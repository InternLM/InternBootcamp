{"kor_rule_num": "10", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 25个密码轮，每个密码轮包含26个字母的不同排列\n    [\n            \"ABCEIGDJFVUYMHTQKZOLRXSPWN\",\n            \"ACDEHFIJKTLMOUVYGZNPQXRWSB\",\n            \"ADKOMJUBGEPHSCZINXFYQRTVWL\",\n            \"AEDCBIFGJHLKMRUOQVPTNWYXZS\",\n            \"AFNQUKDOPITJBRHCYSLWEMZVXG\",\n            \"AGPOCIXLURNDYZHWBJSQFKVMET\",\n            \"AHXJEZBNIKPVROGSYDULCFMQTW\",\n            \"AIHPJOBWKCVFZLQERYNSUMGTDX\",\n            \"AJDSKQOIVTZEFHGYUNLPMBXWCR\",\n            \"AKELBDFJGHONMTPRQSVZUXYWIC\",\n            \"ALTMSXVQPNOHUWDIZYCGKRFBEJ\",\n            \"AMNFLHQGCUJTBYPZKXISRDVEWO\",\n            \"ANCJILDHBMKGXUZTSWQYVORPFE\",\n            \"AODWPKJVIUQHZCTXBLEGNYRSMF\",\n            \"APBVHIYKSGUENTCXOWFQDRLJZM\",\n            \"AQJNUBTGIMWZRVLXCSHDEOKFPY\",\n            \"ARMYOFTHEUSZJXDPCWGQIBKLNV\",\n            \"ASDMCNEQBOZPLGVJRKYTFUIWXH\",\n            \"ATOJYLFXNGWHVCMIRBSEKUPDZQ\",\n            \"AUTRZXQLYIOVBPESNHJWMDGFCK\",\n            \"AVNKHRGOXEYBFSJMUDQCLZWTIP\",\n            \"AWVSFDLIEBHKNRJQZGMXPUCOTY\",\n            \"AXKWREVDTUFOYHMLSIQNJCPGBZ\",\n            \"AYJPXMVKBQWUGLOSTECHNZFRID\",\n            \"AZDNBUHYFWJLVGRCQMPSOEXTKI\"\n        ]\n- 加密步骤:\n    - 初始选择第1个密码轮\n    - 对明文中的每个字符p:\n        - 在当前密码轮上找到字符p，用其后一个字符替换得到密文字符\n        - 如果当前字符在密码轮末尾，则回到密码轮开头\n        - 移动到下一个密码轮处理下一个字符，当到达最后一个密码轮时，返回第一个密码轮继续加密过程", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 25个密码轮，每个密码轮包含26个字母的不同排列\n    [\n            \"ABCEIGDJFVUYMHTQKZOLRXSPWN\",\n            \"ACDEHFIJKTLMOUVYGZNPQXRWSB\",\n            \"ADKOMJUBGEPHSCZINXFYQRTVWL\",\n            \"AEDCBIFGJHLKMRUOQVPTNWYXZS\",\n            \"AFNQUKDOPITJBRHCYSLWEMZVXG\",\n            \"AGPOCIXLURNDYZHWBJSQFKVMET\",\n            \"AHXJEZBNIKPVROGSYDULCFMQTW\",\n            \"AIHPJOBWKCVFZLQERYNSUMGTDX\",\n            \"AJDSKQOIVTZEFHGYUNLPMBXWCR\",\n            \"AKELBDFJGHONMTPRQSVZUXYWIC\",\n            \"ALTMSXVQPNOHUWDIZYCGKRFBEJ\",\n            \"AMNFLHQGCUJTBYPZKXISRDVEWO\",\n            \"ANCJILDHBMKGXUZTSWQYVORPFE\",\n            \"AODWPKJVIUQHZCTXBLEGNYRSMF\",\n            \"APBVHIYKSGUENTCXOWFQDRLJZM\",\n            \"AQJNUBTGIMWZRVLXCSHDEOKFPY\",\n            \"ARMYOFTHEUSZJXDPCWGQIBKLNV\",\n            \"ASDMCNEQBOZPLGVJRKYTFUIWXH\",\n            \"ATOJYLFXNGWHVCMIRBSEKUPDZQ\",\n            \"AUTRZXQLYIOVBPESNHJWMDGFCK\",\n            \"AVNKHRGOXEYBFSJMUDQCLZWTIP\",\n            \"AWVSFDLIEBHKNRJQZGMXPUCOTY\",\n            \"AXKWREVDTUFOYHMLSIQNJCPGBZ\",\n            \"AYJPXMVKBQWUGLOSTECHNZFRID\",\n            \"AZDNBUHYFWJLVGRCQMPSOEXTKI\"\n        ]\n- 加密步骤:\n    - 初始选择第1个密码轮\n    - 对明文中的每个字符p:\n        - 在当前密码轮上找到字符p，用其后一个字符替换得到密文字符\n        - 如果当前字符在密码轮末尾，则回到密码轮开头\n        - 移动到下一个密码轮处理下一个字符，当到达最后一个密码轮时，返回第一个密码轮继续加密过程"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - Reels\n        \n        Reel1:   \"ABCEIGDJFVUYMHTQKZOLRXSPWN\",\n        Reel2:   \"ACDEHFIJKTLMOUVYGZNPQXRWSB\",\n        Reel3:   \"ADKOMJUBGEPHSCZINXFYQRTVWL\",\n        Reel4:   \"AEDCBIFGJHLKMRUOQVPTNWYXZS\",\n        Reel5:   \"AFNQUKDOPITJBRHCYSLWEMZVXG\",\n        Reel6:   \"AGPOCIXLURNDYZHWBJSQFKVMET\",\n        Reel7:    \"AHXJEZBNIKPVROGSYDULCFMQTW\",\n        Reel8:    \"AIHPJOBWKCVFZLQERYNSUMGTDX\",\n        Reel9:    \"AJDSKQOIVTZEFHGYUNLPMBXWCR\",\n        Reel10:   \"AKELBDFJGHONMTPRQSVZUXYWIC\",\n        Reel11:    \"ALTMSXVQPNOHUWDIZYCGKRFBEJ\",\n        Reel12:    \"AMNFLHQGCUJTBYPZKXISRDVEWO\",\n        Reel13:    \"ANCJILDHBMKGXUZTSWQYVORPFE\",\n        Reel14:    \"AODWPKJVIUQHZCTXBLEGNYRSMF\",\n        Reel15:    \"APBVHIYKSGUENTCXOWFQDRLJZM\",\n        Reel16:    \"AQJNUBTGIMWZRVLXCSHDEOKFPY\",\n        Reel17:    \"ARMYOFTHEUSZJXDPCWGQIBKLNV\",\n        Reel18:    \"ASDMCNEQBOZPLGVJRKYTFUIWXH\",\n        Reel19:    \"ATOJYLFXNGWHVCMIRBSEKUPDZQ\",\n        Reel20:    \"AUTRZXQLYIOVBPESNHJWMDGFCK\",\n        Reel21:     \"AVNKHRGOXEYBFSJMUDQCLZWTIP\",\n        Reel22:    \"AWVSFDLIEBHKNRJQZGMXPUCOTY\",\n        Reel23:    \"AXKWREVDTUFOYHMLSIQNJCPGBZ\",\n        Reel24:    \"AYJPXMVKBQWUGLOSTECHNZFRID\",\n        Reel25:    \"AZDNBUHYFWJLVGRCQMPSOEXTKI\"\n        \n- Encryption Steps:\n    - Initially select the Reel1.\n    - For each character p in the plaintext:\n        - Find character p on the Reel and replace it with the next character on the Reel to get the ciphertext character.\n        - If the current character is at the end of the Reel, go around to the beginning of the Reel.\n        - Move to the next Reel to get the next character. When you reach the last Reel, circle back to the first Reel and continue the encryption process.\n\n "]}
{"kor_rule_num": "6", "rule": "请根据加密算法对明文进行加密\n加密规则:\n    - 输入:\n        - 明文: 大写字母字符串,不含标点和空格\n    - 输出:\n        - 密文: 大写字母字符串\n    - 准备:\n        - LETTERS = ['J', 'D', 'W', 'O', 'T', 'R', 'A', 'C', 'X', 'Q', 'M', 'F', 'Y', 'E', 'Z', 'G', 'U', 'K', 'P', 'V', 'B', 'S', 'H', 'N', 'L', 'I']\n        - 将每个字母与其在LETTERS中的位置关联(从0开始):\n            J->0, D->1, W->2, O->3, T->4, R->5, A->6, C->7, X->8, Q->9, M->10, F->11, Y->12, E->13, Z->14, G->15, U->16, K->17, P->18, V->19, B->20, S->21, H->22, N->23, L->24, I->25\n        - 初始卡牌序列:\n            - 54张卡牌的列表,包括52张花色牌和2张可区分的王牌(A王牌和B王牌)。花色牌按四种花色顺序编号1-52,王牌值为53和54。\n            - [9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 53, 26, 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 54, 46, 23, 31, 24, 14, 8, 33, 2, 49, 45, 21]\n        - 密钥流算法:\n            该算法通过移动卡牌生成密钥流值。算法是确定性的,意味着密钥流值仅取决于卡牌的初始顺序。卡牌组被视为循环数组,允许需要移到底部的卡牌绕到顶部。\n            \n            执行以下步骤生成密钥流的一个字符:\n            1. 找到A王牌并下移一位。如果是最后一张牌,则成为第二张牌。不能成为第一张牌。\n            2. 找到B王牌并下移两位。如果是倒数第二张牌,则绕到第二位。如果是最后一张牌,则成为第三张牌。不能成为第一张牌。\n            3. 进行\"三切\":用王牌作为边界将牌组分成三部分,然后交换顶部和底部。王牌本身及其之间的牌保持不变。\n            4. 进行\"计数切\":检查牌组底牌。如果是王牌(53/54),其值固定为53。从牌组顶部取出该数量的牌,插入到最后一张牌的上方。\n            5. 查看顶牌的值。同样,任何王牌计为53。计算该牌下方的位置数,使用该位置的牌值作为下一个密钥流值。如果计算出的牌是王牌,忽略它并重复密钥流算法。\n            6. 返回生成的密钥流值\n    - 加密步骤:\n        - cards=初始卡牌序列\n        - 对每个明文字符p:\n            - 使用字母表将p转换为对应的位置值x(从0开始)\n            - 使用初始卡牌序列为p生成密钥流值y:\n                - y, cards = 密钥流算法(cards)\n                - 该算法修改卡牌顺序,下次执行使用新顺序\n            - 当密钥流值y加到位置值x时,应用模26运算得到z:\n                - z=(y+x) % 26\n            - 使用LETTERS列表返回对应位置z的字母\n            - 将其附加到密文", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n    - 输入:\n        - 明文: 大写字母字符串,不含标点和空格\n    - 输出:\n        - 密文: 大写字母字符串\n    - 准备:\n        - LETTERS = ['J', 'D', 'W', 'O', 'T', 'R', 'A', 'C', 'X', 'Q', 'M', 'F', 'Y', 'E', 'Z', 'G', 'U', 'K', 'P', 'V', 'B', 'S', 'H', 'N', 'L', 'I']\n        - 将每个字母与其在LETTERS中的位置关联(从0开始):\n            J->0, D->1, W->2, O->3, T->4, R->5, A->6, C->7, X->8, Q->9, M->10, F->11, Y->12, E->13, Z->14, G->15, U->16, K->17, P->18, V->19, B->20, S->21, H->22, N->23, L->24, I->25\n        - 初始卡牌序列:\n            - 54张卡牌的列表,包括52张花色牌和2张可区分的王牌(A王牌和B王牌)。花色牌按四种花色顺序编号1-52,王牌值为53和54。\n            - [9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 53, 26, 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 54, 46, 23, 31, 24, 14, 8, 33, 2, 49, 45, 21]\n        - 密钥流算法:\n            该算法通过移动卡牌生成密钥流值。算法是确定性的,意味着密钥流值仅取决于卡牌的初始顺序。卡牌组被视为循环数组,允许需要移到底部的卡牌绕到顶部。\n            \n            执行以下步骤生成密钥流的一个字符:\n            1. 找到A王牌并下移一位。如果是最后一张牌,则成为第二张牌。不能成为第一张牌。\n            2. 找到B王牌并下移两位。如果是倒数第二张牌,则绕到第二位。如果是最后一张牌,则成为第三张牌。不能成为第一张牌。\n            3. 进行\"三切\":用王牌作为边界将牌组分成三部分,然后交换顶部和底部。王牌本身及其之间的牌保持不变。\n            4. 进行\"计数切\":检查牌组底牌。如果是王牌(53/54),其值固定为53。从牌组顶部取出该数量的牌,插入到最后一张牌的上方。\n            5. 查看顶牌的值。同样,任何王牌计为53。计算该牌下方的位置数,使用该位置的牌值作为下一个密钥流值。如果计算出的牌是王牌,忽略它并重复密钥流算法。\n            6. 返回生成的密钥流值\n    - 加密步骤:\n        - cards=初始卡牌序列\n        - 对每个明文字符p:\n            - 使用字母表将p转换为对应的位置值x(从0开始)\n            - 使用初始卡牌序列为p生成密钥流值y:\n                - y, cards = 密钥流算法(cards)\n                - 该算法修改卡牌顺序,下次执行使用新顺序\n            - 当密钥流值y加到位置值x时,应用模26运算得到z:\n                - z=(y+x) % 26\n            - 使用LETTERS列表返回对应位置z的字母\n            - 将其附加到密文"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - LETTERS = ['J', 'D', 'W', 'O', 'T', 'R', 'A', 'C', 'X', 'Q', 'M', 'F', 'Y',\n    'E', 'Z', 'G', 'U', 'K', 'P', 'V', 'B', 'S', 'H', 'N', 'L', 'I']\n    - Associate each letter with its position in the LETTERS (starting from 0):\n        \n        J -> 0, D -> 1, W -> 2, O -> 3, T -> 4, R -> 5, A -> 6, C -> 7, X -> 8, Q -> 9,\n        M -> 10, F -> 11, Y -> 12, E -> 13, Z -> 14, G -> 15, U -> 16, K -> 17, P -> 18,\n        V -> 19, B -> 20, S -> 21, H -> 22, N -> 23, L -> 24, I -> 25\n        \n    - Initial sequence of cards:\n        - A list of 54 numbers, including a randomly shuffled deck consisting of 52 suited cards and two distinguishable jokers known as the A Joker and B Joker. Suited cards are valued sequentially across four suits: Clubs, Diamonds, Hearts, and Spades, with values ranging from 1 to 52, while the jokers are valued 53 and 54.\n        - [9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 53, 26, 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 54, 46, 23, 31, 24, 14, 8, 33, 2, 49, 45, 21]\n    - **Keystream Algorithm**\n        \n        This algorithm generates keystream values by moving cards within a deck. The keystream algorithm is *deterministic*, meaning keystream values depend solely on the initial order of the deck. The deck is treated as a circular array, allowing a card that needs to move below the bottom card to wrap around to the top (in other words, the first card follows the last card).\n        \n        For example, starting with:\n        9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 53, 26, 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 54, 46, 23, 31, 24, 14, 8, 33, 2, 49, 45, 21\n        \n        Perform the following steps to generate a character of the keystream:\n        \n        1. Locate card A and move it down by one position. If it's the last card, it becomes the second card. It cannot become the first card. The deck now looks like this:\n        9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 26, **53,** 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 54, 46, 23, 31, 24, 14, 8, 33, 2, 49, 45, 21\n        2. Locate card B and move it down by two positions. Note, if it's the second last card, it will wrap around to become the second card. If it's the last card, it will become the third card. It cannot become the first card. The deck now looks like this:\n        9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 26, **53,** 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 46, 23, **54,** 31, 24, 14, 8, 33, 2, 49, 45, 21\n        3. Perform a \"triple cut\": Divide the deck into three parts, using the jokers as boundaries, then swap the top and bottom parts. The jokers themselves and the cards between them remain unchanged.\n        31, 24, 14, 8, 33, 2, 49, 45, 21, **53,** 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 46, 23, **54,** 9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 26\n        4. Perform a \"count cut\": Examine the bottom card of the deck. If it's a joker (53/54), its value remains fixed at 53. Take out that many cards from the top of the deck and insert them just above the last card of the deck.\n        29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 46, 23, **54,** 9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, **31, 24, 14, 8, 33, 2, 49, 45, 21,** 53, 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 26\n        5. Now, look at the value of the top card. Similarly, any joker counts as 53. Calculate the number of positions below this card, and use that card's value as the next value in the keystream. If the calculated card is a joker, ignore it and repeat the keystream algorithm. In this example, the top card is 29, so the value of the 30th card (i.e., 14) determines the keystream value. (Note that no cards change position in this step; this step only determines the keystream value).\n        6. Return the resulting keystream value: 14\n- Encryption Steps:\n    - cards=Initial sequence of cards\n    - For each given plaintext character p:\n        - Use the alphabet to convert p to the corresponding positional value x. (starting from 0).\n        - Generate a keystream value y for p using the Initial sequence of cards:\n            - y, cards = Keystream Algorithm (cards)\n            - This algorithm modifies the order of the pile of cards, and the next execution then uses the new order.\n        - When the keystream value y is added to the position value x, the mod 26 operation is applied to obtain z:\n            - z=(y+x) % 26\n        - Use the LETTERS list to return the letter corresponding to position z.\n        - Append it to the ciphertext.\n\n "]}
{"kor_rule_num": "2", "rule": "请根据加密算法对明文进行加密\n\n加密规则:\n\n输入:\n    - 明文: 仅包含大写字母的字符串，不含标点符号和空格。\n输出:\n    - 密文: 大写字母字符串。\n准备:\n    - 加密表 = {\n    'A': '!', 'B': '@', 'C': '#', 'D': '$',\n    'E': '%', 'F': '^', 'G': '&', 'H': '*',\n    'I': '(', 'J': ')', 'K': '_', 'L': '+',\n    'M': '=', 'N': '~', 'O': '?', 'P': '/',\n    'Q': '0', 'R': ':', 'S': ';', 'T': '<',\n    'U': '>', 'V': '1', 'W': '2', 'X': '3',\n    'Y': '4', 'Z': '5'\n    }\n加密步骤:\n    - 对于每个给定的明文字符 p:\n        - 如果 p 是大写字母且存在于加密表中:\n            - 用加密表中对应的符号替换 p。\n    ", "replace": ["请根据加密算法对明文进行加密\n\n加密规则:\n\n输入:\n    - 明文: 仅包含大写字母的字符串，不含标点符号和空格。\n输出:\n    - 密文: 大写字母字符串。\n准备:\n    - 加密表 = {\n    'A': '!', 'B': '@', 'C': '#', 'D': '$',\n    'E': '%', 'F': '^', 'G': '&', 'H': '*',\n    'I': '(', 'J': ')', 'K': '_', 'L': '+',\n    'M': '=', 'N': '~', 'O': '?', 'P': '/',\n    'Q': '0', 'R': ':', 'S': ';', 'T': '<',\n    'U': '>', 'V': '1', 'W': '2', 'X': '3',\n    'Y': '4', 'Z': '5'\n    }\n加密步骤:\n    - 对于每个给定的明文字符 p:\n        - 如果 p 是大写字母且存在于加密表中:\n            - 用加密表中对应的符号替换 p。\n    "], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - encryption_table = {\n    'A': '!', 'B': '@', 'C': '#', 'D': '$',\n    'E': '%', 'F': '^', 'G': '&', 'H': '*',\n    'I': '(', 'J': ')', 'K': '_', 'L': '+',\n    'M': '=', 'N': '~', 'O': '?', 'P': '/',\n    'Q': '0', 'R': ':', 'S': ';', 'T': '<',\n    'U': '>', 'V': '1', 'W': '2', 'X': '3',\n    'Y': '4', 'Z': '5'\n    }\n- Encryption Steps:\n    - For each given plaintext character p:\n        - If `p` is an uppercase letter and exists in the encryption table:\n            - Replace `p` with the corresponding symbol from the encryption table.\n\n "]}
{"kor_rule_num": "23", "rule": "请根据加密算法对明文进行加密\n\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 准备:\n    - e: 263\n    - n: 299\n- 加密步骤:\n    - 对明文中的每个字母p:\n        - 获取字母p对应的ASCII码的十进制数x\n        - 计算x^e mod n作为该字母的密文数字y，这里^表示乘法运算\n    - 最后，将所有y用逗号连接形成最终密文\n", "replace": ["请根据加密算法对明文进行加密\n\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 准备:\n    - e: 263\n    - n: 299\n- 加密步骤:\n    - 对明文中的每个字母p:\n        - 获取字母p对应的ASCII码的十进制数x\n        - 计算x^e mod n作为该字母的密文数字y，这里^表示乘法运算\n    - 最后，将所有y用逗号连接形成最终密文\n"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  A sequence of numbers separated by ,. For example, \"y1,y2,…\".\n- Preparation:\n    - e: 263\n    - n: 299\n- Encryption Steps:\n    - For each letter p in the plaintext:\n        - Get the decimal number x of the value corresponding to the ascii code of p.\n        - Compute x^e mod n as the ciphertext number y for that letter p . Here ^ denotes the multiplication operation.\n    - Finally, concatenate all the y's and separate them with commas for the final ciphertext.\n\n "]}
{"kor_rule_num": "8", "rule": "请根据加密算法对明文进行加密\n加密规则:\n输入:\n    - 明文: 大写字母字符串，不含标点和空格\n    - 密钥: 用于选择替换表的字符串\n输出:\n    - 密文: 大写字母字符串\n准备工作:\n    - 密码替换表:\n        使用以下13个密码替换表，每个表对应两个字母:\n        AB: NOPQRSTUVWXYZABCDEFGHIJKLM\n        CD: ZNOPQRSTUVWXYBCDEFGHIJKLMA\n        EF: YZNOPQRSTUVWXCDEFGHIJKLMAB\n        GH: XYZNOPQRSTUVWDEFGHIJKLMABC\n        IJ: WXYZNOPQRSTUVEFGHIJKLMABCD\n        KL: VWXYZNOPQRSTUFGHIJKLMABCDE\n        MN: UVWXYZNOPQRSTGHIJKLMABCDEF\n        OP: TUVWXYZNOPQRSHIJKLMABCDEFG\n        QR: STUVWXYZNOPQRIJKLMABCDEFGH\n        ST: RSTUVWXYZNOPQJKLMABCDEFGHI\n        UV: QRSTUVWXYZNOPKLMABCDEFGHIJ\n        WX: PQRSTUVWXYZNOLMABCDEFGHIJK\n        YZ: OPQRSTUVWXYZNMABCDEFGHIJKL\n    - 标准字母表:\n        ABCDEFGHIJKLMNOPQRSTUVWXYZ\n加密步骤:\n    - 将密钥中的每个字母与明文中的每个字母配对。如果密钥比明文短，重复使用密钥\n    - 对于每个明文字符p:\n        - 根据与之配对的密钥字母找到对应的密码替换表\n        - 在标准字母表中找到p的位置，用密码替换表中相同位置的字母替换它", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n输入:\n    - 明文: 大写字母字符串，不含标点和空格\n    - 密钥: 用于选择替换表的字符串\n输出:\n    - 密文: 大写字母字符串\n准备工作:\n    - 密码替换表:\n        使用以下13个密码替换表，每个表对应两个字母:\n        AB: NOPQRSTUVWXYZABCDEFGHIJKLM\n        CD: ZNOPQRSTUVWXYBCDEFGHIJKLMA\n        EF: YZNOPQRSTUVWXCDEFGHIJKLMAB\n        GH: XYZNOPQRSTUVWDEFGHIJKLMABC\n        IJ: WXYZNOPQRSTUVEFGHIJKLMABCD\n        KL: VWXYZNOPQRSTUFGHIJKLMABCDE\n        MN: UVWXYZNOPQRSTGHIJKLMABCDEF\n        OP: TUVWXYZNOPQRSHIJKLMABCDEFG\n        QR: STUVWXYZNOPQRIJKLMABCDEFGH\n        ST: RSTUVWXYZNOPQJKLMABCDEFGHI\n        UV: QRSTUVWXYZNOPKLMABCDEFGHIJ\n        WX: PQRSTUVWXYZNOLMABCDEFGHIJK\n        YZ: OPQRSTUVWXYZNMABCDEFGHIJKL\n    - 标准字母表:\n        ABCDEFGHIJKLMNOPQRSTUVWXYZ\n加密步骤:\n    - 将密钥中的每个字母与明文中的每个字母配对。如果密钥比明文短，重复使用密钥\n    - 对于每个明文字符p:\n        - 根据与之配对的密钥字母找到对应的密码替换表\n        - 在标准字母表中找到p的位置，用密码替换表中相同位置的字母替换它"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n    - Key: The key is a string used to select the alphabets. Each letter in the key will be used to select the corresponding alphabet for encryption or decryption.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - Cipher Alphabets\n        \n        Use the following 13 cipher alphabets, each associated with two letters:\n        AB: NOPQRSTUVWXYZABCDEFGHIJKLM\n        CD: ZNOPQRSTUVWXYBCDEFGHIJKLMA\n        EF: YZNOPQRSTUVWXCDEFGHIJKLMAB\n        GH: XYZNOPQRSTUVWDEFGHIJKLMABC\n        IJ: WXYZNOPQRSTUVEFGHIJKLMABCD\n        KL: VWXYZNOPQRSTUFGHIJKLMABCDE\n        MN: UVWXYZNOPQRSTGHIJKLMABCDEF\n        OP: TUVWXYZNOPQRSHIJKLMABCDEFG\n        QR: STUVWXYZNOPQRIJKLMABCDEFGH\n        ST: RSTUVWXYZNOPQJKLMABCDEFGHI\n        UV: QRSTUVWXYZNOPKLMABCDEFGHIJ\n        WX: PQRSTUVWXYZNOLMABCDEFGHIJK\n        YZ: OPQRSTUVWXYZNMABCDEFGHIJKL\n        \n    - Standard Alphabet\n        - ABCDEFGHIJKLMNOPQRSTUVWXYZ\n- Encryption Steps:\n    - Pair each letter in the key with each letter in the plaintext. If the key is shorter than the plaintext, repeat the key.\n    - For each given plaintext character p:\n        - Find the corresponding cipher alphabet based on the key letter paired with it. If the key letter is A, mark the choice AB: NOPQRSTUVWXYZABCDEFGHIJKLM\n        - Find the position of p in the standard alphabet and replace it with the letter at the same position in the cipher alphabet.\n\n "]}
{"kor_rule_num": "17", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 不含标点和空格的字符串\n- 准备:\n    - 每行最大字符数: 5\n- 加密步骤:\n    - 行数从1开始计数\n    - 明文按特殊方式排列：奇数行从左到右写，偶数行从右到左写，每行最多五个字母\n        - 例如，对于明文\"LIDAHELLOWORLD\"，先从左到右写第一行为LIDAH，然后从右到左写第二行为WOLLE，然后从左到右写第三行为ORLD，写完的全部内容表示如下\n        LIDAH\n        WOLLE\n        ORLD\n    - 然后按列读取，每列从上到下读取，每读完一列加一个\"#\"，读出的内容即为最终密文\n        - 例如，上述写好的内容按列读取为LWO#IOR#DLL#ALD#HE#", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 不含标点和空格的字符串\n- 准备:\n    - 每行最大字符数: 5\n- 加密步骤:\n    - 行数从1开始计数\n    - 明文按特殊方式排列：奇数行从左到右写，偶数行从右到左写，每行最多五个字母\n        - 例如，对于明文\"LIDAHELLOWORLD\"，先从左到右写第一行为LIDAH，然后从右到左写第二行为WOLLE，然后从左到右写第三行为ORLD，写完的全部内容表示如下\n        LIDAH\n        WOLLE\n        ORLD\n    - 然后按列读取，每列从上到下读取，每读完一列加一个\"#\"，读出的内容即为最终密文\n        - 例如，上述写好的内容按列读取为LWO#IOR#DLL#ALD#HE#"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  A string without punctuation and spaces.\n- Preparation:\n    - Maximum number of characters per line: 5\n- Encryption Steps:\n    - Lines are counted from 1.\n    - The plaintext is arranged in a special way: an odd number of lines are written from left to right, and an even number of lines are written from right to left, with a maximum of five letters per line.\n        - For example, for the plaintext \"LIDAHELLOWORLD\", first write the first line, from left to right as LIDAH, and then write the second line, from right to left as WOLLE, and then write the third line, from left to right as ORLD, the entire content of the finished writing is expressed as follows\n        LIDAH\n        WOLLE\n        ORLD\n    - Then read by column, each column is read from the top down, each read a column plus a \"#\", read out the contents of the final ciphertext.\n        - For example, the above written content is read as LWO#IOR#DLL#ALD#HE# by column.\n\n "]}
{"kor_rule_num": "18", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 网格和模板:\n        - 准备一个空白网格和一个带孔的模板(栅栏)\n        - 使用的模板是:\n            ▮ ▮ ▮ ▮\n            ▮ ▮ ▯ ▯\n            ▮ ▮ ▮ ▯\n            ▯ ▮ ▮ ▮\n            其中白色的是孔，将模板放在空白网格上，只通过白色孔洞，在网格的对应位置填入字符。\n- 加密步骤:\n    - 将明文逐个分成16个字母的块(如果明文少于16个长度则为一个块)\n    - 对每个块执行以下加密操作:\n        - 将带孔的模板放在空白网格上\n        - 通过模板中的孔按顺序填入明文字母\n        - 模板总共有四个孔，所以填完四个字母后，需要将模板逆时针旋转90度\n        - 重复填充可见孔中的明文下一个字母并旋转模板，直到整个网格完全填满。这将执行4次填充+旋转，最终模板会转回原始模板。如果消息不足以填满整个网格，用填充字符(如'#')补充\n        - 网格填满后，按行读取网格内容作为该块的加密消息\n        - 进入下一个块时，清空网格内容并重做整个填充和旋转操作\n    最后，将所有块的加密消息连接在一起作为最终密文。\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 明文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 网格和模板(与加密相同)\n- 解密步骤(与加密步骤完全相反):\n    - 将密文逐个分成16个字母的块\n    - 对每个块执行以下操作:\n        - 将16个字母按行写入填满网格\n        - 将带孔的模板放在填满的网格上\n        - 读取通过孔可见的字母获得部分明文消息\n        - 由于只有四个孔，此时需要将模板逆时针旋转90度读取下一组字母\n        - 重复读取步骤四次以获得这块解密消息\n    - 连接所有块的解密消息得到最终明文。", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 网格和模板:\n        - 准备一个空白网格和一个带孔的模板(栅栏)\n        - 使用的模板是:\n            ▮ ▮ ▮ ▮\n            ▮ ▮ ▯ ▯\n            ▮ ▮ ▮ ▯\n            ▯ ▮ ▮ ▮\n            其中白色的是孔，将模板放在空白网格上，只通过白色孔洞，在网格的对应位置填入字符。\n- 加密步骤:\n    - 将明文逐个分成16个字母的块(如果明文少于16个长度则为一个块)\n    - 对每个块执行以下加密操作:\n        - 将带孔的模板放在空白网格上\n        - 通过模板中的孔按顺序填入明文字母\n        - 模板总共有四个孔，所以填完四个字母后，需要将模板逆时针旋转90度\n        - 重复填充可见孔中的明文下一个字母并旋转模板，直到整个网格完全填满。这将执行4次填充+旋转，最终模板会转回原始模板。如果消息不足以填满整个网格，用填充字符(如'#')补充\n        - 网格填满后，按行读取网格内容作为该块的加密消息\n        - 进入下一个块时，清空网格内容并重做整个填充和旋转操作\n    最后，将所有块的加密消息连接在一起作为最终密文。\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 明文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 网格和模板(与加密相同)\n- 解密步骤(与加密步骤完全相反):\n    - 将密文逐个分成16个字母的块\n    - 对每个块执行以下操作:\n        - 将16个字母按行写入填满网格\n        - 将带孔的模板放在填满的网格上\n        - 读取通过孔可见的字母获得部分明文消息\n        - 由于只有四个孔，此时需要将模板逆时针旋转90度读取下一组字母\n        - 重复读取步骤四次以获得这块解密消息\n    - 连接所有块的解密消息得到最终明文。"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  Uppercase letters  string without punctuation and spaces.\n- Preparation:\n    - Grid and Template:\n        - Prepare a blank grid and a template with holes (fence).\n        - The template used is:\n            \n            ▮  ▮  ▮  ▮\n            ▮  ▮  ▯  ▯\n            ▮  ▮  ▮  ▯\n            ▯  ▮  ▮  ▮\n            \n            Where the white ones are holes, place the template on a blank grid, only through the white holes, and fill in the corresponding positions of the grid with characters.\n            \n- Encryption Steps:\n    - Divide the plaintext into blocks of 16 letters one by one.(If the plaintext is less than 16 long it is one  block)\n        - For example, the plaintext message \"LOVEHELLOWORLD\" is less than 16 and is one block.\n    - For each block, perform the following encryption operation:\n        - Place the template with holes on the blank grid.\n        - Fill the grid with the letters of the plaintext message in order through the holes in the template.\n            - For example, the plaintext is \"LOVEHELLOWORLD\", through the four holes, after filling in the LOVE grid is\n                \n                [['', '', '', ''],\n                ['', '', 'L', 'O'],\n                ['', '', '', 'V'],\n                ['E', '', '', '']]\n                \n        - The template has a total of four holes, so after filling out the four letters, it can not be filled out, then you need to rotate the template counterclockwise 90 degrees.\n            - For example, after filling in LOVE after rotating the template after the template for:\n                \n                ▮  ▯  ▯  ▮\n                ▮  ▯  ▮  ▮\n                ▮  ▮  ▮  ▮\n                ▮  ▮  ▮  ▯\n                \n        - Repeat filling the visible holes in the grid with the next letter of the plaintext message and rotating the template until the entire grid is completely filled. This will perform 4 fills + rotations and eventually the template will turn to the original template. If the message is not enough to fill the entire grid, it is made up with filler characters (e.g. '#').\n            - For example, if the plain text is \"LOVEHELLOWORLD\", after several fills and rotations, the final grid will be\n                \n                [['L', 'H', 'E', 'O'],\n                ['W', 'L', 'L', 'O'],\n                ['O', 'R', 'D', 'V'],\n                ['E', '#', '#', 'L']]\n                \n        - Once the grid is filled, read the contents of the grid line by line as the encrypted message for that block.\n        - When moving on to the next block, empty the contents of the grid and redo the entire fill and rotate operation.\n        \n        Finally, the encrypted messages of all the blocks are connected together to be the final ciphertext.\n        \n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters  string without punctuation and spaces.\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - Grid and Template (Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - Divide the ciphertext into blocks of 16 letters one by one.\n    - For each block, perform the following operations:\n        - Write the 16 letters row by row to fill the grid.\n        - Place the template with holes on the filled grid.\n        - Read the letters visible through the holes to get a portion of the plaintext message.\n        - Since there are only four holes, at this point you need to rotate the template 90 degrees counterclockwise to read the next set of letters.\n        - Repeat the reading step four times to get this fast decrypted message.\n    - Connecting the decrypted messages of all the blocks gives the final plaintext."]}
{"kor_rule_num": "16", "rule": "请根据加密算法对明文进行加密\n\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的字符串\n- 准备:\n    - 行数: 5\n- 加密步骤:\n    - 在第一行第一个位置填入第一个明文字母\n    - 两种填充方式:\n        - 向下填充: 在第一行填入\"#\"(除去第一列，因为第一个位置已经填入明文字母)，然后从第二行到最后一行(第五行)向下填充明文\n        - 向上填充: 从最后一行(第五行)到第二行向上填充明文，然后在第一行填入\"#\"\n    - 对于明文中的每个字母(除了已经填在第一个位置的第一个字母)，先进行向下填充，填满一列，然后转向上填充，再转向下填充，如此交替进行，直到所有字母都被填入\n    - 填写完成后，逐行读取，读取每行内容后都添加一个*号，标记行的结束；然后读取第二行内容，依此类推，读取所有行，形成最终密文\n", "replace": ["请根据加密算法对明文进行加密\n\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的字符串\n- 准备:\n    - 行数: 5\n- 加密步骤:\n    - 在第一行第一个位置填入第一个明文字母\n    - 两种填充方式:\n        - 向下填充: 在第一行填入\"#\"(除去第一列，因为第一个位置已经填入明文字母)，然后从第二行到最后一行(第五行)向下填充明文\n        - 向上填充: 从最后一行(第五行)到第二行向上填充明文，然后在第一行填入\"#\"\n    - 对于明文中的每个字母(除了已经填在第一个位置的第一个字母)，先进行向下填充，填满一列，然后转向上填充，再转向下填充，如此交替进行，直到所有字母都被填入\n    - 填写完成后，逐行读取，读取每行内容后都添加一个*号，标记行的结束；然后读取第二行内容，依此类推，读取所有行，形成最终密文\n"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  A string without punctuation and spaces.\n- Preparation:\n    - Number of lines: 5\n- Encryption Steps:\n    - Fill in the first plaintext in the first position of the first line.\n    - Two ways to fill:\n        - Downward Fill: Fill the first row with a \"#\" (removing the first column, since the first position is already filled with a plaintext letter), then fill the plaintext downwards from the second row to the last row (fifth row).\n        - Upwards: the plaintext is filled upwards from the last line (fifth line) to the second line, and then the first line is filled with a \"#\".\n    - For each letter in the plaintext (except the first letter which has been filled in the first position), perform downward padding first, fill one column, then turn to upward padding, then turn to downward padding, and so on alternately, until all the letters have been filled.\n        - For example, HELLOWORLD.The content of the five lines after filling is\n        H L #\n        E R D\n        L O\n        L W\n        O #\n    - Filled out, read line by line, first read the contents of the first line, after reading the contents of each line are added a * sign, marking the end of the line; and then read the contents of the second line, and so on, read all the lines, the formation of the final password text.\n        H L #\n        E R D\n        L O\n        L W\n        O #\n        - Read the final cipher text line by line as \"HL#*ERD*LO*LW*O#*\" (i.e., there must be five *'s in the final cipher text to indicate that there are five lines)\n\n "]}
{"kor_rule_num": "16", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的字符串\n- 准备:\n    - 行数: 5\n- 加密步骤:\n    - 在第一行第一个位置填入第一个明文字母\n    - 两种填充方式:\n        - 向下填充: 在第一行填入\"#\"(除去第一列，因为第一个位置已经填入明文字母)，然后从第二行到最后一行(第五行)向下填充明文\n        - 向上填充: 从最后一行(第五行)到第二行向上填充明文，然后在第一行填入\"#\"\n    - 对于明文中的每个字母(除了已经填在第一个位置的第一个字母)，先进行向下填充，填满一列，然后转向上填充，再转向下填充，如此交替进行，直到所有字母都被填入\n    - 填写完成后，逐行读取，读取每行内容后都添加一个*号，标记行的结束；然后读取第二行内容，依此类推，读取所有行，形成最终密文\n\n解密算法:\n\n解密规则:\n- 输入:\n    - 密文: 不含标点和空格的字符串\n- 输出:\n    - 明文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 行数: 5\n- 解密步骤:\n    - 根据密文中的*(不包括*号)，可以分成五组，依次填入五行。得到恢复的五行数据\n    - 然后按照先向下读再向上读交替的方式读取所有列。得到未清理的消息\n    - 从未清理的消息中删除#，得到最终明文\n", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的字符串\n- 准备:\n    - 行数: 5\n- 加密步骤:\n    - 在第一行第一个位置填入第一个明文字母\n    - 两种填充方式:\n        - 向下填充: 在第一行填入\"#\"(除去第一列，因为第一个位置已经填入明文字母)，然后从第二行到最后一行(第五行)向下填充明文\n        - 向上填充: 从最后一行(第五行)到第二行向上填充明文，然后在第一行填入\"#\"\n    - 对于明文中的每个字母(除了已经填在第一个位置的第一个字母)，先进行向下填充，填满一列，然后转向上填充，再转向下填充，如此交替进行，直到所有字母都被填入\n    - 填写完成后，逐行读取，读取每行内容后都添加一个*号，标记行的结束；然后读取第二行内容，依此类推，读取所有行，形成最终密文\n\n解密算法:\n\n解密规则:\n- 输入:\n    - 密文: 不含标点和空格的字符串\n- 输出:\n    - 明文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 行数: 5\n- 解密步骤:\n    - 根据密文中的*(不包括*号)，可以分成五组，依次填入五行。得到恢复的五行数据\n    - 然后按照先向下读再向上读交替的方式读取所有列。得到未清理的消息\n    - 从未清理的消息中删除#，得到最终明文\n"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  A string without punctuation and spaces.\n- Preparation:\n    - Number of lines: 5\n- Encryption Steps:\n    - Fill in the first plaintext in the first position of the first line.\n    - Two ways to fill:\n        - Downward Fill: Fill the first row with a \"#\" (removing the first column, since the first position is already filled with a plaintext letter), then fill the plaintext downwards from the second row to the last row (fifth row).\n        - Upwards: the plaintext is filled upwards from the last line (fifth line) to the second line, and then the first line is filled with a \"#\".\n    - For each letter in the plaintext (except the first letter which has been filled in the first position), perform downward padding first, fill one column, then turn to upward padding, then turn to downward padding, and so on alternately, until all the letters have been filled.\n        - For example, HELLOWORLD.The content of the five lines after filling is\n        H L #\n        E R D\n        L O\n        L W\n        O #\n    - Filled out, read line by line, first read the contents of the first line, after reading the contents of each line are added a * sign, marking the end of the line; and then read the contents of the second line, and so on, read all the lines, the formation of the final password text.\n        H L #\n        E R D\n        L O\n        L W\n        O #\n        - Read the final cipher text line by line as \"HL#*ERD*LO*LW*O#*\" (i.e., there must be five *'s in the final cipher text to indicate that there are five lines)\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: A string without punctuation and spaces.\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - Number of lines: 5\n- Decryption Steps (exact opposite of encryption steps):\n    - According to the * in the ciphertext (excluding the * sign), it can be divided into five groups, which are filled into five rows in turn. Get the recovered data in five rows.\n        - For example, like \"HL#*ERD*LO*LW*O#*\" ,according to the division of * and then fill in the five lines to get the recovered five lines of data D:\n            H L #\n            E R D\n            L O\n            L W\n            O #\n    - Then read all the columns alternately according to read down first and then read up. Get the uncleared messages.\n        - For example, for the five rows of message D in the previous step, read alternately to get \"HELLO#WORL#D\"\n    - Remove the # from the uncleaned message to get the final plaintext."]}
{"kor_rule_num": "1", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 标准字母表: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    - 反转字母表: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    - 替换字母表: \"RFDJUHABCEGIKLMNOPQSTVWXYZ\"\n- 加密步骤:\n    - 对明文中的每个字母p:\n    - (1) 使用反转字母表进行反向映射。在标准字母表中找到其位置，并用反转字母表中对应位置的字母替换。例如，A映射为Z，B映射为Y。\n    - (2) 将步骤(1)得到的字母在标准字母表顺序中向前移动4位。例如，如果p=A，经过步骤(1)映射为Z，然后Z在标准字母表中向前移动4位得到D。\n    - (3) 将步骤(2)得到的字母，在标准字母表中找到其位置，用替换字母表中对应位置的字母替换，得到最终的密文字母。例如，如果经过步骤(2)得到字母D，则映射为J。", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 标准字母表: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    - 反转字母表: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    - 替换字母表: \"RFDJUHABCEGIKLMNOPQSTVWXYZ\"\n- 加密步骤:\n    - 对明文中的每个字母p:\n    - (1) 使用反转字母表进行反向映射。在标准字母表中找到其位置，并用反转字母表中对应位置的字母替换。例如，A映射为Z，B映射为Y。\n    - (2) 将步骤(1)得到的字母在标准字母表顺序中向前移动4位。例如，如果p=A，经过步骤(1)映射为Z，然后Z在标准字母表中向前移动4位得到D。\n    - (3) 将步骤(2)得到的字母，在标准字母表中找到其位置，用替换字母表中对应位置的字母替换，得到最终的密文字母。例如，如果经过步骤(2)得到字母D，则映射为J。"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - standard_alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    - reversed_alphabet: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    - substitution_alphabet: \"RFDJUHABCEGIKLMNOPQSTVWXYZ\"\n- Encryption Steps:\n    - For each letter p in the given Plaintext:\n    - (1) Use reversed_alphabet for reverse mapping. Find its position in the standard_alphabet and replace it with the letter in the corresponding position in reversed_alphabet. For example, A is mapped to Z and B is mapped to Y.\n    - (2) Move the letter obtained in (1) forward 4 places in the standard_alphabet order. For example, if p=A, after (1) is mapped to Z, then Z is shifted forward 4 positions in the standard_alphabet to get D.\n    - (3) Replace the letter obtained from (2) by finding its position in standard_alphabet and using the corresponding letter in substitution_alphabet, resulting in the final ciphertext letter. For example, if the letter obtained by going through (2) is D, it is mapped as J.\n\n"]}
{"kor_rule_num": "9", "rule": "请根据加密算法对明文进行加密\n\n加密规则:\n\n输入:\n- 明文: 大写字母字符串，不含标点和空格\n- period: 定义内圈多久旋转一次。周期性表示在加密过程中每处理指定数量的字符后，内圈将根据增量值旋转一次\n- increment: 定义内圈每次旋转的字符数。在每个周期结束时，内圈将根据增量值向右旋转相应数量的字符\n\n输出:\n- 密文: 大写字母字符串\n\n准备:\n- outer_disk = \"QWERTYUIOPASDFGHJZXCVBNMKL\"\n- inner_disk = \"JKLZXCVBNMASDFGHJQWERTYUIO\"\n\n加密步骤:\n- 对明文中的每个字符p:\n    - 在外圈找到该字符\n    - 用内圈对应位置的字符替换它\n    - 每加密period个字符后，将内圈向右旋转increment个字符。例如，将'ZXCVBNMASDFGHJKLQWERTYUIOP'旋转4位得到'BNMASDFGHJKLQWERTYUIOPZXCV'\n        ", "replace": ["请根据加密算法对明文进行加密\n\n加密规则:\n\n输入:\n- 明文: 大写字母字符串，不含标点和空格\n- period: 定义内圈多久旋转一次。周期性表示在加密过程中每处理指定数量的字符后，内圈将根据增量值旋转一次\n- increment: 定义内圈每次旋转的字符数。在每个周期结束时，内圈将根据增量值向右旋转相应数量的字符\n\n输出:\n- 密文: 大写字母字符串\n\n准备:\n- outer_disk = \"QWERTYUIOPASDFGHJZXCVBNMKL\"\n- inner_disk = \"JKLZXCVBNMASDFGHJQWERTYUIO\"\n\n加密步骤:\n- 对明文中的每个字符p:\n    - 在外圈找到该字符\n    - 用内圈对应位置的字符替换它\n    - 每加密period个字符后，将内圈向右旋转increment个字符。例如，将'ZXCVBNMASDFGHJKLQWERTYUIOP'旋转4位得到'BNMASDFGHJKLQWERTYUIOPZXCV'\n        "], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n    - period: Defines how often the inner disc rotates. Periodicity indicates that after every number of characters processed in the encryption process, the inner disc will rotate once according to the incremental value.\n    - increment: Defines the number of characters the inner disc rotates each time. At the end of each cycle, the inner disc will rotate to the right by the corresponding number of characters based on the increment value. For example, if the increment is 4, the inner disc will rotate 4 characters to the right for each cycle that passes (e.g., 5 characters are processed).\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - outer_disk = \"QWERTYUIOPASDFGHJZXCVBNMKL\"\n    - inner_disk = \"JKLZXCVBNMASDFGHJQWERTYUIO\"\n- Encryption Steps:\n    - For each character p in the plaintext:\n        - Find the character in the outer_disk.\n        - Replace it with the character at the corresponding position on the inner_disk.\n        - After encrypting every `period` characters, rotate the inner_disk to the right by `increment` characters.For example, rotating 'ZXCVBNMASDFGHJKLQWERTYUIOP' by 4 gives 'BNMASDFGHJKLQWERTYUIOPZXCV'.\n\n "]}
{"kor_rule_num": "24", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 准备:\n    - k_q_x值: 12\n- 加密步骤:\n    - 对明文中的每个字母p:\n        - 获取字母p对应的ASCII码值x\n        - 计算x * k_q_x作为该字母对应的密文数字y\n    - 最后将所有y值用逗号连接得到最终密文\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 输出:\n    - 明文: 不含标点和空格的大写字母字符串\n- 准备:\n    - k_q_x值: 12\n- 解密步骤:\n    - 对密文中的每个数字c:\n        - 计算z = c // k_q_x，其中//表示整数除法运算，返回商的整数部分\n        - 根据z对应的ASCII码值找到对应的字母作为明文字母p\n    - 最后将所有p连接得到最终明文", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 准备:\n    - k_q_x值: 12\n- 加密步骤:\n    - 对明文中的每个字母p:\n        - 获取字母p对应的ASCII码值x\n        - 计算x * k_q_x作为该字母对应的密文数字y\n    - 最后将所有y值用逗号连接得到最终密文\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 输出:\n    - 明文: 不含标点和空格的大写字母字符串\n- 准备:\n    - k_q_x值: 12\n- 解密步骤:\n    - 对密文中的每个数字c:\n        - 计算z = c // k_q_x，其中//表示整数除法运算，返回商的整数部分\n        - 根据z对应的ASCII码值找到对应的字母作为明文字母p\n    - 最后将所有p连接得到最终明文"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  A sequence of numbers separated by ,. For example, \"y1,y2,…\".\n- Preparation:\n    - k_q_x : 12\n- Encryption Steps:\n    - For each letter p in the plaintext:\n        - Get the decimal number x corresponding to the ascii code of p.\n        - Calculate x * k_q_x as the number y of ciphertexts for that letter p.\n    - Finally, concatenate all y's and separate them with commas to get the final ciphertext.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: A sequence of numbers separated by ,. For example, \"y1,y2,…\".\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - k_q_x : 12\n- Decryption Steps:\n    - For each number c in the ciphertext:\n        - Compute z = c // k_q_x. where // is used in integer division operations to return the integer part of the quotient (i.e., the result of removing the fractional part).\n        - Based on the decimal number represented by z, use ascii to find the corresponding letter as the plaintext letter p.\n    - Finally, concatenate all p's to get the final plaintext."]}
{"kor_rule_num": "25", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n    - 输入:\n        - 明文: 仅包含大写字母的字符串，不含标点符号和空格\n    - 输出:\n        - 密文: 十六进制字符串（包含小写字母a-e）\n    - 准备:\n        - 密钥(SHA哈希值)\n            - 对\"SECRET_KEY\"执行SHA-256运算，得到'73ef2a4edd7a7fbf07fd5f6faf99674dc0c25a025fd74c221f4c35849e5c0fb3'\n    - 加密步骤:\n        - 将明文字符串转换为字节序列（ASCII编码）\n        - 使用密钥对每个字节进行异或（XOR）运算加密。重复使用密钥使其长度与明文字节数相同\n        - 将加密后的字节序列转换为十六进制字符串作为密文输出\n解密算法:\n解密规则:\n    - 输入:\n        - 密文: 十六进制字符串（包含小写字母a-e）\n    - 输出:\n        - 明文: 仅包含大写字母的字符串，不含标点符号和空格\n    - 准备:\n        - 密钥（与加密相同，是通过SHA-256获得的哈希值）\n    - 解密步骤:\n        - 将密文字符串转换为字节序列\n        - 使用密钥对每个字节进行异或（XOR）运算解密（解密过程与加密过程相同）\n        - 将解密后的字节序列转换为明文字符串", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n    - 输入:\n        - 明文: 仅包含大写字母的字符串，不含标点符号和空格\n    - 输出:\n        - 密文: 十六进制字符串（包含小写字母a-e）\n    - 准备:\n        - 密钥(SHA哈希值)\n            - 对\"SECRET_KEY\"执行SHA-256运算，得到'73ef2a4edd7a7fbf07fd5f6faf99674dc0c25a025fd74c221f4c35849e5c0fb3'\n    - 加密步骤:\n        - 将明文字符串转换为字节序列（ASCII编码）\n        - 使用密钥对每个字节进行异或（XOR）运算加密。重复使用密钥使其长度与明文字节数相同\n        - 将加密后的字节序列转换为十六进制字符串作为密文输出\n解密算法:\n解密规则:\n    - 输入:\n        - 密文: 十六进制字符串（包含小写字母a-e）\n    - 输出:\n        - 明文: 仅包含大写字母的字符串，不含标点符号和空格\n    - 准备:\n        - 密钥（与加密相同，是通过SHA-256获得的哈希值）\n    - 解密步骤:\n        - 将密文字符串转换为字节序列\n        - 使用密钥对每个字节进行异或（XOR）运算解密（解密过程与加密过程相同）\n        - 将解密后的字节序列转换为明文字符串"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  Hexadecimal string (and letters a-e in lower case).\n- Preparation:\n    - Key(SHA hash value)\n        - Performing SHA-256 on \"SECRET_KEY\" results in '73ef2a4edd7a7fbf07fd5f6faf99674dc0c25a025fd74c221f4c35849e5c0fb3'.\n- Encryption Steps:\n    - Converts a plaintext string into a sequence of bytes (ASCII encoding).\n    - Each byte is encrypted with the corresponding byte of the key using a bitwise different-or (XOR) operation. Repeatedly recycle the key so that the key length is the same as the number of plaintext bytes.\n    - The encrypted byte sequence is converted to a hexadecimal string for ciphertext output.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Hexadecimal string (and letters a-e in lower case).\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - Key (Same as encryption,is a hashed hash obtained by SHA_256)\n- Decryption Steps:\n    - Converts the ciphertext string into a sequence of bytes.\n    - Each byte is decrypted (the decryption process is the same as the encryption process) with the corresponding byte of the key using a bitwise different-or (XOR) operation.\n    - The decrypted byte sequence is converted to a plaintext string."]}
{"kor_rule_num": "15", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 5x5网格(所有行和列号从0开始计数):\n        - M Z S D P\n        K N F L Q\n        G A O X U\n        W R Y V C\n        B T E H I\n        - 位于所有行第一个字母的MKGWB是行首字母\n        - 位于所有列最后一个字母的PQUCL是列尾字母\n- 加密步骤:\n    - 移除明文中的空格、标点和字母J，并将所有字母转换为大写\n    - 对明文中的每个字母p:\n        - 在网格中找到字母p的位置，然后找到相应的行首和列尾字符\n        - 将行首和列尾字符连接成二元组作为该字母p的加密消息\n        - 例如，如果字母p是H，它在第4行，行首字符是B；它在第3列，列尾字符是H，所以加密消息是BH\n    \n    连接所有加密消息作为最终密文输出", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 5x5网格(所有行和列号从0开始计数):\n        - M Z S D P\n        K N F L Q\n        G A O X U\n        W R Y V C\n        B T E H I\n        - 位于所有行第一个字母的MKGWB是行首字母\n        - 位于所有列最后一个字母的PQUCL是列尾字母\n- 加密步骤:\n    - 移除明文中的空格、标点和字母J，并将所有字母转换为大写\n    - 对明文中的每个字母p:\n        - 在网格中找到字母p的位置，然后找到相应的行首和列尾字符\n        - 将行首和列尾字符连接成二元组作为该字母p的加密消息\n        - 例如，如果字母p是H，它在第4行，行首字符是B；它在第3列，列尾字符是H，所以加密消息是BH\n    \n    连接所有加密消息作为最终密文输出"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - 5x5 Gird(All row and column numbers are counted from 0.):\n        - M Z S D P\n        K N F L Q\n        G A O X U\n        W R Y V C\n        B T E H I\n        - Located at the first letter of all rows, MKGWB is the row header letter.\n        - Located at the last letter of all columns, BTEHI is the bottom column letter.\n- Encryption Steps:\n    - Remove spaces and punctuation and the letter J from plain text and convert all letters to uppercase.\n    - For each letter p in the plaintext.\n        - Find the position of the letter p in the grid, and then find the corresponding row header and column footer characters accordingly.\n        - Concatenate the row-header and column-bottom characters into a binary as the encrypted message for that letter p.\n        - For example, if the letter p is H, it is in the 4th row, and the row header character is B; it is in the 3rd column, and the column bottom character is H, so the encrypted message is BH.\n    \n    Concatenate all the encrypted messages for the final ciphertext output.\n    \n\n "]}
{"kor_rule_num": "5", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 仿射字母表 = \"XMJQUDONPRGTVBWFAKSHZCYEIL\"\n    - 将每个字母与其在仿射字母表中的位置关联（从0开始）:\n        X->0, M->1, J->2, Q->3, U->4, D->5, O->6, N->7,\n        P->8, R->9, G->10, T->11, V->12, B->13, W->14, F->15,\n        A->16, K->17, S->18, H->19, Z->20, C->21, Y->22, E->23, I->24, L->25\n    - A: 3\n    - B: 5\n    - A_inv: 9\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 设x为其在仿射字母表中的位置\n        - 应用仿射编码函数计算y:\n            - y = (Ax + B) mod 26\n        - 在仿射字母表中找到位置y对应的字母，形成加密消息", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 仿射字母表 = \"XMJQUDONPRGTVBWFAKSHZCYEIL\"\n    - 将每个字母与其在仿射字母表中的位置关联（从0开始）:\n        X->0, M->1, J->2, Q->3, U->4, D->5, O->6, N->7,\n        P->8, R->9, G->10, T->11, V->12, B->13, W->14, F->15,\n        A->16, K->17, S->18, H->19, Z->20, C->21, Y->22, E->23, I->24, L->25\n    - A: 3\n    - B: 5\n    - A_inv: 9\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 设x为其在仿射字母表中的位置\n        - 应用仿射编码函数计算y:\n            - y = (Ax + B) mod 26\n        - 在仿射字母表中找到位置y对应的字母，形成加密消息"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - affine alphabet = \"XMJQUDONPRGTVBWFAKSHZCYEIL\"\n    - Associate each letter with its position in the affine alphabet (starting from 0):\n        \n        X -> 0, M -> 1, J -> 2, Q -> 3, U -> 4, D -> 5, O -> 6, N -> 7,\n        P -> 8, R -> 9, G -> 10, T -> 11, V -> 12, B -> 13, W -> 14, F -> 15,\n        A -> 16, K -> 17, S -> 18, H -> 19, Z -> 20, C -> 21, Y -> 22, E -> 23, I -> 24, L -> 25\n        \n    - A: 3\n    - B: 5\n    - A_inv: 9\n- Encryption Steps:\n    - For each given plaintext character p:\n        - Let  x  denote its position in the affine alphabet.\n        - Apply the affine coding function to compute y:\n            - y = (Ax + B) mod 26\n        - Find the corresponding letter in the affine alphabet at position  y , forming the encrypted message.\n\n "]}
{"kor_rule_num": "10", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 25个密码轮，每个密码轮包含26个字母的不同排列\n    [\n            \"ABCEIGDJFVUYMHTQKZOLRXSPWN\",\n            \"ACDEHFIJKTLMOUVYGZNPQXRWSB\",\n            \"ADKOMJUBGEPHSCZINXFYQRTVWL\",\n            \"AEDCBIFGJHLKMRUOQVPTNWYXZS\",\n            \"AFNQUKDOPITJBRHCYSLWEMZVXG\",\n            \"AGPOCIXLURNDYZHWBJSQFKVMET\",\n            \"AHXJEZBNIKPVROGSYDULCFMQTW\",\n            \"AIHPJOBWKCVFZLQERYNSUMGTDX\",\n            \"AJDSKQOIVTZEFHGYUNLPMBXWCR\",\n            \"AKELBDFJGHONMTPRQSVZUXYWIC\",\n            \"ALTMSXVQPNOHUWDIZYCGKRFBEJ\",\n            \"AMNFLHQGCUJTBYPZKXISRDVEWO\",\n            \"ANCJILDHBMKGXUZTSWQYVORPFE\",\n            \"AODWPKJVIUQHZCTXBLEGNYRSMF\",\n            \"APBVHIYKSGUENTCXOWFQDRLJZM\",\n            \"AQJNUBTGIMWZRVLXCSHDEOKFPY\",\n            \"ARMYOFTHEUSZJXDPCWGQIBKLNV\",\n            \"ASDMCNEQBOZPLGVJRKYTFUIWXH\",\n            \"ATOJYLFXNGWHVCMIRBSEKUPDZQ\",\n            \"AUTRZXQLYIOVBPESNHJWMDGFCK\",\n            \"AVNKHRGOXEYBFSJMUDQCLZWTIP\",\n            \"AWVSFDLIEBHKNRJQZGMXPUCOTY\",\n            \"AXKWREVDTUFOYHMLSIQNJCPGBZ\",\n            \"AYJPXMVKBQWUGLOSTECHNZFRID\",\n            \"AZDNBUHYFWJLVGRCQMPSOEXTKI\"\n        ]\n- 加密步骤:\n    - 初始选择第1个密码轮\n    - 对明文中的每个字符p:\n        - 在当前密码轮上找到字符p，用其后一个字符替换得到密文字符\n        - 如果当前字符在密码轮末尾，则回到密码轮开头\n        - 移动到下一个密码轮处理下一个字符，当到达最后一个密码轮时，返回第一个密码轮继续加密过程\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 大写字母字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - 25个密码轮，与加密相同\n- 解密步骤(与加密步骤相反):\n    - 初始选择第1个密码轮\n    - 对密文中的每个字符c:\n        - 在当前密码轮上找到字符c，用其前一个字符替换得到明文字符\n        - 如果当前字符在密码轮开头，则回到密码轮末尾\n        - 移动到下一个密码轮处理下一个字符，当到达最后一个密码轮时，返回第一个密码轮继续解密过程", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 25个密码轮，每个密码轮包含26个字母的不同排列\n    [\n            \"ABCEIGDJFVUYMHTQKZOLRXSPWN\",\n            \"ACDEHFIJKTLMOUVYGZNPQXRWSB\",\n            \"ADKOMJUBGEPHSCZINXFYQRTVWL\",\n            \"AEDCBIFGJHLKMRUOQVPTNWYXZS\",\n            \"AFNQUKDOPITJBRHCYSLWEMZVXG\",\n            \"AGPOCIXLURNDYZHWBJSQFKVMET\",\n            \"AHXJEZBNIKPVROGSYDULCFMQTW\",\n            \"AIHPJOBWKCVFZLQERYNSUMGTDX\",\n            \"AJDSKQOIVTZEFHGYUNLPMBXWCR\",\n            \"AKELBDFJGHONMTPRQSVZUXYWIC\",\n            \"ALTMSXVQPNOHUWDIZYCGKRFBEJ\",\n            \"AMNFLHQGCUJTBYPZKXISRDVEWO\",\n            \"ANCJILDHBMKGXUZTSWQYVORPFE\",\n            \"AODWPKJVIUQHZCTXBLEGNYRSMF\",\n            \"APBVHIYKSGUENTCXOWFQDRLJZM\",\n            \"AQJNUBTGIMWZRVLXCSHDEOKFPY\",\n            \"ARMYOFTHEUSZJXDPCWGQIBKLNV\",\n            \"ASDMCNEQBOZPLGVJRKYTFUIWXH\",\n            \"ATOJYLFXNGWHVCMIRBSEKUPDZQ\",\n            \"AUTRZXQLYIOVBPESNHJWMDGFCK\",\n            \"AVNKHRGOXEYBFSJMUDQCLZWTIP\",\n            \"AWVSFDLIEBHKNRJQZGMXPUCOTY\",\n            \"AXKWREVDTUFOYHMLSIQNJCPGBZ\",\n            \"AYJPXMVKBQWUGLOSTECHNZFRID\",\n            \"AZDNBUHYFWJLVGRCQMPSOEXTKI\"\n        ]\n- 加密步骤:\n    - 初始选择第1个密码轮\n    - 对明文中的每个字符p:\n        - 在当前密码轮上找到字符p，用其后一个字符替换得到密文字符\n        - 如果当前字符在密码轮末尾，则回到密码轮开头\n        - 移动到下一个密码轮处理下一个字符，当到达最后一个密码轮时，返回第一个密码轮继续加密过程\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 大写字母字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - 25个密码轮，与加密相同\n- 解密步骤(与加密步骤相反):\n    - 初始选择第1个密码轮\n    - 对密文中的每个字符c:\n        - 在当前密码轮上找到字符c，用其前一个字符替换得到明文字符\n        - 如果当前字符在密码轮开头，则回到密码轮末尾\n        - 移动到下一个密码轮处理下一个字符，当到达最后一个密码轮时，返回第一个密码轮继续解密过程"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - Reels\n        \n        Reel1:   \"ABCEIGDJFVUYMHTQKZOLRXSPWN\",\n        Reel2:   \"ACDEHFIJKTLMOUVYGZNPQXRWSB\",\n        Reel3:   \"ADKOMJUBGEPHSCZINXFYQRTVWL\",\n        Reel4:   \"AEDCBIFGJHLKMRUOQVPTNWYXZS\",\n        Reel5:   \"AFNQUKDOPITJBRHCYSLWEMZVXG\",\n        Reel6:   \"AGPOCIXLURNDYZHWBJSQFKVMET\",\n        Reel7:    \"AHXJEZBNIKPVROGSYDULCFMQTW\",\n        Reel8:    \"AIHPJOBWKCVFZLQERYNSUMGTDX\",\n        Reel9:    \"AJDSKQOIVTZEFHGYUNLPMBXWCR\",\n        Reel10:   \"AKELBDFJGHONMTPRQSVZUXYWIC\",\n        Reel11:    \"ALTMSXVQPNOHUWDIZYCGKRFBEJ\",\n        Reel12:    \"AMNFLHQGCUJTBYPZKXISRDVEWO\",\n        Reel13:    \"ANCJILDHBMKGXUZTSWQYVORPFE\",\n        Reel14:    \"AODWPKJVIUQHZCTXBLEGNYRSMF\",\n        Reel15:    \"APBVHIYKSGUENTCXOWFQDRLJZM\",\n        Reel16:    \"AQJNUBTGIMWZRVLXCSHDEOKFPY\",\n        Reel17:    \"ARMYOFTHEUSZJXDPCWGQIBKLNV\",\n        Reel18:    \"ASDMCNEQBOZPLGVJRKYTFUIWXH\",\n        Reel19:    \"ATOJYLFXNGWHVCMIRBSEKUPDZQ\",\n        Reel20:    \"AUTRZXQLYIOVBPESNHJWMDGFCK\",\n        Reel21:     \"AVNKHRGOXEYBFSJMUDQCLZWTIP\",\n        Reel22:    \"AWVSFDLIEBHKNRJQZGMXPUCOTY\",\n        Reel23:    \"AXKWREVDTUFOYHMLSIQNJCPGBZ\",\n        Reel24:    \"AYJPXMVKBQWUGLOSTECHNZFRID\",\n        Reel25:    \"AZDNBUHYFWJLVGRCQMPSOEXTKI\"\n        \n- Encryption Steps:\n    - Initially select the Reel1.\n    - For each character p in the plaintext:\n        - Find character p on the Reel and replace it with the next character on the Reel to get the ciphertext character.\n        - If the current character is at the end of the Reel, go around to the beginning of the Reel.\n        - Move to the next Reel to get the next character. When you reach the last Reel, circle back to the first Reel and continue the encryption process.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation:\n    - Reels (Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - Initially select the Reel1.\n    - For each character c in the ciphertext:\n        - Find character c on the Reel and replace it with the previous character  on the Reel to get the plaintext character.\n        - If the current character is at the beginning of the Reel, go around to the end of the Reel.\n        - Move to the next Reel to get the next character. When you reach the last Reel, circle back to the first Reel and continue the decryption process."]}
{"kor_rule_num": "2", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n\n输入:\n    - 明文: 仅包含大写字母的字符串，不含标点符号和空格。\n输出:\n    - 密文: 大写字母字符串。\n准备:\n    - 加密表 = {\n    'A': '!', 'B': '@', 'C': '#', 'D': '$',\n    'E': '%', 'F': '^', 'G': '&', 'H': '*',\n    'I': '(', 'J': ')', 'K': '_', 'L': '+',\n    'M': '=', 'N': '~', 'O': '?', 'P': '/',\n    'Q': '0', 'R': ':', 'S': ';', 'T': '<',\n    'U': '>', 'V': '1', 'W': '2', 'X': '3',\n    'Y': '4', 'Z': '5'\n    }\n加密步骤:\n    - 对于每个给定的明文字符 p:\n        - 如果 p 是大写字母且存在于加密表中:\n            - 用加密表中对应的符号替换 p。\n    \n解密算法:\n\n解密规则:\n\n输入:\n    - 密文: 大写字母字符串。\n输出:\n    - 明文: 大写字母字符串。\n准备:\n    - 加密表 = {\n    'A': '!', 'B': '@', 'C': '#', 'D': '$',\n    'E': '%', 'F': '^', 'G': '&', 'H': '*',\n    'I': '(', 'J': ')', 'K': '_', 'L': '+',\n    'M': '=', 'N': '~', 'O': '?', 'P': '/',\n    'Q': '0', 'R': ':', 'S': ';', 'T': '<',\n    'U': '>', 'V': '1', 'W': '2', 'X': '3',\n    'Y': '4', 'Z': '5'\n    }\n解密步骤 (与加密步骤完全相反):\n    - 对于每个给定的密文字符 c:\n        - 如果 c 是加密表中的符号且存在于加密表中:\n            - 用加密表中对应的大写字母替换 c。\n    ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n\n输入:\n    - 明文: 仅包含大写字母的字符串，不含标点符号和空格。\n输出:\n    - 密文: 大写字母字符串。\n准备:\n    - 加密表 = {\n    'A': '!', 'B': '@', 'C': '#', 'D': '$',\n    'E': '%', 'F': '^', 'G': '&', 'H': '*',\n    'I': '(', 'J': ')', 'K': '_', 'L': '+',\n    'M': '=', 'N': '~', 'O': '?', 'P': '/',\n    'Q': '0', 'R': ':', 'S': ';', 'T': '<',\n    'U': '>', 'V': '1', 'W': '2', 'X': '3',\n    'Y': '4', 'Z': '5'\n    }\n加密步骤:\n    - 对于每个给定的明文字符 p:\n        - 如果 p 是大写字母且存在于加密表中:\n            - 用加密表中对应的符号替换 p。\n    \n解密算法:\n\n解密规则:\n\n输入:\n    - 密文: 大写字母字符串。\n输出:\n    - 明文: 大写字母字符串。\n准备:\n    - 加密表 = {\n    'A': '!', 'B': '@', 'C': '#', 'D': '$',\n    'E': '%', 'F': '^', 'G': '&', 'H': '*',\n    'I': '(', 'J': ')', 'K': '_', 'L': '+',\n    'M': '=', 'N': '~', 'O': '?', 'P': '/',\n    'Q': '0', 'R': ':', 'S': ';', 'T': '<',\n    'U': '>', 'V': '1', 'W': '2', 'X': '3',\n    'Y': '4', 'Z': '5'\n    }\n解密步骤 (与加密步骤完全相反):\n    - 对于每个给定的密文字符 c:\n        - 如果 c 是加密表中的符号且存在于加密表中:\n            - 用加密表中对应的大写字母替换 c。\n    "], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - encryption_table = {\n    'A': '!', 'B': '@', 'C': '#', 'D': '$',\n    'E': '%', 'F': '^', 'G': '&', 'H': '*',\n    'I': '(', 'J': ')', 'K': '_', 'L': '+',\n    'M': '=', 'N': '~', 'O': '?', 'P': '/',\n    'Q': '0', 'R': ':', 'S': ';', 'T': '<',\n    'U': '>', 'V': '1', 'W': '2', 'X': '3',\n    'Y': '4', 'Z': '5'\n    }\n- Encryption Steps:\n    - For each given plaintext character p:\n        - If `p` is an uppercase letter and exists in the encryption table:\n            - Replace `p` with the corresponding symbol from the encryption table.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation:\n    - encryption_table = {\n    'A': '!', 'B': '@', 'C': '#', 'D': '$',\n    'E': '%', 'F': '^', 'G': '&', 'H': '*',\n    'I': '(', 'J': ')', 'K': '_', 'L': '+',\n    'M': '=', 'N': '~', 'O': '?', 'P': '/',\n    'Q': '0', 'R': ':', 'S': ';', 'T': '<',\n    'U': '>', 'V': '1', 'W': '2', 'X': '3',\n    'Y': '4', 'Z': '5'\n    }\n- Decryption Steps (exact opposite of encryption steps):\n    - For each given ciphertext character c:\n        - If `c` is a symbol from the encryption table and exists in the encryption table:\n            - Replace `c` with the corresponding uppercase letter from the encryption table."]}
{"kor_rule_num": "11", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n以下是经过整理后的文字：\n\n---\n\n### 5x5 网格布局\n\n共有四个5x5的字符网格，每个网格代表了不同的排列方式。\n\n1. **网格1 原始网格**\n\n这是最初的字符排列，按照特定顺序组织如下：\n\n```\nK L M N O\nP R S T U\nV W X Y Z\nA B C D E\nF G H I J\n```\n\n2. **网格2 ECHO 网格**\n\n该网格根据\"ECHO\"这个词进行了重新排列：\n\n```\nE C H O A\nB D F G I\nJ K L M N\nP R S T U\nV W X Y Z\n```\n\n3. **网格3 VORTEX 网格**\n\n此网格基于\"VORTEX\"一词进行了独特的字符重组：\n\n```\nV O R T E\nX A B C D\nF G H I J\nK L M N P\nS U W Y Z\n```\n\n4. **网格4 重复原始网格**\n\n最后一个网格与第一个原始网格完全相同，没有进行任何改变：\n\n```\nK L M N O\nP R S T U\nV W X Y Z\nA B C D E\nF G H I J\n```\n\n每个网格展示了不同主题词下字符的独特排列。\n- 加密步骤:\n    - 清理明文，移除空格和非字母字符，移除字母Q，转换为大写\n    - 如果明文长度为奇数，添加字母'X'使其成为偶数\n    - 将处理后的明文分成两个字母一组\n    - 对于每组两个字母p1,p2:\n        - 在网格1和网格4中找到第一个字母和第二个字母的位置\n        - 在网格2和网格3中找到这两个位置对应的字母，用这两个字母作为该组的加密结果\n    - 连接所有加密后的字母组形成最终密文", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n以下是经过整理后的文字：\n\n---\n\n### 5x5 网格布局\n\n共有四个5x5的字符网格，每个网格代表了不同的排列方式。\n\n1. **网格1 原始网格**\n\n这是最初的字符排列，按照特定顺序组织如下：\n\n```\nK L M N O\nP R S T U\nV W X Y Z\nA B C D E\nF G H I J\n```\n\n2. **网格2 ECHO 网格**\n\n该网格根据\"ECHO\"这个词进行了重新排列：\n\n```\nE C H O A\nB D F G I\nJ K L M N\nP R S T U\nV W X Y Z\n```\n\n3. **网格3 VORTEX 网格**\n\n此网格基于\"VORTEX\"一词进行了独特的字符重组：\n\n```\nV O R T E\nX A B C D\nF G H I J\nK L M N P\nS U W Y Z\n```\n\n4. **网格4 重复原始网格**\n\n最后一个网格与第一个原始网格完全相同，没有进行任何改变：\n\n```\nK L M N O\nP R S T U\nV W X Y Z\nA B C D E\nF G H I J\n```\n\n每个网格展示了不同主题词下字符的独特排列。\n- 加密步骤:\n    - 清理明文，移除空格和非字母字符，移除字母Q，转换为大写\n    - 如果明文长度为奇数，添加字母'X'使其成为偶数\n    - 将处理后的明文分成两个字母一组\n    - 对于每组两个字母p1,p2:\n        - 在网格1和网格4中找到第一个字母和第二个字母的位置\n        - 在网格2和网格3中找到这两个位置对应的字母，用这两个字母作为该组的加密结果\n    - 连接所有加密后的字母组形成最终密文"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - Four 5x5 Girds\n        - Gird1\n            - K  L  M  N  O\n            P  R  S  T  U\n            V  W  X  Y  Z\n            A  B  C  D  E\n            F  G  H  I  J\n        - Gird2\n            - E  C  H  O  A\n            B  D  F  G  I\n            J  K  L  M  N\n            P  R  S  T  U\n            V  W  X  Y  Z\n        - Gird3\n            - V  O  R  T  E\n            X  A  B  C  D\n            F  G  H  I  J\n            K  L  M  N  P\n            S  U  W  Y  Z\n        - Gird4\n            - K  L  M  N  O\n            P  R  S  T  U\n            V  W  X  Y  Z\n            A  B  C  D  E\n            F  G  H  I  J\n- Encryption Steps:\n    - Cleans up plaintext, removing spaces and non-alphabetic characters, removing the letter Q, and converting all letters to uppercase.\n    - If the plaintext is of odd length, add a letter 'X' to make it of even length.\n    - Split the cleaned plaintext into two-letter groups.\n    - For each double-letter group p1,p2 of the plaintext:\n        - In Gird1 and Gird4, find the position of the first letter and the second letter.\n        - In Gird2 and Gird3, find the letters corresponding to these two positions, use these two letters as the result of encrypting the double letter combination.\n    - Concatenate all the encrypted double letter groups to form the final ciphertext.\n\n "]}
{"kor_rule_num": "8", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n输入:\n    - 明文: 大写字母字符串，不含标点和空格\n    - 密钥: 用于选择替换表的字符串\n输出:\n    - 密文: 大写字母字符串\n准备工作:\n    - 密码替换表:\n        使用以下13个密码替换表，每个表对应两个字母:\n        AB: NOPQRSTUVWXYZABCDEFGHIJKLM\n        CD: ZNOPQRSTUVWXYBCDEFGHIJKLMA\n        EF: YZNOPQRSTUVWXCDEFGHIJKLMAB\n        GH: XYZNOPQRSTUVWDEFGHIJKLMABC\n        IJ: WXYZNOPQRSTUVEFGHIJKLMABCD\n        KL: VWXYZNOPQRSTUFGHIJKLMABCDE\n        MN: UVWXYZNOPQRSTGHIJKLMABCDEF\n        OP: TUVWXYZNOPQRSHIJKLMABCDEFG\n        QR: STUVWXYZNOPQRIJKLMABCDEFGH\n        ST: RSTUVWXYZNOPQJKLMABCDEFGHI\n        UV: QRSTUVWXYZNOPKLMABCDEFGHIJ\n        WX: PQRSTUVWXYZNOLMABCDEFGHIJK\n        YZ: OPQRSTUVWXYZNMABCDEFGHIJKL\n    - 标准字母表:\n        ABCDEFGHIJKLMNOPQRSTUVWXYZ\n加密步骤:\n    - 将密钥中的每个字母与明文中的每个字母配对。如果密钥比明文短，重复使用密钥\n    - 对于每个明文字符p:\n        - 根据与之配对的密钥字母找到对应的密码替换表\n        - 在标准字母表中找到p的位置，用密码替换表中相同位置的字母替换它\n解密算法:\n解密规则:\n输入:\n    - 密文: 大写字母字符串\n    - 密钥: 用于选择替换表的字符串\n输出:\n    - 明文: 大写字母字符串\n准备工作:\n    - 密码替换表: (与加密相同)\n    - 标准字母表: (与加密相同)\n解密步骤:\n    - 将密钥中的每个字母与密文中的每个字母配对。如果密钥比密文短，重复使用密钥\n    - 对于每个密文字符c:\n        - 根据与之配对的密钥字母找到对应的密码替换表\n        - 在密码替换表中找到c的位置，用标准字母表中相同位置的字母还原它", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n输入:\n    - 明文: 大写字母字符串，不含标点和空格\n    - 密钥: 用于选择替换表的字符串\n输出:\n    - 密文: 大写字母字符串\n准备工作:\n    - 密码替换表:\n        使用以下13个密码替换表，每个表对应两个字母:\n        AB: NOPQRSTUVWXYZABCDEFGHIJKLM\n        CD: ZNOPQRSTUVWXYBCDEFGHIJKLMA\n        EF: YZNOPQRSTUVWXCDEFGHIJKLMAB\n        GH: XYZNOPQRSTUVWDEFGHIJKLMABC\n        IJ: WXYZNOPQRSTUVEFGHIJKLMABCD\n        KL: VWXYZNOPQRSTUFGHIJKLMABCDE\n        MN: UVWXYZNOPQRSTGHIJKLMABCDEF\n        OP: TUVWXYZNOPQRSHIJKLMABCDEFG\n        QR: STUVWXYZNOPQRIJKLMABCDEFGH\n        ST: RSTUVWXYZNOPQJKLMABCDEFGHI\n        UV: QRSTUVWXYZNOPKLMABCDEFGHIJ\n        WX: PQRSTUVWXYZNOLMABCDEFGHIJK\n        YZ: OPQRSTUVWXYZNMABCDEFGHIJKL\n    - 标准字母表:\n        ABCDEFGHIJKLMNOPQRSTUVWXYZ\n加密步骤:\n    - 将密钥中的每个字母与明文中的每个字母配对。如果密钥比明文短，重复使用密钥\n    - 对于每个明文字符p:\n        - 根据与之配对的密钥字母找到对应的密码替换表\n        - 在标准字母表中找到p的位置，用密码替换表中相同位置的字母替换它\n解密算法:\n解密规则:\n输入:\n    - 密文: 大写字母字符串\n    - 密钥: 用于选择替换表的字符串\n输出:\n    - 明文: 大写字母字符串\n准备工作:\n    - 密码替换表: (与加密相同)\n    - 标准字母表: (与加密相同)\n解密步骤:\n    - 将密钥中的每个字母与密文中的每个字母配对。如果密钥比密文短，重复使用密钥\n    - 对于每个密文字符c:\n        - 根据与之配对的密钥字母找到对应的密码替换表\n        - 在密码替换表中找到c的位置，用标准字母表中相同位置的字母还原它"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n    - Key: The key is a string used to select the alphabets. Each letter in the key will be used to select the corresponding alphabet for encryption or decryption.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - Cipher Alphabets\n        \n        Use the following 13 cipher alphabets, each associated with two letters:\n        AB: NOPQRSTUVWXYZABCDEFGHIJKLM\n        CD: ZNOPQRSTUVWXYBCDEFGHIJKLMA\n        EF: YZNOPQRSTUVWXCDEFGHIJKLMAB\n        GH: XYZNOPQRSTUVWDEFGHIJKLMABC\n        IJ: WXYZNOPQRSTUVEFGHIJKLMABCD\n        KL: VWXYZNOPQRSTUFGHIJKLMABCDE\n        MN: UVWXYZNOPQRSTGHIJKLMABCDEF\n        OP: TUVWXYZNOPQRSHIJKLMABCDEFG\n        QR: STUVWXYZNOPQRIJKLMABCDEFGH\n        ST: RSTUVWXYZNOPQJKLMABCDEFGHI\n        UV: QRSTUVWXYZNOPKLMABCDEFGHIJ\n        WX: PQRSTUVWXYZNOLMABCDEFGHIJK\n        YZ: OPQRSTUVWXYZNMABCDEFGHIJKL\n        \n    - Standard Alphabet\n        - ABCDEFGHIJKLMNOPQRSTUVWXYZ\n- Encryption Steps:\n    - Pair each letter in the key with each letter in the plaintext. If the key is shorter than the plaintext, repeat the key.\n    - For each given plaintext character p:\n        - Find the corresponding cipher alphabet based on the key letter paired with it. If the key letter is A, mark the choice AB: NOPQRSTUVWXYZABCDEFGHIJKLM\n        - Find the position of p in the standard alphabet and replace it with the letter at the same position in the cipher alphabet.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string.\n    - Key: The key is a string used to select the alphabets. Each letter in the key will be used to select the corresponding alphabet for encryption or decryption.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation:\n    - Cipher Alphabets (Same as encryption)\n    - Standard Alphabet(Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - Pair each letter in the key with each letter in the ciphertext. If the key is shorter than the plaintext, repeat the key.\n    - For each given ciphertext character c:\n        - Find the corresponding cipher alphabet based on the key letter paired with it. If the key letter is A, mark AB Option: NOPQRSTUVWXYZABCDEFGHIJKLM\n        - Find the position of c in the cipher alphabet and reduce it to the plaintext letter using the same position in the standard alphabet."]}
{"kor_rule_num": "18", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 网格和模板:\n        - 准备一个空白网格和一个带孔的模板(栅栏)\n        - 使用的模板是:\n            ▮ ▮ ▮ ▮\n            ▮ ▮ ▯ ▯\n            ▮ ▮ ▮ ▯\n            ▯ ▮ ▮ ▮\n            其中白色的是孔，将模板放在空白网格上，只通过白色孔洞，在网格的对应位置填入字符。\n- 加密步骤:\n    - 将明文逐个分成16个字母的块(如果明文少于16个长度则为一个块)\n    - 对每个块执行以下加密操作:\n        - 将带孔的模板放在空白网格上\n        - 通过模板中的孔按顺序填入明文字母\n        - 模板总共有四个孔，所以填完四个字母后，需要将模板逆时针旋转90度\n        - 重复填充可见孔中的明文下一个字母并旋转模板，直到整个网格完全填满。这将执行4次填充+旋转，最终模板会转回原始模板。如果消息不足以填满整个网格，用填充字符(如'#')补充\n        - 网格填满后，按行读取网格内容作为该块的加密消息\n        - 进入下一个块时，清空网格内容并重做整个填充和旋转操作\n    最后，将所有块的加密消息连接在一起作为最终密文。", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 网格和模板:\n        - 准备一个空白网格和一个带孔的模板(栅栏)\n        - 使用的模板是:\n            ▮ ▮ ▮ ▮\n            ▮ ▮ ▯ ▯\n            ▮ ▮ ▮ ▯\n            ▯ ▮ ▮ ▮\n            其中白色的是孔，将模板放在空白网格上，只通过白色孔洞，在网格的对应位置填入字符。\n- 加密步骤:\n    - 将明文逐个分成16个字母的块(如果明文少于16个长度则为一个块)\n    - 对每个块执行以下加密操作:\n        - 将带孔的模板放在空白网格上\n        - 通过模板中的孔按顺序填入明文字母\n        - 模板总共有四个孔，所以填完四个字母后，需要将模板逆时针旋转90度\n        - 重复填充可见孔中的明文下一个字母并旋转模板，直到整个网格完全填满。这将执行4次填充+旋转，最终模板会转回原始模板。如果消息不足以填满整个网格，用填充字符(如'#')补充\n        - 网格填满后，按行读取网格内容作为该块的加密消息\n        - 进入下一个块时，清空网格内容并重做整个填充和旋转操作\n    最后，将所有块的加密消息连接在一起作为最终密文。"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  Uppercase letters  string without punctuation and spaces.\n- Preparation:\n    - Grid and Template:\n        - Prepare a blank grid and a template with holes (fence).\n        - The template used is:\n            \n            ▮  ▮  ▮  ▮\n            ▮  ▮  ▯  ▯\n            ▮  ▮  ▮  ▯\n            ▯  ▮  ▮  ▮\n            \n            Where the white ones are holes, place the template on a blank grid, only through the white holes, and fill in the corresponding positions of the grid with characters.\n            \n- Encryption Steps:\n    - Divide the plaintext into blocks of 16 letters one by one.(If the plaintext is less than 16 long it is one  block)\n        - For example, the plaintext message \"LOVEHELLOWORLD\" is less than 16 and is one block.\n    - For each block, perform the following encryption operation:\n        - Place the template with holes on the blank grid.\n        - Fill the grid with the letters of the plaintext message in order through the holes in the template.\n            - For example, the plaintext is \"LOVEHELLOWORLD\", through the four holes, after filling in the LOVE grid is\n                \n                [['', '', '', ''],\n                ['', '', 'L', 'O'],\n                ['', '', '', 'V'],\n                ['E', '', '', '']]\n                \n        - The template has a total of four holes, so after filling out the four letters, it can not be filled out, then you need to rotate the template counterclockwise 90 degrees.\n            - For example, after filling in LOVE after rotating the template after the template for:\n                \n                ▮  ▯  ▯  ▮\n                ▮  ▯  ▮  ▮\n                ▮  ▮  ▮  ▮\n                ▮  ▮  ▮  ▯\n                \n        - Repeat filling the visible holes in the grid with the next letter of the plaintext message and rotating the template until the entire grid is completely filled. This will perform 4 fills + rotations and eventually the template will turn to the original template. If the message is not enough to fill the entire grid, it is made up with filler characters (e.g. '#').\n            - For example, if the plain text is \"LOVEHELLOWORLD\", after several fills and rotations, the final grid will be\n                \n                [['L', 'H', 'E', 'O'],\n                ['W', 'L', 'L', 'O'],\n                ['O', 'R', 'D', 'V'],\n                ['E', '#', '#', 'L']]\n                \n        - Once the grid is filled, read the contents of the grid line by line as the encrypted message for that block.\n        - When moving on to the next block, empty the contents of the grid and redo the entire fill and rotate operation.\n        \n        Finally, the encrypted messages of all the blocks are connected together to be the final ciphertext.\n        \n\n "]}
{"kor_rule_num": "3", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格。\n- 输出:\n    - 密文: 不含标点的字符串。\n- 准备:\n    - 多击编码表\n        | 字母 | 多击编码 |\n        | A | 2^1 |\n        | B | 2^2 |\n        | C | 2^3 |\n        | D | 3^1 |\n        | E | 3^2 |\n        | F | 3^3 |\n        | G | 4^1 |\n        | H | 4^2 |\n        | I | 4^3 |\n        | J | 5^1 |\n        | K | 5^2 |\n        | L | 5^3 |\n        | M | 6^1 |\n        | N | 6^2 |\n        | O | 6^3 |\n        | P | 7^1 |\n        | Q | 7^2 |\n        | R | 7^3 |\n        | S | 7^4 |\n        | T | 8^1 |\n        | U | 8^2 |\n        | V | 8^3 |\n        | W | 9^1 |\n        | X | 9^2 |\n        | Y | 9^3 |\n        | Z | 9^4 |\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 如果p是大写字母且存在于多击编码表中:\n            - 用多击编码表中对应的多击编码替换p。\n\n解密算法:\n\n解密规则:\n- 输入:\n    - 密文: 不含标点的字符串。\n- 输出:\n    - 明文: 大写字母字符串。\n- 准备: 多击编码表(与加密相同)\n- 解密步骤(与加密步骤相反):\n    - 对于每个密文中的多击编码c:\n        - 如果c是多击编码表中的编码:\n            - 用多击编码表中对应的大写字母替换c。\n", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格。\n- 输出:\n    - 密文: 不含标点的字符串。\n- 准备:\n    - 多击编码表\n        | 字母 | 多击编码 |\n        | A | 2^1 |\n        | B | 2^2 |\n        | C | 2^3 |\n        | D | 3^1 |\n        | E | 3^2 |\n        | F | 3^3 |\n        | G | 4^1 |\n        | H | 4^2 |\n        | I | 4^3 |\n        | J | 5^1 |\n        | K | 5^2 |\n        | L | 5^3 |\n        | M | 6^1 |\n        | N | 6^2 |\n        | O | 6^3 |\n        | P | 7^1 |\n        | Q | 7^2 |\n        | R | 7^3 |\n        | S | 7^4 |\n        | T | 8^1 |\n        | U | 8^2 |\n        | V | 8^3 |\n        | W | 9^1 |\n        | X | 9^2 |\n        | Y | 9^3 |\n        | Z | 9^4 |\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 如果p是大写字母且存在于多击编码表中:\n            - 用多击编码表中对应的多击编码替换p。\n\n解密算法:\n\n解密规则:\n- 输入:\n    - 密文: 不含标点的字符串。\n- 输出:\n    - 明文: 大写字母字符串。\n- 准备: 多击编码表(与加密相同)\n- 解密步骤(与加密步骤相反):\n    - 对于每个密文中的多击编码c:\n        - 如果c是多击编码表中的编码:\n            - 用多击编码表中对应的大写字母替换c。\n"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: A string without punctuation.\n- Preparation:\n    - Multitap Code Table\n        | Letter | Multitap Code |\n        | --- | --- |\n        | A | 2^1 |\n        | B | 2^2 |\n        | C | 2^3 |\n        | D | 3^1 |\n        | E | 3^2 |\n        | F | 3^3 |\n        | G | 4^1 |\n        | H | 4^2 |\n        | I | 4^3 |\n        | J | 5^1 |\n        | K | 5^2 |\n        | L | 5^3 |\n        | M | 6^1 |\n        | N | 6^2 |\n        | O | 6^3 |\n        | P | 7^1 |\n        | Q | 7^2 |\n        | R | 7^3 |\n        | S | 7^4 |\n        | T | 8^1 |\n        | U | 8^2 |\n        | V | 8^3 |\n        | W | 9^1 |\n        | X | 9^2 |\n        | Y | 9^3 |\n        | Z | 9^4 |\n- Encryption Steps:\n    - For each given plaintext character p:\n        - If `p` is an uppercase letter and exists in the Multitap Code Table:\n            - Replace `p` with the corresponding Multitap Code from the Multitap Code Table.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: A string without punctuation.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation: Multitap Code Table (Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - For each given ciphertext Multitap Code c:\n        - If `c` is a Multitap Code from the Multitap Code Table:\n            - Replace `c` with the corresponding uppercase letter from the Multitap Code Table."]}
{"kor_rule_num": "12", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 字符串\n- 准备:\n    - 数字索引映射表\n        - '..' : 5\n        - '.-' : 4\n        - './' : 9\n        - '-.' : 8\n        - '--' : 6\n        - '-/' : 7\n        - '/.' : 3\n        - '/-' : 1\n        - '//' : 2\n    - 摩斯密码表\n        - A: '.-',     B: '-...',   C: '-.-.',   D: '-..',\n        - E: '.',      F: '..-.',   G: '--.',    H: '....',\n        - I: '..',     J: '.---',   K: '-.-',    L: '.-..',\n        - M: '--',     N: '-.',     O: '---',    P: '.--.',\n        - Q: '--.-',   R: '.-.',    S: '...',    T: '-',\n        - U: '..-',    V: '...-',   W: '.--',    X: '-..-',\n        - Y: '-.--',   Z: '--..'\n- 加密步骤:\n    - 根据摩斯密码表将明文中的每个字符转换为摩斯密码，用/分隔每个字符，例如AB对应'.-/-...'\n    - 将摩斯密码分成两个字符一组。如果摩斯密码长度为奇数，最后一个字符不进行映射，直接添加到密文末尾\n    - 根据数字索引映射表将每组字符转换为对应的数字字符串\n    - 加密后的消息用字符串表示\n\n解密算法:\n\n解密规则:\n- 输入:\n    - 密文: 数字字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - 数字索引映射表(与加密相同)\n    - 摩斯密码表(与加密相同)\n- 解密步骤(与加密步骤相反):\n    - 根据数字索引映射表将密文中的每个数字转换为对应的字符对。如果密文末尾有非数字字符，则不处理。此时获得完整的摩斯密码\n    - 通过/分隔摩斯密码获得每个字符的摩斯密码\n    - 根据摩斯密码表将每个字符的摩斯密码转换为对应的明文字符\n    - 最终明文字符为大写字符串\n", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 字符串\n- 准备:\n    - 数字索引映射表\n        - '..' : 5\n        - '.-' : 4\n        - './' : 9\n        - '-.' : 8\n        - '--' : 6\n        - '-/' : 7\n        - '/.' : 3\n        - '/-' : 1\n        - '//' : 2\n    - 摩斯密码表\n        - A: '.-',     B: '-...',   C: '-.-.',   D: '-..',\n        - E: '.',      F: '..-.',   G: '--.',    H: '....',\n        - I: '..',     J: '.---',   K: '-.-',    L: '.-..',\n        - M: '--',     N: '-.',     O: '---',    P: '.--.',\n        - Q: '--.-',   R: '.-.',    S: '...',    T: '-',\n        - U: '..-',    V: '...-',   W: '.--',    X: '-..-',\n        - Y: '-.--',   Z: '--..'\n- 加密步骤:\n    - 根据摩斯密码表将明文中的每个字符转换为摩斯密码，用/分隔每个字符，例如AB对应'.-/-...'\n    - 将摩斯密码分成两个字符一组。如果摩斯密码长度为奇数，最后一个字符不进行映射，直接添加到密文末尾\n    - 根据数字索引映射表将每组字符转换为对应的数字字符串\n    - 加密后的消息用字符串表示\n\n解密算法:\n\n解密规则:\n- 输入:\n    - 密文: 数字字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - 数字索引映射表(与加密相同)\n    - 摩斯密码表(与加密相同)\n- 解密步骤(与加密步骤相反):\n    - 根据数字索引映射表将密文中的每个数字转换为对应的字符对。如果密文末尾有非数字字符，则不处理。此时获得完整的摩斯密码\n    - 通过/分隔摩斯密码获得每个字符的摩斯密码\n    - 根据摩斯密码表将每个字符的摩斯密码转换为对应的明文字符\n    - 最终明文字符为大写字符串\n"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: A string.\n- Preparation:\n    - Numerical-Index Mapping Table\n        - '..' : 5\n        - '.-' : 4\n        - './' : 9\n        - '-.' : 8\n        - '--' : 6\n        - '-/' : 7\n        - '/.' : 3\n        - '/-' : 1\n        - '//' : 2\n    - morse_code Table\n        - morse_code = {\n                'A': '.-',     'B': '-...',   'C': '-.-.',   'D': '-..',\n                'E': '.',      'F': '..-.',   'G': '--.',    'H': '....',\n                'I': '..',     'J': '.---',   'K': '-.-',    'L': '.-..',\n                'M': '--',     'N': '-.',     'O': '---',    'P': '.--.',\n                'Q': '--.-',   'R': '.-.',    'S': '...',    'T': '-',\n                'U': '..-',    'V': '...-',   'W': '.--',    'X': '-..-',\n                'Y': '-.--',   'Z': '--..',\n            }\n- Encryption Steps:\n    - Convert each character in the plaintext into Morse code according to the morse_code Table, with each character separated by a /, e.g., the Morse code corresponding to AB is '.-/-...'.\n    - Divide Morse code into two pairs of characters. If the length of the Morse code is odd, the last character, without the following mapping, is finally added to the end of the ciphertext.\n    - Each pair of characters is converted into a corresponding numeric string according to the numeric index mapping table.\n    - The encrypted message is represented by a string.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: A numeric string.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation:\n    - Numerical-Index Mapping Table (Same as encryption)\n    - morse_code Table (Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - Each digit in the ciphertext is converted to the corresponding character pair according to the digit-index mapping table. If there is a non-numeric character at the end of the ciphertext, it is not processed. By this point, the complete Morse code is obtained.\n    - Obtain the Morse code for each character by splitting the Morse code by /.\n    - Convert the Morse code of each character to the corresponding plaintext character according to the morse_code table.\n    - The final plaintext character is an uppercase string."]}
{"kor_rule_num": "7", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 字母表 = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'(不包含字母J)\n    - 8个网格(Grid0-Grid7)\n- 加密步骤:\n    - 明文按5个字符分组，从0开始编号\n    - 对于5个字符的块:\n        - 使用的网格由grid_index = (i // 5) % 8确定，其中i是块号。整数除法运算符//将左边的数除以右边的数，向下取整结果\n        - 对于当前块中的每个字符:\n            - 如果字符是\"J\"，不加密直接添加到加密块\n            - 否则，在当前网格中找到字符的位置。然后向右下方移动一个网格位置(row+1,col+1)(如果越界则在对应边界的另一侧继续)，移动后位置的字母作为加密字母\n            - 将加密字母添加到加密块\n    - 处理完所有块后，连接加密块形成最终加密消息", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 字母表 = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'(不包含字母J)\n    - 8个网格(Grid0-Grid7)\n- 加密步骤:\n    - 明文按5个字符分组，从0开始编号\n    - 对于5个字符的块:\n        - 使用的网格由grid_index = (i // 5) % 8确定，其中i是块号。整数除法运算符//将左边的数除以右边的数，向下取整结果\n        - 对于当前块中的每个字符:\n            - 如果字符是\"J\"，不加密直接添加到加密块\n            - 否则，在当前网格中找到字符的位置。然后向右下方移动一个网格位置(row+1,col+1)(如果越界则在对应边界的另一侧继续)，移动后位置的字母作为加密字母\n            - 将加密字母添加到加密块\n    - 处理完所有块后，连接加密块形成最终加密消息"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'(The letter J is excluded)\n    - 8 Grids:\n        \n        Grid0:\n        \n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        \n        Grid1:\n        \n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        \n        Grid2:\n        \n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        \n        Grid3:\n        \n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        \n        Grid4:\n        \n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        \n        Grid5:\n        \n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        \n        Grid6:\n        \n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        \n        Grid7:\n        \n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        \n- Encryption Steps:\n    - The plaintext is grouped into blocks of 5 characters, numbered from 0.\n    - For blocks of 5 characters:\n        - To use the grid is determined by calculating grid_index = (i // 5) % 8, where i is the number. Integer division operator // divides the number on the left by the number on the right, rounding down the result. That is, it removes the fractional part and keeps only the integer part!This ensures that the grid is recycled.\n        - For each character in the current block:\n            - If the character is \"J\", it is not encrypted and is appended directly to the encrypted block.\n            - Otherwise, find the position of the character in the current grid. Then move one grid position to the lower right (row+1,col+1) (or continue on the opposite side of the corresponding boundary if it crosses the boundary), and get the letter at the position after the move as the encrypted letter.\n            - Add the encrypted letter to the encryption block.\n    - After processing all the blocks, connect the encrypted blocks to form the final encrypted message.\n\n "]}
{"kor_rule_num": "25", "rule": "请根据加密算法对明文进行加密\n加密规则:\n    - 输入:\n        - 明文: 仅包含大写字母的字符串，不含标点符号和空格\n    - 输出:\n        - 密文: 十六进制字符串（包含小写字母a-e）\n    - 准备:\n        - 密钥(SHA哈希值)\n            - 对\"SECRET_KEY\"执行SHA-256运算，得到'73ef2a4edd7a7fbf07fd5f6faf99674dc0c25a025fd74c221f4c35849e5c0fb3'\n    - 加密步骤:\n        - 将明文字符串转换为字节序列（ASCII编码）\n        - 使用密钥对每个字节进行异或（XOR）运算加密。重复使用密钥使其长度与明文字节数相同\n        - 将加密后的字节序列转换为十六进制字符串作为密文输出", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n    - 输入:\n        - 明文: 仅包含大写字母的字符串，不含标点符号和空格\n    - 输出:\n        - 密文: 十六进制字符串（包含小写字母a-e）\n    - 准备:\n        - 密钥(SHA哈希值)\n            - 对\"SECRET_KEY\"执行SHA-256运算，得到'73ef2a4edd7a7fbf07fd5f6faf99674dc0c25a025fd74c221f4c35849e5c0fb3'\n    - 加密步骤:\n        - 将明文字符串转换为字节序列（ASCII编码）\n        - 使用密钥对每个字节进行异或（XOR）运算加密。重复使用密钥使其长度与明文字节数相同\n        - 将加密后的字节序列转换为十六进制字符串作为密文输出"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  Hexadecimal string (and letters a-e in lower case).\n- Preparation:\n    - Key(SHA hash value)\n        - Performing SHA-256 on \"SECRET_KEY\" results in '73ef2a4edd7a7fbf07fd5f6faf99674dc0c25a025fd74c221f4c35849e5c0fb3'.\n- Encryption Steps:\n    - Converts a plaintext string into a sequence of bytes (ASCII encoding).\n    - Each byte is encrypted with the corresponding byte of the key using a bitwise different-or (XOR) operation. Repeatedly recycle the key so that the key length is the same as the number of plaintext bytes.\n    - The encrypted byte sequence is converted to a hexadecimal string for ciphertext output.\n\n "]}
{"kor_rule_num": "20", "rule": "请根据加密算法对明文进行加密\n加密规则:\n    - 输入:\n        - 明文: 不含标点和空格的大写字母字符串\n    - 输出:\n        - 密文: 不含标点和空格的字符串\n    - 准备:\n        - 转置序列表:\n            - [1, 4, 0, 6, 5, 2, 3]\n            - 转置序列表用于按顺序逐行写入明文，然后根据转置序列表调整列的顺序，使每行中的字符按给定顺序排列。\n            - 列从0开始计数。\n    - 加密步骤:\n        - [1, 4, 0, 6, 5, 2, 3]转置序列表共7位，表示一行应写入7个字母。\n        - 按顺序逐行写入明文，每行7个。当不足7个时，最后一行用$填充。可以得到一个写入网格。\n        - 根据转置序列表调整列的顺序，即现在列的顺序为[原列1，原列4，原列0，原列6，原列5，原列2，原列3]，可以得到调整列顺序后的网格。\n        - 逐行读取网格并连接起来得到最终密文。(注意需要保留$)", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n    - 输入:\n        - 明文: 不含标点和空格的大写字母字符串\n    - 输出:\n        - 密文: 不含标点和空格的字符串\n    - 准备:\n        - 转置序列表:\n            - [1, 4, 0, 6, 5, 2, 3]\n            - 转置序列表用于按顺序逐行写入明文，然后根据转置序列表调整列的顺序，使每行中的字符按给定顺序排列。\n            - 列从0开始计数。\n    - 加密步骤:\n        - [1, 4, 0, 6, 5, 2, 3]转置序列表共7位，表示一行应写入7个字母。\n        - 按顺序逐行写入明文，每行7个。当不足7个时，最后一行用$填充。可以得到一个写入网格。\n        - 根据转置序列表调整列的顺序，即现在列的顺序为[原列1，原列4，原列0，原列6，原列5，原列2，原列3]，可以得到调整列顺序后的网格。\n        - 逐行读取网格并连接起来得到最终密文。(注意需要保留$)"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  A string without punctuation and spaces.\n- Preparation:\n    - Transposed sequence list:\n        - [1, 4, 0, 6, 5, 2, 3]\n        - The transposed sequence  list is used to write the plaintext in order one line at a time, and then the columns are adjusted according to the transposed sequence table so that the characters in each line are arranged in the given order.\n        - Columns count from 0.\n- Encryption Steps:\n    - The [1, 4, 0, 6, 5, 2, 3] transposed sequence table has a total of 7 bits, indicating that 7 letters should be written on a line.\n    - Write the plaintext in order, line by line, 7 per line. When there are less than 7, the last line is filled with $. A written grid can be obtained.\n    - According to the transposed sequence table, adjust the order of the columns, that is, the order of the columns is now [the original column 1, the original column 4, the original column 0, the original column 6, the original column 5, the original column 2, the original column 3], you can get after the adjustment of the columns after the order of the grid.\n    - Read the grid row by row and connect them to get the final ciphertext.(Note that $ needs to be retained.)\n\n "]}
{"kor_rule_num": "21", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n        加密规则:\n        - 输入:\n            - 明文: 仅包含大写字母(A-Z)的字符串，不含标点和空格\n        - 输出:\n            - 密文: 仅包含0和1的二进制字符串\n        - 准备:\n            - 固定密钥: 8位二进制字符串(例如'10101010')\n            - 置换表:\n                - 置换表: (2, 0, 3, 1, 4, 6, 5, 7)\n                - 逆置换表: (1, 3, 0, 2, 4, 6, 5, 7)\n        - 加密步骤:\n            1. 将每个字符转换为二进制:\n                - 将每个字符转换为ASCII值\n                - 将ASCII值转换为8位二进制字符串\n            2. XOR运算:\n                - 对字符的8位二进制表示与固定密钥进行XOR运算\n                - 如果需要，重复密钥以匹配二进制表示的长度\n            3. 置换:\n                - 对XOR结果应用置换表得到每个字符的最终加密二进制字符串\n            4. 合并二进制字符串:\n                - 将所有字符的二进制字符串连接形成最终密文\n        \n解密算法:\n\n        解密规则:\n        - 输入:\n            - 密文: 仅包含0和1的二进制字符串\n        - 输出:\n            - 明文: 仅包含大写字母(A-Z)的字符串，不含标点和空格\n        - 准备:\n            - 固定密钥: 与加密使用的相同8位二进制字符串(例如'10101010')\n            - 置换表:\n                - 置换表: (2, 0, 3, 1, 4, 6, 5, 7)\n                - 逆置换表: (1, 3, 0, 2, 4, 6, 5, 7)\n        - 解密步骤:\n            1. 将密文分块:\n                - 将二进制密文分成8位一组，每组代表一个加密字符\n            2. 逆置换:\n                - 对每个8位块应用逆置换表以还原加密时的置换\n            3. XOR运算:\n                - 对置换后的二进制块与固定密钥进行XOR运算\n            4. 二进制转字符:\n                - 将得到的二进制字符串转换为十进制值\n                - 将十进制值转换为对应的ASCII字符\n            5. 合并字符:\n                - 将每个二进制块得到的字符连接形成最终明文\n        ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n        加密规则:\n        - 输入:\n            - 明文: 仅包含大写字母(A-Z)的字符串，不含标点和空格\n        - 输出:\n            - 密文: 仅包含0和1的二进制字符串\n        - 准备:\n            - 固定密钥: 8位二进制字符串(例如'10101010')\n            - 置换表:\n                - 置换表: (2, 0, 3, 1, 4, 6, 5, 7)\n                - 逆置换表: (1, 3, 0, 2, 4, 6, 5, 7)\n        - 加密步骤:\n            1. 将每个字符转换为二进制:\n                - 将每个字符转换为ASCII值\n                - 将ASCII值转换为8位二进制字符串\n            2. XOR运算:\n                - 对字符的8位二进制表示与固定密钥进行XOR运算\n                - 如果需要，重复密钥以匹配二进制表示的长度\n            3. 置换:\n                - 对XOR结果应用置换表得到每个字符的最终加密二进制字符串\n            4. 合并二进制字符串:\n                - 将所有字符的二进制字符串连接形成最终密文\n        \n解密算法:\n\n        解密规则:\n        - 输入:\n            - 密文: 仅包含0和1的二进制字符串\n        - 输出:\n            - 明文: 仅包含大写字母(A-Z)的字符串，不含标点和空格\n        - 准备:\n            - 固定密钥: 与加密使用的相同8位二进制字符串(例如'10101010')\n            - 置换表:\n                - 置换表: (2, 0, 3, 1, 4, 6, 5, 7)\n                - 逆置换表: (1, 3, 0, 2, 4, 6, 5, 7)\n        - 解密步骤:\n            1. 将密文分块:\n                - 将二进制密文分成8位一组，每组代表一个加密字符\n            2. 逆置换:\n                - 对每个8位块应用逆置换表以还原加密时的置换\n            3. XOR运算:\n                - 对置换后的二进制块与固定密钥进行XOR运算\n            4. 二进制转字符:\n                - 将得到的二进制字符串转换为十进制值\n                - 将十进制值转换为对应的ASCII字符\n            5. 合并字符:\n                - 将每个二进制块得到的字符连接形成最终明文\n        "], "replace_en": ["**Encryption Rules**\n\n- Input:\n    - Plaintext: A string of uppercase letters (A-Z) without punctuation and spaces.\n- Output:\n    - Ciphertext: A binary string containing only 0s and 1s.\n- Preparation:\n    - Fixed Key: A binary string of length 8 (e.g., '10101010').\n    - Permutation Table:\n        - Permutation Table: (2, 0, 3, 1, 4, 6, 5, 7)\n        - Inverse Permutation Table: (1, 3, 0, 2, 4, 6, 5, 7)\n- Encryption Steps:\n    1. Convert Each Character to Binary:\n        - For each character in the plaintext, convert it to its ASCII value.\n        - Convert this ASCII value to an 8-bit binary string.\n    2. XOR Operation:\n        - Perform an XOR operation between the 8-bit binary representation of the character and the fixed key.\n        - Ensure the key is repeated to match the length of the binary representation if needed.\n    3. Permutation:\n        - Apply the permutation table to the XOR result to get the final encrypted binary string for each character.\n    4. Combine Binary Strings:\n        - Concatenate the binary strings of all characters to form the final ciphertext.\n\n**Decryption Rules**\n\n- Input:\n    - Ciphertext: A binary string containing only 0s and 1s.\n- Output:\n    - Plaintext: A string of uppercase letters (A-Z) without punctuation and spaces.\n- Preparation:\n    - Fixed Key: Same binary string of length 8 used for encryption (e.g., '10101010').\n    - Permutation Table:\n        - Permutation Table: (2, 0, 3, 1, 4, 6, 5, 7)\n        - Inverse Permutation Table: (1, 3, 0, 2, 4, 6, 5, 7)\n- Decryption Steps:\n    1. Split Ciphertext into Chunks:\n        - Split the binary ciphertext into 8-bit chunks, each representing an encrypted character.\n    2. Inverse Permutation:\n        - Apply the inverse permutation table to each 8-bit chunk to reverse the permutation applied during encryption.\n    3. XOR Operation:\n        - Perform an XOR operation between the permuted binary chunk and the fixed key.\n    4. Convert Binary to Character:\n        - Convert the resulting binary string back to its decimal equivalent.\n        - Convert this decimal value to its corresponding ASCII character.\n    5. Combine Characters:\n        - Concatenate the characters obtained from each binary chunk to form the final plaintext."]}
{"kor_rule_num": "21", "rule": "请根据加密算法对明文进行加密\n\n        加密规则:\n        - 输入:\n            - 明文: 仅包含大写字母(A-Z)的字符串，不含标点和空格\n        - 输出:\n            - 密文: 仅包含0和1的二进制字符串\n        - 准备:\n            - 固定密钥: 8位二进制字符串(例如'10101010')\n            - 置换表:\n                - 置换表: (2, 0, 3, 1, 4, 6, 5, 7)\n                - 逆置换表: (1, 3, 0, 2, 4, 6, 5, 7)\n        - 加密步骤:\n            1. 将每个字符转换为二进制:\n                - 将每个字符转换为ASCII值\n                - 将ASCII值转换为8位二进制字符串\n            2. XOR运算:\n                - 对字符的8位二进制表示与固定密钥进行XOR运算\n                - 如果需要，重复密钥以匹配二进制表示的长度\n            3. 置换:\n                - 对XOR结果应用置换表得到每个字符的最终加密二进制字符串\n            4. 合并二进制字符串:\n                - 将所有字符的二进制字符串连接形成最终密文\n        ", "replace": ["请根据加密算法对明文进行加密\n\n        加密规则:\n        - 输入:\n            - 明文: 仅包含大写字母(A-Z)的字符串，不含标点和空格\n        - 输出:\n            - 密文: 仅包含0和1的二进制字符串\n        - 准备:\n            - 固定密钥: 8位二进制字符串(例如'10101010')\n            - 置换表:\n                - 置换表: (2, 0, 3, 1, 4, 6, 5, 7)\n                - 逆置换表: (1, 3, 0, 2, 4, 6, 5, 7)\n        - 加密步骤:\n            1. 将每个字符转换为二进制:\n                - 将每个字符转换为ASCII值\n                - 将ASCII值转换为8位二进制字符串\n            2. XOR运算:\n                - 对字符的8位二进制表示与固定密钥进行XOR运算\n                - 如果需要，重复密钥以匹配二进制表示的长度\n            3. 置换:\n                - 对XOR结果应用置换表得到每个字符的最终加密二进制字符串\n            4. 合并二进制字符串:\n                - 将所有字符的二进制字符串连接形成最终密文\n        "], "replace_en": ["**Encryption Rules**\n\n- Input:\n    - Plaintext: A string of uppercase letters (A-Z) without punctuation and spaces.\n- Output:\n    - Ciphertext: A binary string containing only 0s and 1s.\n- Preparation:\n    - Fixed Key: A binary string of length 8 (e.g., '10101010').\n    - Permutation Table:\n        - Permutation Table: (2, 0, 3, 1, 4, 6, 5, 7)\n        - Inverse Permutation Table: (1, 3, 0, 2, 4, 6, 5, 7)\n- Encryption Steps:\n    1. Convert Each Character to Binary:\n        - For each character in the plaintext, convert it to its ASCII value.\n        - Convert this ASCII value to an 8-bit binary string.\n    2. XOR Operation:\n        - Perform an XOR operation between the 8-bit binary representation of the character and the fixed key.\n        - Ensure the key is repeated to match the length of the binary representation if needed.\n    3. Permutation:\n        - Apply the permutation table to the XOR result to get the final encrypted binary string for each character.\n    4. Combine Binary Strings:\n        - Concatenate the binary strings of all characters to form the final ciphertext.\n\n"]}
{"kor_rule_num": "20", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n    - 输入:\n        - 明文: 不含标点和空格的大写字母字符串\n    - 输出:\n        - 密文: 不含标点和空格的字符串\n    - 准备:\n        - 转置序列表:\n            - [1, 4, 0, 6, 5, 2, 3]\n            - 转置序列表用于按顺序逐行写入明文，然后根据转置序列表调整列的顺序，使每行中的字符按给定顺序排列。\n            - 列从0开始计数。\n    - 加密步骤:\n        - [1, 4, 0, 6, 5, 2, 3]转置序列表共7位，表示一行应写入7个字母。\n        - 按顺序逐行写入明文，每行7个。当不足7个时，最后一行用$填充。可以得到一个写入网格。\n        - 根据转置序列表调整列的顺序，即现在列的顺序为[原列1，原列4，原列0，原列6，原列5，原列2，原列3]，可以得到调整列顺序后的网格。\n        - 逐行读取网格并连接起来得到最终密文。(注意需要保留$)\n解密算法:\n解密规则:\n    - 输入:\n        - 密文: 不含标点和空格的字符串\n    - 输出:\n        - 明文: 不含标点和空格的大写字母字符串\n    - 准备:\n        - 转置序列表(与加密相同)\n    - 解密步骤:\n        - 按顺序逐行写入密文，每行7个字母。\n        - 逐行读取，但读取每行时，先读取对应0的第2列的字符，然后读取对应1的第0列的字符，然后读取对应2的第6列的字符，依此类推。\n        - 最终逐行读取信息，去掉末尾的$，即可得到解密后的明文。", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n    - 输入:\n        - 明文: 不含标点和空格的大写字母字符串\n    - 输出:\n        - 密文: 不含标点和空格的字符串\n    - 准备:\n        - 转置序列表:\n            - [1, 4, 0, 6, 5, 2, 3]\n            - 转置序列表用于按顺序逐行写入明文，然后根据转置序列表调整列的顺序，使每行中的字符按给定顺序排列。\n            - 列从0开始计数。\n    - 加密步骤:\n        - [1, 4, 0, 6, 5, 2, 3]转置序列表共7位，表示一行应写入7个字母。\n        - 按顺序逐行写入明文，每行7个。当不足7个时，最后一行用$填充。可以得到一个写入网格。\n        - 根据转置序列表调整列的顺序，即现在列的顺序为[原列1，原列4，原列0，原列6，原列5，原列2，原列3]，可以得到调整列顺序后的网格。\n        - 逐行读取网格并连接起来得到最终密文。(注意需要保留$)\n解密算法:\n解密规则:\n    - 输入:\n        - 密文: 不含标点和空格的字符串\n    - 输出:\n        - 明文: 不含标点和空格的大写字母字符串\n    - 准备:\n        - 转置序列表(与加密相同)\n    - 解密步骤:\n        - 按顺序逐行写入密文，每行7个字母。\n        - 逐行读取，但读取每行时，先读取对应0的第2列的字符，然后读取对应1的第0列的字符，然后读取对应2的第6列的字符，依此类推。\n        - 最终逐行读取信息，去掉末尾的$，即可得到解密后的明文。"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  A string without punctuation and spaces.\n- Preparation:\n    - Transposed sequence list:\n        - [1, 4, 0, 6, 5, 2, 3]\n        - The transposed sequence  list is used to write the plaintext in order one line at a time, and then the columns are adjusted according to the transposed sequence table so that the characters in each line are arranged in the given order.\n        - Columns count from 0.\n- Encryption Steps:\n    - The [1, 4, 0, 6, 5, 2, 3] transposed sequence table has a total of 7 bits, indicating that 7 letters should be written on a line.\n    - Write the plaintext in order, line by line, 7 per line. When there are less than 7, the last line is filled with $. A written grid can be obtained.\n    - According to the transposed sequence table, adjust the order of the columns, that is, the order of the columns is now [the original column 1, the original column 4, the original column 0, the original column 6, the original column 5, the original column 2, the original column 3], you can get after the adjustment of the columns after the order of the grid.\n    - Read the grid row by row and connect them to get the final ciphertext.(Note that $ needs to be retained.)\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: A string without punctuation and spaces.\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - Transposed sequence list (Same as encryption)\n- Decryption Steps:\n    - Write the ciphertext sequentially, line by line, 7 letters per line.\n    - Read line by line, but when reading each line, read a character in column 2 corresponding to 0, then a character in column 0 corresponding to 1, then a character in column 6 corresponding to 2, etc., etc., etc., etc., etc., etc.\n    - Eventually read the message line by line, remove the $ at the end, you can get the decrypted plaintext."]}
{"kor_rule_num": "19", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 6x6矩阵 (矩阵中的行和列从0开始计数)\n        [['R', 'U', 'A', '0', 'Q', 'B'], \n        ['D', '2', 'W', 'K', 'S', '1'], \n        ['H', '4', '5', 'F', 'T', 'Z'], \n        ['Y', 'C', 'G', 'X', '7', 'L'], \n        ['9', '8', 'I', '3', 'P', 'N'], \n        ['6', 'J', 'V', 'O', 'E', 'M']]\n    - 加密字符集: \"ADFGVX\"\n- 加密步骤:\n    - 对明文中的每个字符:\n        - 在6X6矩阵中找到该字符的行数和列数。例如，A的行数为0，列数为2。\n        - 加密字符集中的字符位置标记为0-6。使用加密字符集中对应位置的字符替换行数和列数得到加密二元组。\n            - 例如，A的行数为0对应加密字符集中的A，列数为2对应加密字符集中的F，所以A的加密二元组为(A,F)。\n        - 读取所有加密二元组的行，然后读取所有加密二元组的列得到最终密文。\n            - 例如，加密二元组为(A,F)(X,V)，最后读取为AXFV，所以最终密文为AXFV。\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 明文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 6x6矩阵 (与加密相同)\n    - 加密字符集 (与加密相同)\n- 解密步骤:\n    - 将密文分成两半\n    - 每次从上半部分和下半部分各取一个字母作为解密二元组:\n        - 加密字符集中的字符位置标记为0-6，使用加密字符集中对应字符的位置解密出解密二元组代表的行数和列数。\n            - 例如，解密二元组为加密二元组(A,F)，A的位置为0，F的位置为2，所以行数为0，列数为2，得到(0,2)。\n        - 使用得到的行数和列数在6x6矩阵中找到对应位置的字母作为解密后的字符。\n            - 例如，(0,2)位置的字符为A，所以AF解密后的字符为A。\n    - 连接所有解密后的字符得到最终明文。", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 6x6矩阵 (矩阵中的行和列从0开始计数)\n        [['R', 'U', 'A', '0', 'Q', 'B'], \n        ['D', '2', 'W', 'K', 'S', '1'], \n        ['H', '4', '5', 'F', 'T', 'Z'], \n        ['Y', 'C', 'G', 'X', '7', 'L'], \n        ['9', '8', 'I', '3', 'P', 'N'], \n        ['6', 'J', 'V', 'O', 'E', 'M']]\n    - 加密字符集: \"ADFGVX\"\n- 加密步骤:\n    - 对明文中的每个字符:\n        - 在6X6矩阵中找到该字符的行数和列数。例如，A的行数为0，列数为2。\n        - 加密字符集中的字符位置标记为0-6。使用加密字符集中对应位置的字符替换行数和列数得到加密二元组。\n            - 例如，A的行数为0对应加密字符集中的A，列数为2对应加密字符集中的F，所以A的加密二元组为(A,F)。\n        - 读取所有加密二元组的行，然后读取所有加密二元组的列得到最终密文。\n            - 例如，加密二元组为(A,F)(X,V)，最后读取为AXFV，所以最终密文为AXFV。\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 明文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 6x6矩阵 (与加密相同)\n    - 加密字符集 (与加密相同)\n- 解密步骤:\n    - 将密文分成两半\n    - 每次从上半部分和下半部分各取一个字母作为解密二元组:\n        - 加密字符集中的字符位置标记为0-6，使用加密字符集中对应字符的位置解密出解密二元组代表的行数和列数。\n            - 例如，解密二元组为加密二元组(A,F)，A的位置为0，F的位置为2，所以行数为0，列数为2，得到(0,2)。\n        - 使用得到的行数和列数在6x6矩阵中找到对应位置的字母作为解密后的字符。\n            - 例如，(0,2)位置的字符为A，所以AF解密后的字符为A。\n    - 连接所有解密后的字符得到最终明文。"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  Uppercase letters  string without punctuation and spaces.\n- Preparation:\n    - 6x6 Matrix (The rows and columns in the matrix are counted from 0.)\n        \n        [['R', 'U', 'A', '0', 'Q', 'B'], \n        ['D', '2', 'W', 'K', 'S', '1'], \n        ['H', '4', '5', 'F', 'T', 'Z'],\n        ['Y', 'C', 'G', 'X', '7', 'L'], \n        ['9', '8', 'I', '3', 'P', 'N'],\n        ['6', 'J', 'V', 'O', 'E', 'M']]\n        \n    - Encrypted Character Set\n        - \"ADFGVX\"\n- Encryption Steps:\n    - For each character in the plaintext:\n        - Find the number of rows and columns of that character in the 6X6 matrix. For example, A has 0 rows and 2 columns.\n        - The position of each character in the encrypted character set is flagged as 0-6. Use the character at the corresponding position in the encrypted character set to replace the number of rows and columns to get the encrypted binary.\n            - For example, the number of rows of A is 0, which corresponds to A in the encrypted character set, and the number of columns of A is 2, which corresponds to F in the encrypted character set. so the encrypted binary corresponding to A is (A,F).The encrypted binary is (A,F).\n        - Read all rows of the encrypted binary, and then read all columns of the encrypted binary to get the final ciphertext.\n            - For example, the encrypted binary is (A,F)(X,V), the last read is AXFV, so the final ciphertext is AXFV.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters  string without punctuation and spaces.\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - 6x6 Matrix (Same as encryption)\n    - Encrypted Character Set (Same as encryption)\n- Decryption Steps:\n    - Divide the ciphertext into two halves.\n    - Take one letter from the upper half and one letter from the lower half each time as a decryption binary:\n        - The position of each character in the encrypted character set is flagged as 0-6, and the position of the corresponding character in the encrypted character set is used to decrypt the number of rows and columns represented by the decrypted binary.\n            - For example, the decrypted binary is the encrypted binary as (A,F), the position of A is 0 and the position of F is 2, so the number of rows is 0 and the number of columns is 2, obtaining (0, 2).\n        - Use the number of rows and columns obtained to find the letter in the corresponding position in the 6x6 matrix as the character after decryption.\n            - For example, the character at (0, 2) is A, and the character after AF decryption is A.\n    - Concatenate all the decrypted characters to get the final plaintext."]}
{"kor_rule_num": "5", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 仿射字母表 = \"XMJQUDONPRGTVBWFAKSHZCYEIL\"\n    - 将每个字母与其在仿射字母表中的位置关联（从0开始）:\n        X->0, M->1, J->2, Q->3, U->4, D->5, O->6, N->7,\n        P->8, R->9, G->10, T->11, V->12, B->13, W->14, F->15,\n        A->16, K->17, S->18, H->19, Z->20, C->21, Y->22, E->23, I->24, L->25\n    - A: 3\n    - B: 5\n    - A_inv: 9\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 设x为其在仿射字母表中的位置\n        - 应用仿射编码函数计算y:\n            - y = (Ax + B) mod 26\n        - 在仿射字母表中找到位置y对应的字母，形成加密消息\n解密算法:\n解密规则:\n    - 输入:\n        - 密文: 大写字母字符串\n    - 输出:\n        - 明文: 大写字母字符串\n    - 准备:\n        - 仿射字母表 = \"XMJQUDONPRGTVBWFAKSHZCYEIL\"\n        - 将每个字母与其在仿射字母表中的位置关联（从0开始）:\n            X->0, M->1, J->2, Q->3, U->4, D->5, O->6, N->7,\n            P->8, R->9, G->10, T->11, V->12, B->13, W->14, F->15,\n            A->16, K->17, S->18, H->19, Z->20, C->21, Y->22, E->23, I->24, L->25\n        - A: 3\n        - B: 5\n        - A_inv: 9\n    - 解密步骤:\n        - 对于每个密文字符c:\n            - 设y为其在仿射字母表中的位置\n            - 计算x:\n                - x = A_inv * (y - B) % n\n            - 用仿射字母表中位置x处的字母替换c，形成解密消息", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 仿射字母表 = \"XMJQUDONPRGTVBWFAKSHZCYEIL\"\n    - 将每个字母与其在仿射字母表中的位置关联（从0开始）:\n        X->0, M->1, J->2, Q->3, U->4, D->5, O->6, N->7,\n        P->8, R->9, G->10, T->11, V->12, B->13, W->14, F->15,\n        A->16, K->17, S->18, H->19, Z->20, C->21, Y->22, E->23, I->24, L->25\n    - A: 3\n    - B: 5\n    - A_inv: 9\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 设x为其在仿射字母表中的位置\n        - 应用仿射编码函数计算y:\n            - y = (Ax + B) mod 26\n        - 在仿射字母表中找到位置y对应的字母，形成加密消息\n解密算法:\n解密规则:\n    - 输入:\n        - 密文: 大写字母字符串\n    - 输出:\n        - 明文: 大写字母字符串\n    - 准备:\n        - 仿射字母表 = \"XMJQUDONPRGTVBWFAKSHZCYEIL\"\n        - 将每个字母与其在仿射字母表中的位置关联（从0开始）:\n            X->0, M->1, J->2, Q->3, U->4, D->5, O->6, N->7,\n            P->8, R->9, G->10, T->11, V->12, B->13, W->14, F->15,\n            A->16, K->17, S->18, H->19, Z->20, C->21, Y->22, E->23, I->24, L->25\n        - A: 3\n        - B: 5\n        - A_inv: 9\n    - 解密步骤:\n        - 对于每个密文字符c:\n            - 设y为其在仿射字母表中的位置\n            - 计算x:\n                - x = A_inv * (y - B) % n\n            - 用仿射字母表中位置x处的字母替换c，形成解密消息"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - affine alphabet = \"XMJQUDONPRGTVBWFAKSHZCYEIL\"\n    - Associate each letter with its position in the affine alphabet (starting from 0):\n        \n        X -> 0, M -> 1, J -> 2, Q -> 3, U -> 4, D -> 5, O -> 6, N -> 7,\n        P -> 8, R -> 9, G -> 10, T -> 11, V -> 12, B -> 13, W -> 14, F -> 15,\n        A -> 16, K -> 17, S -> 18, H -> 19, Z -> 20, C -> 21, Y -> 22, E -> 23, I -> 24, L -> 25\n        \n    - A: 3\n    - B: 5\n    - A_inv: 9\n- Encryption Steps:\n    - For each given plaintext character p:\n        - Let  x  denote its position in the affine alphabet.\n        - Apply the affine coding function to compute y:\n            - y = (Ax + B) mod 26\n        - Find the corresponding letter in the affine alphabet at position  y , forming the encrypted message.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation:\n    - affine alphabet = \"XMJQUDONPRGTVBWFAKSHZCYEIL\"\n    - Associate each letter with its position in the affine alphabet (starting from 0):\n        \n        X -> 0, M -> 1, J -> 2, Q -> 3, U -> 4, D -> 5, O -> 6, N -> 7,\n        P -> 8, R -> 9, G -> 10, T -> 11, V -> 12, B -> 13, W -> 14, F -> 15,\n        A -> 16, K -> 17, S -> 18, H -> 19, Z -> 20, C -> 21, Y -> 22, E -> 23, I -> 24, L -> 25\n        \n    - A: 3\n    - B: 5\n    - A_inv: 9\n- Decryption Steps (exact opposite of encryption steps):\n    - For each given ciphertext character c:\n        - Let y denote its position in the affine alphabet.\n        - Calculate x:\n            - x = A_inv * (y - B) % n.\n        - Replace c with the letter at position x  in the affine alphabet to form the decrypted message."]}
{"kor_rule_num": "1", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 标准字母表: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    - 反转字母表: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    - 替换字母表: \"RFDJUHABCEGIKLMNOPQSTVWXYZ\"\n- 加密步骤:\n    - 对明文中的每个字母p:\n    - (1) 使用反转字母表进行反向映射。在标准字母表中找到其位置，并用反转字母表中对应位置的字母替换。例如，A映射为Z，B映射为Y。\n    - (2) 将步骤(1)得到的字母在标准字母表顺序中向前移动4位。例如，如果p=A，经过步骤(1)映射为Z，然后Z在标准字母表中向前移动4位得到D。\n    - (3) 将步骤(2)得到的字母，在标准字母表中找到其位置，用替换字母表中对应位置的字母替换，得到最终的密文字母。例如，如果经过步骤(2)得到字母D，则映射为J。\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 大写字母字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - 标准字母表: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    - 反转字母表: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    - 替换字母表: \"RFDJUHABCEGIKLMNOPQSTVWXYZ\"\n- 解密步骤(与加密步骤完全相反):\n    - (1) 对密文中的每个字母c，在替换字母表中找到其位置，用标准字母表中对应位置的字母替换。\n    - (2) 将步骤(1)得到的字母按标准字母表顺序向后移动4位。\n    - (3) 将步骤(2)得到的字母，在反转字母表中找到其位置，然后用标准字母表中对应位置的字母替换。例如，Z映射为A，Y映射为B。", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 标准字母表: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    - 反转字母表: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    - 替换字母表: \"RFDJUHABCEGIKLMNOPQSTVWXYZ\"\n- 加密步骤:\n    - 对明文中的每个字母p:\n    - (1) 使用反转字母表进行反向映射。在标准字母表中找到其位置，并用反转字母表中对应位置的字母替换。例如，A映射为Z，B映射为Y。\n    - (2) 将步骤(1)得到的字母在标准字母表顺序中向前移动4位。例如，如果p=A，经过步骤(1)映射为Z，然后Z在标准字母表中向前移动4位得到D。\n    - (3) 将步骤(2)得到的字母，在标准字母表中找到其位置，用替换字母表中对应位置的字母替换，得到最终的密文字母。例如，如果经过步骤(2)得到字母D，则映射为J。\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 大写字母字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - 标准字母表: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    - 反转字母表: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    - 替换字母表: \"RFDJUHABCEGIKLMNOPQSTVWXYZ\"\n- 解密步骤(与加密步骤完全相反):\n    - (1) 对密文中的每个字母c，在替换字母表中找到其位置，用标准字母表中对应位置的字母替换。\n    - (2) 将步骤(1)得到的字母按标准字母表顺序向后移动4位。\n    - (3) 将步骤(2)得到的字母，在反转字母表中找到其位置，然后用标准字母表中对应位置的字母替换。例如，Z映射为A，Y映射为B。"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - standard_alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    - reversed_alphabet: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    - substitution_alphabet: \"RFDJUHABCEGIKLMNOPQSTVWXYZ\"\n- Encryption Steps:\n    - For each letter p in the given Plaintext:\n    - (1) Use reversed_alphabet for reverse mapping. Find its position in the standard_alphabet and replace it with the letter in the corresponding position in reversed_alphabet. For example, A is mapped to Z and B is mapped to Y.\n    - (2) Move the letter obtained in (1) forward 4 places in the standard_alphabet order. For example, if p=A, after (1) is mapped to Z, then Z is shifted forward 4 positions in the standard_alphabet to get D.\n    - (3) Replace the letter obtained from (2) by finding its position in standard_alphabet and using the corresponding letter in substitution_alphabet, resulting in the final ciphertext letter. For example, if the letter obtained by going through (2) is D, it is mapped as J.\n\n**Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation:\n    - alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    - reversed_alphabet: \"ZYXWVUTSRQPONMLKJIHGFEDCBA\"\n    - substitution_alphabet: \"RFDJUHABCEGIKLMNOPQSTVWXYZ\"\n- Decryption Steps (exact opposite of encryption steps):\n    - (1) For each letter c in Ciphertext, find its position in substitution_alphabet and replace it with the corresponding letter in standard_alphabet.\n    - (2) Shift the letter obtained from (1) backward by 4 positions according to the standard_alphabet order.\n    - (3) Replace the letter obtained from (2) by finding its position in reversed_alphabet, then replace it with the corresponding letter in standard_alphabet. For example, Z maps to A, Y maps to B."]}
{"kor_rule_num": "14", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 数字字符串，不含标点和空格\n- 准备:\n    - 3个网格(所有行列号从0开始计数):\n        - 网格1 (3x9):\n            Q W E R T Y U I O\n            P A S D F G H J K\n            L Z X C V B N M #\n        - 网格2 (9x3):\n            Q W E\n            R T Y\n            U I O\n            P A S\n            D F G\n            H J K\n            L Z X\n            C V B\n            N M #\n        - 网格3 (3x3):\n            1 2 3\n            4 5 6\n            7 8 9\n- 加密步骤:\n    - 移除所有空格和标点，将文本转换为大写字母\n    - 将明文切分为6个字符一组，如果最后一组不足6个字符，用#填充\n    - 将每组6个字符分成3个二元组\n    - 对每个二元组(L1, L2)执行以下操作:\n        - 确定L1在网格1中的行列号(l1_row, l1_col)\n        - 确定L2在网格2中的行列号(l2_row, l2_col)\n        - 在网格3中用l1_row和l2_col找到对应数字num3\n        - 输出三元组(l1_col, num3, l2_row)\n    - 将所有三元组连接成一个数字串作为加密信息", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 数字字符串，不含标点和空格\n- 准备:\n    - 3个网格(所有行列号从0开始计数):\n        - 网格1 (3x9):\n            Q W E R T Y U I O\n            P A S D F G H J K\n            L Z X C V B N M #\n        - 网格2 (9x3):\n            Q W E\n            R T Y\n            U I O\n            P A S\n            D F G\n            H J K\n            L Z X\n            C V B\n            N M #\n        - 网格3 (3x3):\n            1 2 3\n            4 5 6\n            7 8 9\n- 加密步骤:\n    - 移除所有空格和标点，将文本转换为大写字母\n    - 将明文切分为6个字符一组，如果最后一组不足6个字符，用#填充\n    - 将每组6个字符分成3个二元组\n    - 对每个二元组(L1, L2)执行以下操作:\n        - 确定L1在网格1中的行列号(l1_row, l1_col)\n        - 确定L2在网格2中的行列号(l2_row, l2_col)\n        - 在网格3中用l1_row和l2_col找到对应数字num3\n        - 输出三元组(l1_col, num3, l2_row)\n    - 将所有三元组连接成一个数字串作为加密信息"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: A numeric string without punctuation and spaces.\n- Preparation:\n    - 3 Girds(All row and column numbers are counted from 0.):\n        - Grid 1 (3x9):\n            \n            Q W E R T Y U I O\n            P A S D F G H J K\n            L Z X C V B N M #\n            \n        - Grid 2 (9x3):\n            \n            Q W E\n            R T Y\n            U I O\n            P A S\n            D F G\n            H J K\n            L Z X\n            C V B\n            N M #\n            \n        - Grid 3 (3x3):\n            \n            1 2 3\n            4 5 6\n            7 8 9\n            \n- Encryption Steps:\n    - Remove all spaces and punctuation from the plain text and convert them to capital letters.\n    - Cut the plaintext into groups of 6 characters, and if a group is less than 6 characters long, fill it with `#`.\n    - Split each group of 6 characters into 3 binary groups.\n    - For each binary group `(L1, L2)` do the following:\n        - Determine the row and column numbers  of `L1` in `grid1` as `(l1_row, l1_col)`.\n        - Determine the row and column numbers of `L2` in `grid2` as `(l2_row, l2_col)`.\n        - Find the corresponding number `num3` in `grid3` from `l1_row` and `l2_col`.\n        - Output the triple `(l1_col, num3, l2_row)` of the three numbers.\n            - For example, for the binary (T,H), the row and column numbers of T in `grid1` are (0,4), the row and column numbers of H in `grid2` are (5,0).\n            - Based on `l1_row` (0) and `l2_col`(0) , the corresponding number `num3` found in `grid3` is 1, and the final ternary is (4, 1, 5).\n    - After performing the previous step multiple times and converting all the binary groups to triples, read them in turn to form a string of numbers that can be used as encrypted information. For example (4, 1, 5), (2, 3, 3), (8, 1, 8), the final encrypted message is 415233818.\n\n "]}
{"kor_rule_num": "6", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n    - 输入:\n        - 明文: 大写字母字符串,不含标点和空格\n    - 输出:\n        - 密文: 大写字母字符串\n    - 准备:\n        - LETTERS = ['J', 'D', 'W', 'O', 'T', 'R', 'A', 'C', 'X', 'Q', 'M', 'F', 'Y', 'E', 'Z', 'G', 'U', 'K', 'P', 'V', 'B', 'S', 'H', 'N', 'L', 'I']\n        - 将每个字母与其在LETTERS中的位置关联(从0开始):\n            J->0, D->1, W->2, O->3, T->4, R->5, A->6, C->7, X->8, Q->9, M->10, F->11, Y->12, E->13, Z->14, G->15, U->16, K->17, P->18, V->19, B->20, S->21, H->22, N->23, L->24, I->25\n        - 初始卡牌序列:\n            - 54张卡牌的列表,包括52张花色牌和2张可区分的王牌(A王牌和B王牌)。花色牌按四种花色顺序编号1-52,王牌值为53和54。\n            - [9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 53, 26, 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 54, 46, 23, 31, 24, 14, 8, 33, 2, 49, 45, 21]\n        - 密钥流算法:\n            该算法通过移动卡牌生成密钥流值。算法是确定性的,意味着密钥流值仅取决于卡牌的初始顺序。卡牌组被视为循环数组,允许需要移到底部的卡牌绕到顶部。\n            \n            执行以下步骤生成密钥流的一个字符:\n            1. 找到A王牌并下移一位。如果是最后一张牌,则成为第二张牌。不能成为第一张牌。\n            2. 找到B王牌并下移两位。如果是倒数第二张牌,则绕到第二位。如果是最后一张牌,则成为第三张牌。不能成为第一张牌。\n            3. 进行\"三切\":用王牌作为边界将牌组分成三部分,然后交换顶部和底部。王牌本身及其之间的牌保持不变。\n            4. 进行\"计数切\":检查牌组底牌。如果是王牌(53/54),其值固定为53。从牌组顶部取出该数量的牌,插入到最后一张牌的上方。\n            5. 查看顶牌的值。同样,任何王牌计为53。计算该牌下方的位置数,使用该位置的牌值作为下一个密钥流值。如果计算出的牌是王牌,忽略它并重复密钥流算法。\n            6. 返回生成的密钥流值\n    - 加密步骤:\n        - cards=初始卡牌序列\n        - 对每个明文字符p:\n            - 使用字母表将p转换为对应的位置值x(从0开始)\n            - 使用初始卡牌序列为p生成密钥流值y:\n                - y, cards = 密钥流算法(cards)\n                - 该算法修改卡牌顺序,下次执行使用新顺序\n            - 当密钥流值y加到位置值x时,应用模26运算得到z:\n                - z=(y+x) % 26\n            - 使用LETTERS列表返回对应位置z的字母\n            - 将其附加到密文\n解密算法:\n解密规则:\n    - 输入:\n        - 密文: 大写字母字符串\n    - 输出:\n        - 明文: 大写字母字符串\n    - 准备:\n        - LETTERS = ['J', 'D', 'W', 'O', 'T', 'R', 'A', 'C', 'X', 'Q', 'M', 'F', 'Y', 'E', 'Z', 'G', 'U', 'K', 'P', 'V', 'B', 'S', 'H', 'N', 'L', 'I']\n        - 将每个字母与其在LETTERS中的位置关联(从0开始):\n            J->0, D->1, W->2, O->3, T->4, R->5, A->6, C->7, X->8, Q->9, M->10, F->11, Y->12, E->13, Z->14, G->15, U->16, K->17, P->18, V->19, B->20, S->21, H->22, N->23, L->24, I->25\n        - 初始卡牌序列(与加密相同)\n        - 密钥流算法(与加密相同)\n    - 解密步骤(与加密步骤完全相反):\n        - cards=初始卡牌序列\n        - 对每个密文字符c:\n            - 使用LETTERS将c转换为对应的位置值z(从0开始)\n            - 为c生成密钥流值y:\n                - y, cards = 密钥流算法(cards)\n                - 该算法修改卡牌顺序,下次执行使用新顺序\n            - 从密文字符c计算原始位置值x:\n                - x=(z-y) mod 26\n            - 使用LETTERS列表返回对应位置x的字母\n            - 将其附加到解密明文", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n    - 输入:\n        - 明文: 大写字母字符串,不含标点和空格\n    - 输出:\n        - 密文: 大写字母字符串\n    - 准备:\n        - LETTERS = ['J', 'D', 'W', 'O', 'T', 'R', 'A', 'C', 'X', 'Q', 'M', 'F', 'Y', 'E', 'Z', 'G', 'U', 'K', 'P', 'V', 'B', 'S', 'H', 'N', 'L', 'I']\n        - 将每个字母与其在LETTERS中的位置关联(从0开始):\n            J->0, D->1, W->2, O->3, T->4, R->5, A->6, C->7, X->8, Q->9, M->10, F->11, Y->12, E->13, Z->14, G->15, U->16, K->17, P->18, V->19, B->20, S->21, H->22, N->23, L->24, I->25\n        - 初始卡牌序列:\n            - 54张卡牌的列表,包括52张花色牌和2张可区分的王牌(A王牌和B王牌)。花色牌按四种花色顺序编号1-52,王牌值为53和54。\n            - [9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 53, 26, 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 54, 46, 23, 31, 24, 14, 8, 33, 2, 49, 45, 21]\n        - 密钥流算法:\n            该算法通过移动卡牌生成密钥流值。算法是确定性的,意味着密钥流值仅取决于卡牌的初始顺序。卡牌组被视为循环数组,允许需要移到底部的卡牌绕到顶部。\n            \n            执行以下步骤生成密钥流的一个字符:\n            1. 找到A王牌并下移一位。如果是最后一张牌,则成为第二张牌。不能成为第一张牌。\n            2. 找到B王牌并下移两位。如果是倒数第二张牌,则绕到第二位。如果是最后一张牌,则成为第三张牌。不能成为第一张牌。\n            3. 进行\"三切\":用王牌作为边界将牌组分成三部分,然后交换顶部和底部。王牌本身及其之间的牌保持不变。\n            4. 进行\"计数切\":检查牌组底牌。如果是王牌(53/54),其值固定为53。从牌组顶部取出该数量的牌,插入到最后一张牌的上方。\n            5. 查看顶牌的值。同样,任何王牌计为53。计算该牌下方的位置数,使用该位置的牌值作为下一个密钥流值。如果计算出的牌是王牌,忽略它并重复密钥流算法。\n            6. 返回生成的密钥流值\n    - 加密步骤:\n        - cards=初始卡牌序列\n        - 对每个明文字符p:\n            - 使用字母表将p转换为对应的位置值x(从0开始)\n            - 使用初始卡牌序列为p生成密钥流值y:\n                - y, cards = 密钥流算法(cards)\n                - 该算法修改卡牌顺序,下次执行使用新顺序\n            - 当密钥流值y加到位置值x时,应用模26运算得到z:\n                - z=(y+x) % 26\n            - 使用LETTERS列表返回对应位置z的字母\n            - 将其附加到密文\n解密算法:\n解密规则:\n    - 输入:\n        - 密文: 大写字母字符串\n    - 输出:\n        - 明文: 大写字母字符串\n    - 准备:\n        - LETTERS = ['J', 'D', 'W', 'O', 'T', 'R', 'A', 'C', 'X', 'Q', 'M', 'F', 'Y', 'E', 'Z', 'G', 'U', 'K', 'P', 'V', 'B', 'S', 'H', 'N', 'L', 'I']\n        - 将每个字母与其在LETTERS中的位置关联(从0开始):\n            J->0, D->1, W->2, O->3, T->4, R->5, A->6, C->7, X->8, Q->9, M->10, F->11, Y->12, E->13, Z->14, G->15, U->16, K->17, P->18, V->19, B->20, S->21, H->22, N->23, L->24, I->25\n        - 初始卡牌序列(与加密相同)\n        - 密钥流算法(与加密相同)\n    - 解密步骤(与加密步骤完全相反):\n        - cards=初始卡牌序列\n        - 对每个密文字符c:\n            - 使用LETTERS将c转换为对应的位置值z(从0开始)\n            - 为c生成密钥流值y:\n                - y, cards = 密钥流算法(cards)\n                - 该算法修改卡牌顺序,下次执行使用新顺序\n            - 从密文字符c计算原始位置值x:\n                - x=(z-y) mod 26\n            - 使用LETTERS列表返回对应位置x的字母\n            - 将其附加到解密明文"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - LETTERS = ['J', 'D', 'W', 'O', 'T', 'R', 'A', 'C', 'X', 'Q', 'M', 'F', 'Y',\n    'E', 'Z', 'G', 'U', 'K', 'P', 'V', 'B', 'S', 'H', 'N', 'L', 'I']\n    - Associate each letter with its position in the LETTERS (starting from 0):\n        \n        J -> 0, D -> 1, W -> 2, O -> 3, T -> 4, R -> 5, A -> 6, C -> 7, X -> 8, Q -> 9,\n        M -> 10, F -> 11, Y -> 12, E -> 13, Z -> 14, G -> 15, U -> 16, K -> 17, P -> 18,\n        V -> 19, B -> 20, S -> 21, H -> 22, N -> 23, L -> 24, I -> 25\n        \n    - Initial sequence of cards:\n        - A list of 54 numbers, including a randomly shuffled deck consisting of 52 suited cards and two distinguishable jokers known as the A Joker and B Joker. Suited cards are valued sequentially across four suits: Clubs, Diamonds, Hearts, and Spades, with values ranging from 1 to 52, while the jokers are valued 53 and 54.\n        - [9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 53, 26, 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 54, 46, 23, 31, 24, 14, 8, 33, 2, 49, 45, 21]\n    - **Keystream Algorithm**\n        \n        This algorithm generates keystream values by moving cards within a deck. The keystream algorithm is *deterministic*, meaning keystream values depend solely on the initial order of the deck. The deck is treated as a circular array, allowing a card that needs to move below the bottom card to wrap around to the top (in other words, the first card follows the last card).\n        \n        For example, starting with:\n        9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 53, 26, 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 54, 46, 23, 31, 24, 14, 8, 33, 2, 49, 45, 21\n        \n        Perform the following steps to generate a character of the keystream:\n        \n        1. Locate card A and move it down by one position. If it's the last card, it becomes the second card. It cannot become the first card. The deck now looks like this:\n        9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 26, **53,** 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 54, 46, 23, 31, 24, 14, 8, 33, 2, 49, 45, 21\n        2. Locate card B and move it down by two positions. Note, if it's the second last card, it will wrap around to become the second card. If it's the last card, it will become the third card. It cannot become the first card. The deck now looks like this:\n        9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 26, **53,** 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 46, 23, **54,** 31, 24, 14, 8, 33, 2, 49, 45, 21\n        3. Perform a \"triple cut\": Divide the deck into three parts, using the jokers as boundaries, then swap the top and bottom parts. The jokers themselves and the cards between them remain unchanged.\n        31, 24, 14, 8, 33, 2, 49, 45, 21, **53,** 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 46, 23, **54,** 9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, 26\n        4. Perform a \"count cut\": Examine the bottom card of the deck. If it's a joker (53/54), its value remains fixed at 53. Take out that many cards from the top of the deck and insert them just above the last card of the deck.\n        29, 20, 51, 6, 7, 52, 34, 35, 5, 50, 9, 46, 23, **54,** 9, 25, 44, 38, 40, 22, 11, 36, 13, 39, 18, 42, 10, **31, 24, 14, 8, 33, 2, 49, 45, 21,** 53, 12, 1, 16, 3, 43, 37, 17, 30, 4, 28, 48, 27, 41, 32, 15, 47, 26\n        5. Now, look at the value of the top card. Similarly, any joker counts as 53. Calculate the number of positions below this card, and use that card's value as the next value in the keystream. If the calculated card is a joker, ignore it and repeat the keystream algorithm. In this example, the top card is 29, so the value of the 30th card (i.e., 14) determines the keystream value. (Note that no cards change position in this step; this step only determines the keystream value).\n        6. Return the resulting keystream value: 14\n- Encryption Steps:\n    - cards=Initial sequence of cards\n    - For each given plaintext character p:\n        - Use the alphabet to convert p to the corresponding positional value x. (starting from 0).\n        - Generate a keystream value y for p using the Initial sequence of cards:\n            - y, cards = Keystream Algorithm (cards)\n            - This algorithm modifies the order of the pile of cards, and the next execution then uses the new order.\n        - When the keystream value y is added to the position value x, the mod 26 operation is applied to obtain z:\n            - z=(y+x) % 26\n        - Use the LETTERS list to return the letter corresponding to position z.\n        - Append it to the ciphertext.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation:\n    - LETTERS = ['J', 'D', 'W', 'O', 'T', 'R', 'A', 'C', 'X', 'Q', 'M', 'F', 'Y',\n    'E', 'Z', 'G', 'U', 'K', 'P', 'V', 'B', 'S', 'H', 'N', 'L', 'I']\n    - Associate each letter with its position in the LETTERS (starting from 0):\n        \n        J -> 0, D -> 1, W -> 2, O -> 3, T -> 4, R -> 5, A -> 6, C -> 7, X -> 8, Q -> 9,\n        M -> 10, F -> 11, Y -> 12, E -> 13, Z -> 14, G -> 15, U -> 16, K -> 17, P -> 18,\n        V -> 19, B -> 20, S -> 21, H -> 22, N -> 23, L -> 24, I -> 25\n        \n    - Initial sequence of cards(Same as encryption)\n    - Keystream Algorithm(Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - cards=Initial sequence of cards\n    - For each ciphertext character c:\n        - Convert c to its corresponding positional value z using the LETTERS (starting from 0).\n        - Generate the keystream value y for c:\n            - y, cards = Keystream Algorithm (cards)\n            - This algorithm modifies the order of the pile of cards, and the next execution then uses the new order.\n        - Calculate the original positional value x from ciphertext character c:\n            - x=(z-y) mod 26\n        - Use the LETTERS list to return the letter corresponding to position x.\n        - Append it to the decrypted plaintext."]}
{"kor_rule_num": "17", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 不含标点和空格的字符串\n- 准备:\n    - 每行最大字符数: 5\n- 加密步骤:\n    - 行数从1开始计数\n    - 明文按特殊方式排列：奇数行从左到右写，偶数行从右到左写，每行最多五个字母\n        - 例如，对于明文\"LIDAHELLOWORLD\"，先从左到右写第一行为LIDAH，然后从右到左写第二行为WOLLE，然后从左到右写第三行为ORLD，写完的全部内容表示如下\n        LIDAH\n        WOLLE\n        ORLD\n    - 然后按列读取，每列从上到下读取，每读完一列加一个\"#\"，读出的内容即为最终密文\n        - 例如，上述写好的内容按列读取为LWO#IOR#DLL#ALD#HE#\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 不含标点和空格的字符串\n- 输出:\n    - 明文: 大写字母字符串，不含标点和空格\n- 准备:\n    - 行数: 5\n- 解密步骤(与加密步骤完全相反):\n    - 对密文中的每个字符，从上到下写入；如果遇到#，则切换到下一列继续写入，直到整个密文写完\n        - 例如，对于密文LWO#IOR#DLL#ALD#HE#，写出如下\n        LIDAH\n        WOLLE\n        ORLD\n    - 然后按照奇数行从左到右读，偶数行从右到左读的顺序依次读取，最终结果即为解密后的明文\n        - 例如，对于上述写好的内容，第一行从左到右读为LIDAH，第二行从右到左读为ELLOW，第三行从左到右读为ORLD，最终全部内容连接起来，解密明文为LIDAHELLOWORLD", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 不含标点和空格的字符串\n- 准备:\n    - 每行最大字符数: 5\n- 加密步骤:\n    - 行数从1开始计数\n    - 明文按特殊方式排列：奇数行从左到右写，偶数行从右到左写，每行最多五个字母\n        - 例如，对于明文\"LIDAHELLOWORLD\"，先从左到右写第一行为LIDAH，然后从右到左写第二行为WOLLE，然后从左到右写第三行为ORLD，写完的全部内容表示如下\n        LIDAH\n        WOLLE\n        ORLD\n    - 然后按列读取，每列从上到下读取，每读完一列加一个\"#\"，读出的内容即为最终密文\n        - 例如，上述写好的内容按列读取为LWO#IOR#DLL#ALD#HE#\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 不含标点和空格的字符串\n- 输出:\n    - 明文: 大写字母字符串，不含标点和空格\n- 准备:\n    - 行数: 5\n- 解密步骤(与加密步骤完全相反):\n    - 对密文中的每个字符，从上到下写入；如果遇到#，则切换到下一列继续写入，直到整个密文写完\n        - 例如，对于密文LWO#IOR#DLL#ALD#HE#，写出如下\n        LIDAH\n        WOLLE\n        ORLD\n    - 然后按照奇数行从左到右读，偶数行从右到左读的顺序依次读取，最终结果即为解密后的明文\n        - 例如，对于上述写好的内容，第一行从左到右读为LIDAH，第二行从右到左读为ELLOW，第三行从左到右读为ORLD，最终全部内容连接起来，解密明文为LIDAHELLOWORLD"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  A string without punctuation and spaces.\n- Preparation:\n    - Maximum number of characters per line: 5\n- Encryption Steps:\n    - Lines are counted from 1.\n    - The plaintext is arranged in a special way: an odd number of lines are written from left to right, and an even number of lines are written from right to left, with a maximum of five letters per line.\n        - For example, for the plaintext \"LIDAHELLOWORLD\", first write the first line, from left to right as LIDAH, and then write the second line, from right to left as WOLLE, and then write the third line, from left to right as ORLD, the entire content of the finished writing is expressed as follows\n        LIDAH\n        WOLLE\n        ORLD\n    - Then read by column, each column is read from the top down, each read a column plus a \"#\", read out the contents of the final ciphertext.\n        - For example, the above written content is read as LWO#IOR#DLL#ALD#HE# by column.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: A string without punctuation and spaces.\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - Number of lines: 5\n- Decryption Steps (exact opposite of encryption steps):\n    - For each character in the ciphertext, it is written from top to bottom; if it encounters #, it switches to the next column and continues writing until the entire ciphertext has been written.\n        - For example, for the ciphertext LWO#IOR#DLL#ALD#HE#,it is written as\n        LIDAH\n        WOLLE\n        ORLD\n    - Then according to the odd-numbered rows from left to right read, the even number of rows from right to left read the order of sequential reading, the final result is the decrypted plaintext.\n        - For example, for the above written content, the first line, read from left to right as LIDAH, the second line, read from right to left as ELLOW, the third line, read from left to right as ORLD, and ultimately the entire content connected, decrypted plaintext as LIDAHELLOWORLD."]}
{"kor_rule_num": "22", "rule": "请根据加密算法对明文进行加密\n加密规则:\n    - 输入:\n        - 明文: 大写字母和空格组成的字符串\n    - 输出:\n        - 密文: 表示加密数据的十六进制字符串(其中A-E需要大写)\n    - 准备:\n        - 固定密钥\n            - KEY = b'1234567890ABCDEF'\n        - S盒\n            - S_BOX = {\n            0x00: 0x0F, 0x01: 0x0A, 0x02: 0x07, 0x03: 0x05,\n            0x04: 0x09, 0x05: 0x03, 0x06: 0x0D, 0x07: 0x00,\n            0x08: 0x0E, 0x09: 0x08, 0x0A: 0x04, 0x0B: 0x06,\n            0x0C: 0x01, 0x0D: 0x02, 0x0E: 0x0B, 0x0F: 0x0C\n            }\n    - 加密步骤:\n        1. 填充: 如果明文长度不是8字节的倍数，用\\x00(空字符)填充使其长度成为8字节的倍数\n        2. 分块: 将填充后的明文分成8字节的块\n        3. 块加密:\n            - 转换为字节: 使用ASCII编码将每个块转换为字节\n            - 与密钥XOR: 字节块与固定密钥进行XOR运算\n            - 替换: 使用S盒替换每个字节的高4位和低4位并拼接\n            - 置换: 通过将每个字节左移1位进行简单置换\n            - 与密钥XOR: 置换后的字节块再次与固定密钥进行XOR运算\n        4. 十六进制编码: 将加密后的字节块转换为十六进制字符串\n        5. 拼接: 将所有加密块的十六进制字符串拼接形成最终密文", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n    - 输入:\n        - 明文: 大写字母和空格组成的字符串\n    - 输出:\n        - 密文: 表示加密数据的十六进制字符串(其中A-E需要大写)\n    - 准备:\n        - 固定密钥\n            - KEY = b'1234567890ABCDEF'\n        - S盒\n            - S_BOX = {\n            0x00: 0x0F, 0x01: 0x0A, 0x02: 0x07, 0x03: 0x05,\n            0x04: 0x09, 0x05: 0x03, 0x06: 0x0D, 0x07: 0x00,\n            0x08: 0x0E, 0x09: 0x08, 0x0A: 0x04, 0x0B: 0x06,\n            0x0C: 0x01, 0x0D: 0x02, 0x0E: 0x0B, 0x0F: 0x0C\n            }\n    - 加密步骤:\n        1. 填充: 如果明文长度不是8字节的倍数，用\\x00(空字符)填充使其长度成为8字节的倍数\n        2. 分块: 将填充后的明文分成8字节的块\n        3. 块加密:\n            - 转换为字节: 使用ASCII编码将每个块转换为字节\n            - 与密钥XOR: 字节块与固定密钥进行XOR运算\n            - 替换: 使用S盒替换每个字节的高4位和低4位并拼接\n            - 置换: 通过将每个字节左移1位进行简单置换\n            - 与密钥XOR: 置换后的字节块再次与固定密钥进行XOR运算\n        4. 十六进制编码: 将加密后的字节块转换为十六进制字符串\n        5. 拼接: 将所有加密块的十六进制字符串拼接形成最终密文"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: A string of uppercase letters and spaces.\n- Output:\n    - Ciphertext: A hexadecimal string representing the encrypted data (where A-E needs to be capitalised).\n- Preparation:\n    - Fixed key\n        - KEY = b'1234567890ABCDEF'\n    - S_BOX\n        - S_BOX = {\n        0x00: 0x0F, 0x01: 0x0A, 0x02: 0x07, 0x03: 0x05,\n        0x04: 0x09, 0x05: 0x03, 0x06: 0x0D, 0x07: 0x00,\n        0x08: 0x0E, 0x09: 0x08, 0x0A: 0x04, 0x0B: 0x06,\n        0x0C: 0x01, 0x0D: 0x02, 0x0E: 0x0B, 0x0F: 0x0C\n        }\n- Encryption Steps:\n    1. Padding: If the plaintext is not a multiple of 8 bytes, pad it with \\x00 (null character) to make its length a multiple of 8 bytes.\n    2. Block Splitting: Divide the padded plaintext into 8-byte blocks.\n    3. Block Encryption:\n        - Convert Block to Bytes: Convert each block to bytes using ASCII encoding.\n        - XOR with Key: Apply XOR between the byte block and the fixed key.\n        - Substitute:  Use the S_BOX Replacement Box to replace the high 4 bits and low 4 bits in each byte before stitching them together.\n        - Permute: Perform a simple permutation by rotating each byte left by 1 bit.\n        - XOR with Key: Apply XOR between the permuted byte block and the fixed key again.\n    4. Hexadecimal Encoding: Convert the encrypted byte blocks to a hexadecimal string.\n    5. Concatenate: Concatenate all the hexadecimal strings of the encrypted blocks to form the final ciphertext.\n\n"]}
{"kor_rule_num": "23", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 准备:\n    - e: 263\n    - n: 299\n- 加密步骤:\n    - 对明文中的每个字母p:\n        - 获取字母p对应的ASCII码的十进制数x\n        - 计算x^e mod n作为该字母的密文数字y，这里^表示乘法运算\n    - 最后，将所有y用逗号连接形成最终密文\n\n解密算法:\n\n解密规则:\n- 输入:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 输出:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 准备:\n    - e: 263\n    - n: 299\n- 解密步骤:\n    - 对密文中的每个数字c:\n        - 计算z = c^e mod n，这里^表示乘法运算\n        - 根据z的十进制值，使用ASCII码找到对应的字母作为明文字母p\n    - 最后，将所有p连接得到最终明文\n", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 输出:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 准备:\n    - e: 263\n    - n: 299\n- 加密步骤:\n    - 对明文中的每个字母p:\n        - 获取字母p对应的ASCII码的十进制数x\n        - 计算x^e mod n作为该字母的密文数字y，这里^表示乘法运算\n    - 最后，将所有y用逗号连接形成最终密文\n\n解密算法:\n\n解密规则:\n- 输入:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 输出:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格\n- 准备:\n    - e: 263\n    - n: 299\n- 解密步骤:\n    - 对密文中的每个数字c:\n        - 计算z = c^e mod n，这里^表示乘法运算\n        - 根据z的十进制值，使用ASCII码找到对应的字母作为明文字母p\n    - 最后，将所有p连接得到最终明文\n"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  A sequence of numbers separated by ,. For example, \"y1,y2,…\".\n- Preparation:\n    - e: 263\n    - n: 299\n- Encryption Steps:\n    - For each letter p in the plaintext:\n        - Get the decimal number x of the value corresponding to the ascii code of p.\n        - Compute x^e mod n as the ciphertext number y for that letter p . Here ^ denotes the multiplication operation.\n    - Finally, concatenate all the y's and separate them with commas for the final ciphertext.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: A sequence of numbers separated by ,. For example, \"y1,y2,…\".\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - e: 263\n    - n: 299\n- Decryption Steps:\n    - For each number c in the ciphertext:\n        - Calculate z = c^e mod n. Here ^ means multiplication.\n        Based on the decimal number represented by z, use the ascii code to find the corresponding letter as the plaintext letter p.\n    - Finally, concatenate all p's to get the final plaintext."]}
{"kor_rule_num": "13", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串,不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 5x5网格(不含字母J,行列坐标在0到4之间):\n        - U B I L A\n        N T C D E\n        F G H K M\n        O P Q R S\n        V W X Y Z\n- 加密步骤:\n    - 去除明文中的标点、空格和字母J\n    - 对明文中的每个字母,找到其在网格中对应的行列坐标(0-4)。例如A是(0,4)\n    - 将所有行列坐标重排,先读所有行坐标,再读所有列坐标形成新的坐标序列。例如原来是(0,4)(1,2),现在读作0142\n    - 每次从新坐标序列中取出两个数作为新的行列坐标,在网格中找到对应字母形成密文。例如对于0142,密文对应(0,1)是B,(4,2)是X。最终密文是BX\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 大写字母字符串,不含标点和空格\n- 输出:\n    - 明文: 大写字母字符串,不含标点和空格\n- 准备:\n    - 5x5网格(与加密相同)\n- 解密步骤(与加密步骤完全相反):\n    - 对密文中的每个字母,找到其在网格中对应的行列坐标(0-4)得到坐标序列\n    - 将坐标序列分成两半,前半部分为所有原始行坐标,后半部分为所有原始列坐标,从原始行坐标读一个,从原始列坐标读一个,根据原始行列坐标在网格中找到对应字母形成明文\n        - 例如[0,1,4,2],前半部分作为行坐标:[0,1],后半部分作为列坐标:[4,2]\n        - 交替读取行坐标和列坐标。得到(0,4),(1,2),分别在网格中找到对应字母为AC", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串,不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 5x5网格(不含字母J,行列坐标在0到4之间):\n        - U B I L A\n        N T C D E\n        F G H K M\n        O P Q R S\n        V W X Y Z\n- 加密步骤:\n    - 去除明文中的标点、空格和字母J\n    - 对明文中的每个字母,找到其在网格中对应的行列坐标(0-4)。例如A是(0,4)\n    - 将所有行列坐标重排,先读所有行坐标,再读所有列坐标形成新的坐标序列。例如原来是(0,4)(1,2),现在读作0142\n    - 每次从新坐标序列中取出两个数作为新的行列坐标,在网格中找到对应字母形成密文。例如对于0142,密文对应(0,1)是B,(4,2)是X。最终密文是BX\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 大写字母字符串,不含标点和空格\n- 输出:\n    - 明文: 大写字母字符串,不含标点和空格\n- 准备:\n    - 5x5网格(与加密相同)\n- 解密步骤(与加密步骤完全相反):\n    - 对密文中的每个字母,找到其在网格中对应的行列坐标(0-4)得到坐标序列\n    - 将坐标序列分成两半,前半部分为所有原始行坐标,后半部分为所有原始列坐标,从原始行坐标读一个,从原始列坐标读一个,根据原始行列坐标在网格中找到对应字母形成明文\n        - 例如[0,1,4,2],前半部分作为行坐标:[0,1],后半部分作为列坐标:[4,2]\n        - 交替读取行坐标和列坐标。得到(0,4),(1,2),分别在网格中找到对应字母为AC"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - 5x5 grid (There is no letter J.Its row and column coordinates are between 0 and 4.):\n        - U  B  I  L  A\n        N  T  C  D  E\n        F  G  H  K  M\n        O  P  Q  R  S\n        V  W  X  Y  Z\n- Encryption Steps:\n    - Remove punctuation, spaces, and the letter J from plaintext.\n    - For each letter p in the plaintext, find its corresponding row and column coordinates (between 0 and 4) in the grid. For example, A is (0,4).\n    - Arrange all row and column coordinates, read all row coordinates first, then read all column coordinates to form a new coordinate sequence. For example, the original has (0,4)(1,2), now read as 0142.\n    - Each time, two numbers are taken out from the new coordinate sequence as new row and column coordinates, and the corresponding letters are found in the grid to form the ciphertext. For example, for 0142, the ciphertext corresponding to (0,1) is B, and the ciphertext corresponding to (4,2) is X. The final ciphertext is BX.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - 5x5 grid (Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - For each letter c in the ciphertext, find its corresponding row and column coordinates (between 0 and 4) in the grid to obtain a sequence of coordinates.\n    - Divide the coordinate sequence into two halves, the first half is all the original row coordinates, the second half is all the original column coordinates, read one from the original row coordinates, read one from the original column coordinates, and find the corresponding letter in the grid according to the original row and column coordinates to form the plaintext.\n        - For example [0,1,4,2], the first half as row coordinates: [0, 1], the second half as column coordinates: [4,2].\n        - Read one from the row coordinates, one from the column coordinates, and so on alternately. Obtain (0,4),(1,2), respectively, and find the corresponding letters in the grid as AC."]}
{"kor_rule_num": "9", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n\n输入:\n- 明文: 大写字母字符串，不含标点和空格\n- period: 定义内圈多久旋转一次。周期性表示在加密过程中每处理指定数量的字符后，内圈将根据增量值旋转一次\n- increment: 定义内圈每次旋转的字符数。在每个周期结束时，内圈将根据增量值向右旋转相应数量的字符\n\n输出:\n- 密文: 大写字母字符串\n\n准备:\n- outer_disk = \"QWERTYUIOPASDFGHJZXCVBNMKL\"\n- inner_disk = \"JKLZXCVBNMASDFGHJQWERTYUIO\"\n\n加密步骤:\n- 对明文中的每个字符p:\n    - 在外圈找到该字符\n    - 用内圈对应位置的字符替换它\n    - 每加密period个字符后，将内圈向右旋转increment个字符。例如，将'ZXCVBNMASDFGHJKLQWERTYUIOP'旋转4位得到'BNMASDFGHJKLQWERTYUIOPZXCV'\n        \n解密算法:\n\n解密规则:\n\n输入:\n- 密文: 大写字母字符串\n- period (与加密相同)\n- increment (与加密相同)\n\n输出:\n- 明文: 大写字母字符串\n\n准备:\n- outer_disk = \"QWERTYUIOPASDFGHJZXCVBNMKL\"\n- inner_disk = \"JKLZXCVBNMASDFGHJQWERTYUIO\"\n\n解密步骤 (与加密步骤完全相反):\n- 对密文中的每个字符c:\n    - 在内圈找到该字符\n    - 用外圈对应位置的字符替换它\n    - 每解密period个字符后，将内圈向右旋转increment个字符。例如，将'ZXCVBNMASDFGHJKLQWERTYUIOP'旋转4位得到'BNMASDFGHJKLQWERTYUIOPZXCV'\n        ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n\n输入:\n- 明文: 大写字母字符串，不含标点和空格\n- period: 定义内圈多久旋转一次。周期性表示在加密过程中每处理指定数量的字符后，内圈将根据增量值旋转一次\n- increment: 定义内圈每次旋转的字符数。在每个周期结束时，内圈将根据增量值向右旋转相应数量的字符\n\n输出:\n- 密文: 大写字母字符串\n\n准备:\n- outer_disk = \"QWERTYUIOPASDFGHJZXCVBNMKL\"\n- inner_disk = \"JKLZXCVBNMASDFGHJQWERTYUIO\"\n\n加密步骤:\n- 对明文中的每个字符p:\n    - 在外圈找到该字符\n    - 用内圈对应位置的字符替换它\n    - 每加密period个字符后，将内圈向右旋转increment个字符。例如，将'ZXCVBNMASDFGHJKLQWERTYUIOP'旋转4位得到'BNMASDFGHJKLQWERTYUIOPZXCV'\n        \n解密算法:\n\n解密规则:\n\n输入:\n- 密文: 大写字母字符串\n- period (与加密相同)\n- increment (与加密相同)\n\n输出:\n- 明文: 大写字母字符串\n\n准备:\n- outer_disk = \"QWERTYUIOPASDFGHJZXCVBNMKL\"\n- inner_disk = \"JKLZXCVBNMASDFGHJQWERTYUIO\"\n\n解密步骤 (与加密步骤完全相反):\n- 对密文中的每个字符c:\n    - 在内圈找到该字符\n    - 用外圈对应位置的字符替换它\n    - 每解密period个字符后，将内圈向右旋转increment个字符。例如，将'ZXCVBNMASDFGHJKLQWERTYUIOP'旋转4位得到'BNMASDFGHJKLQWERTYUIOPZXCV'\n        "], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n    - period: Defines how often the inner disc rotates. Periodicity indicates that after every number of characters processed in the encryption process, the inner disc will rotate once according to the incremental value.\n    - increment: Defines the number of characters the inner disc rotates each time. At the end of each cycle, the inner disc will rotate to the right by the corresponding number of characters based on the increment value. For example, if the increment is 4, the inner disc will rotate 4 characters to the right for each cycle that passes (e.g., 5 characters are processed).\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - outer_disk = \"QWERTYUIOPASDFGHJZXCVBNMKL\"\n    - inner_disk = \"JKLZXCVBNMASDFGHJQWERTYUIO\"\n- Encryption Steps:\n    - For each character p in the plaintext:\n        - Find the character in the outer_disk.\n        - Replace it with the character at the corresponding position on the inner_disk.\n        - After encrypting every `period` characters, rotate the inner_disk to the right by `increment` characters.For example, rotating 'ZXCVBNMASDFGHJKLQWERTYUIOP' by 4 gives 'BNMASDFGHJKLQWERTYUIOPZXCV'.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string.\n    - period (Same as encryption)\n    - increment (Same as encryption)\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation:\n    - outer_disk = \"QWERTYUIOPASDFGHJZXCVBNMKL\"\n    - inner_disk = \"JKLZXCVBNMASDFGHJQWERTYUIO\"\n- Decryption Steps (exact opposite of encryption steps):\n    - For each character c in the ciphertext:\n        - Find the character in the inner_disk.\n        - Replace the character with the corresponding position in the outer_disk.\n        - After decrypting every `period` characters, rotate the inner_disk to the right by `increment` characters.For example, rotating 'ZXCVBNMASDFGHJKLQWERTYUIOP' by 4 gives 'BNMASDFGHJKLQWERTYUIOPZXCV'."]}
{"kor_rule_num": "13", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串,不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 5x5网格(不含字母J,行列坐标在0到4之间):\n        - U B I L A\n        N T C D E\n        F G H K M\n        O P Q R S\n        V W X Y Z\n- 加密步骤:\n    - 去除明文中的标点、空格和字母J\n    - 对明文中的每个字母,找到其在网格中对应的行列坐标(0-4)。例如A是(0,4)\n    - 将所有行列坐标重排,先读所有行坐标,再读所有列坐标形成新的坐标序列。例如原来是(0,4)(1,2),现在读作0142\n    - 每次从新坐标序列中取出两个数作为新的行列坐标,在网格中找到对应字母形成密文。例如对于0142,密文对应(0,1)是B,(4,2)是X。最终密文是BX", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串,不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 5x5网格(不含字母J,行列坐标在0到4之间):\n        - U B I L A\n        N T C D E\n        F G H K M\n        O P Q R S\n        V W X Y Z\n- 加密步骤:\n    - 去除明文中的标点、空格和字母J\n    - 对明文中的每个字母,找到其在网格中对应的行列坐标(0-4)。例如A是(0,4)\n    - 将所有行列坐标重排,先读所有行坐标,再读所有列坐标形成新的坐标序列。例如原来是(0,4)(1,2),现在读作0142\n    - 每次从新坐标序列中取出两个数作为新的行列坐标,在网格中找到对应字母形成密文。例如对于0142,密文对应(0,1)是B,(4,2)是X。最终密文是BX"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - 5x5 grid (There is no letter J.Its row and column coordinates are between 0 and 4.):\n        - U  B  I  L  A\n        N  T  C  D  E\n        F  G  H  K  M\n        O  P  Q  R  S\n        V  W  X  Y  Z\n- Encryption Steps:\n    - Remove punctuation, spaces, and the letter J from plaintext.\n    - For each letter p in the plaintext, find its corresponding row and column coordinates (between 0 and 4) in the grid. For example, A is (0,4).\n    - Arrange all row and column coordinates, read all row coordinates first, then read all column coordinates to form a new coordinate sequence. For example, the original has (0,4)(1,2), now read as 0142.\n    - Each time, two numbers are taken out from the new coordinate sequence as new row and column coordinates, and the corresponding letters are found in the grid to form the ciphertext. For example, for 0142, the ciphertext corresponding to (0,1) is B, and the ciphertext corresponding to (4,2) is X. The final ciphertext is BX.\n\n "]}
{"kor_rule_num": "24", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 准备:\n    - k_q_x值: 12\n- 加密步骤:\n    - 对明文中的每个字母p:\n        - 获取字母p对应的ASCII码值x\n        - 计算x * k_q_x作为该字母对应的密文数字y\n    - 最后将所有y值用逗号连接得到最终密文", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 由逗号分隔的数字序列，例如\"y1,y2,...\"\n- 准备:\n    - k_q_x值: 12\n- 加密步骤:\n    - 对明文中的每个字母p:\n        - 获取字母p对应的ASCII码值x\n        - 计算x * k_q_x作为该字母对应的密文数字y\n    - 最后将所有y值用逗号连接得到最终密文"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  A sequence of numbers separated by ,. For example, \"y1,y2,…\".\n- Preparation:\n    - k_q_x : 12\n- Encryption Steps:\n    - For each letter p in the plaintext:\n        - Get the decimal number x corresponding to the ascii code of p.\n        - Calculate x * k_q_x as the number y of ciphertexts for that letter p.\n    - Finally, concatenate all y's and separate them with commas to get the final ciphertext.\n\n "]}
{"kor_rule_num": "19", "rule": "请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 6x6矩阵 (矩阵中的行和列从0开始计数)\n        [['R', 'U', 'A', '0', 'Q', 'B'], \n        ['D', '2', 'W', 'K', 'S', '1'], \n        ['H', '4', '5', 'F', 'T', 'Z'], \n        ['Y', 'C', 'G', 'X', '7', 'L'], \n        ['9', '8', 'I', '3', 'P', 'N'], \n        ['6', 'J', 'V', 'O', 'E', 'M']]\n    - 加密字符集: \"ADFGVX\"\n- 加密步骤:\n    - 对明文中的每个字符:\n        - 在6X6矩阵中找到该字符的行数和列数。例如，A的行数为0，列数为2。\n        - 加密字符集中的字符位置标记为0-6。使用加密字符集中对应位置的字符替换行数和列数得到加密二元组。\n            - 例如，A的行数为0对应加密字符集中的A，列数为2对应加密字符集中的F，所以A的加密二元组为(A,F)。\n        - 读取所有加密二元组的行，然后读取所有加密二元组的列得到最终密文。\n            - 例如，加密二元组为(A,F)(X,V)，最后读取为AXFV，所以最终密文为AXFV。", "replace": ["请根据加密算法对明文进行加密\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 6x6矩阵 (矩阵中的行和列从0开始计数)\n        [['R', 'U', 'A', '0', 'Q', 'B'], \n        ['D', '2', 'W', 'K', 'S', '1'], \n        ['H', '4', '5', 'F', 'T', 'Z'], \n        ['Y', 'C', 'G', 'X', '7', 'L'], \n        ['9', '8', 'I', '3', 'P', 'N'], \n        ['6', 'J', 'V', 'O', 'E', 'M']]\n    - 加密字符集: \"ADFGVX\"\n- 加密步骤:\n    - 对明文中的每个字符:\n        - 在6X6矩阵中找到该字符的行数和列数。例如，A的行数为0，列数为2。\n        - 加密字符集中的字符位置标记为0-6。使用加密字符集中对应位置的字符替换行数和列数得到加密二元组。\n            - 例如，A的行数为0对应加密字符集中的A，列数为2对应加密字符集中的F，所以A的加密二元组为(A,F)。\n        - 读取所有加密二元组的行，然后读取所有加密二元组的列得到最终密文。\n            - 例如，加密二元组为(A,F)(X,V)，最后读取为AXFV，所以最终密文为AXFV。"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext:  Uppercase letters  string without punctuation and spaces.\n- Preparation:\n    - 6x6 Matrix (The rows and columns in the matrix are counted from 0.)\n        \n        [['R', 'U', 'A', '0', 'Q', 'B'], \n        ['D', '2', 'W', 'K', 'S', '1'], \n        ['H', '4', '5', 'F', 'T', 'Z'],\n        ['Y', 'C', 'G', 'X', '7', 'L'], \n        ['9', '8', 'I', '3', 'P', 'N'],\n        ['6', 'J', 'V', 'O', 'E', 'M']]\n        \n    - Encrypted Character Set\n        - \"ADFGVX\"\n- Encryption Steps:\n    - For each character in the plaintext:\n        - Find the number of rows and columns of that character in the 6X6 matrix. For example, A has 0 rows and 2 columns.\n        - The position of each character in the encrypted character set is flagged as 0-6. Use the character at the corresponding position in the encrypted character set to replace the number of rows and columns to get the encrypted binary.\n            - For example, the number of rows of A is 0, which corresponds to A in the encrypted character set, and the number of columns of A is 2, which corresponds to F in the encrypted character set. so the encrypted binary corresponding to A is (A,F).The encrypted binary is (A,F).\n        - Read all rows of the encrypted binary, and then read all columns of the encrypted binary to get the final ciphertext.\n            - For example, the encrypted binary is (A,F)(X,V), the last read is AXFV, so the final ciphertext is AXFV.\n\n "]}
{"kor_rule_num": "7", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 字母表 = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'(不包含字母J)\n    - 8个网格(Grid0-Grid7)\n- 加密步骤:\n    - 明文按5个字符分组，从0开始编号\n    - 对于5个字符的块:\n        - 使用的网格由grid_index = (i // 5) % 8确定，其中i是块号。整数除法运算符//将左边的数除以右边的数，向下取整结果\n        - 对于当前块中的每个字符:\n            - 如果字符是\"J\"，不加密直接添加到加密块\n            - 否则，在当前网格中找到字符的位置。然后向右下方移动一个网格位置(row+1,col+1)(如果越界则在对应边界的另一侧继续)，移动后位置的字母作为加密字母\n            - 将加密字母添加到加密块\n    - 处理完所有块后，连接加密块形成最终加密消息\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 大写字母字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - 字母表 = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'(不包含字母J)\n    - 8个网格(与加密相同)\n- 解密步骤:\n    - 将密文分成5个字符的块:\n        - 例如，如果密文是\"KHOORTQHQTHHSAUQ\"，第0块是\"KHOOR\"，第1块是\"TQHQH\"，以此类推(从0开始编号)\n    - 确定用于当前块的网格:\n        计算grid_index = (i // 5) % 8从网格列表中选择适当的网格。i是块号\n    - 对于块中的每个字符:\n        - 如果字符是\"J\": 直接将\"J\"添加到解密块，不进行解密\n        - 否则在网格中找到字符的位置，通过向左上方移动一格获得(如果越界则在对应边界的另一侧继续)，移动后位置的字母作为解密字母\n        - 将解密字母添加到解密块\n    - 处理完块中所有字符后，将解密块添加到解密消息列表。形成最终解密消息", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - 字母表 = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'(不包含字母J)\n    - 8个网格(Grid0-Grid7)\n- 加密步骤:\n    - 明文按5个字符分组，从0开始编号\n    - 对于5个字符的块:\n        - 使用的网格由grid_index = (i // 5) % 8确定，其中i是块号。整数除法运算符//将左边的数除以右边的数，向下取整结果\n        - 对于当前块中的每个字符:\n            - 如果字符是\"J\"，不加密直接添加到加密块\n            - 否则，在当前网格中找到字符的位置。然后向右下方移动一个网格位置(row+1,col+1)(如果越界则在对应边界的另一侧继续)，移动后位置的字母作为加密字母\n            - 将加密字母添加到加密块\n    - 处理完所有块后，连接加密块形成最终加密消息\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 大写字母字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - 字母表 = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'(不包含字母J)\n    - 8个网格(与加密相同)\n- 解密步骤:\n    - 将密文分成5个字符的块:\n        - 例如，如果密文是\"KHOORTQHQTHHSAUQ\"，第0块是\"KHOOR\"，第1块是\"TQHQH\"，以此类推(从0开始编号)\n    - 确定用于当前块的网格:\n        计算grid_index = (i // 5) % 8从网格列表中选择适当的网格。i是块号\n    - 对于块中的每个字符:\n        - 如果字符是\"J\": 直接将\"J\"添加到解密块，不进行解密\n        - 否则在网格中找到字符的位置，通过向左上方移动一格获得(如果越界则在对应边界的另一侧继续)，移动后位置的字母作为解密字母\n        - 将解密字母添加到解密块\n    - 处理完块中所有字符后，将解密块添加到解密消息列表。形成最终解密消息"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'(The letter J is excluded)\n    - 8 Grids:\n        \n        Grid0:\n        \n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        \n        Grid1:\n        \n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        \n        Grid2:\n        \n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        \n        Grid3:\n        \n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        \n        Grid4:\n        \n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        \n        Grid5:\n        \n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        \n        Grid6:\n        \n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        | O | Q | R | T | U |\n        \n        Grid7:\n        \n        | O | Q | R | T | U |\n        | V | W | X | Y | Z |\n        | P | H | I | L | S |\n        | A | B | C | D | E |\n        | F | G | K | M | N |\n        \n- Encryption Steps:\n    - The plaintext is grouped into blocks of 5 characters, numbered from 0.\n    - For blocks of 5 characters:\n        - To use the grid is determined by calculating grid_index = (i // 5) % 8, where i is the number. Integer division operator // divides the number on the left by the number on the right, rounding down the result. That is, it removes the fractional part and keeps only the integer part!This ensures that the grid is recycled.\n        - For each character in the current block:\n            - If the character is \"J\", it is not encrypted and is appended directly to the encrypted block.\n            - Otherwise, find the position of the character in the current grid. Then move one grid position to the lower right (row+1,col+1) (or continue on the opposite side of the corresponding boundary if it crosses the boundary), and get the letter at the position after the move as the encrypted letter.\n            - Add the encrypted letter to the encryption block.\n    - After processing all the blocks, connect the encrypted blocks to form the final encrypted message.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation:\n    - alphabet = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'(The letter J is excluded)\n    - 8 Grids (Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - Divide the ciphertext into 5-character blocks:\n        - For example, if the cipher text is \"KHOORTQHQTHHSAUQ\", the 0th block is \"KHOOR\", the 1st block is \"TQHQH\", and so on. (Numbering starts at 0)\n    - Determine the grid used for the current block:\n    Calculate grid_index = (i // 5) % 8 to select the appropriate grid from the grid list. i is the block number.\n    - For each character in the block:\n        - If the character is \"J\": add \"J\" directly to the decrypted block without decryption.\n        - Otherwise find the position of the character in the grid and obtain it by moving one grid to the upper left (or continue on the opposite side of the corresponding boundary if it crosses the boundary). the letter at the position after the move is used as the decrypted letter.\n        - Append the decrypted letter to the decryption block.\n    - After processing all characters in the block, append the decrypted block to the decrypted message list. Form the final decrypted message."]}
{"kor_rule_num": "4", "rule": "请根据加密算法对明文进行加密\n\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - Polybius方阵:\n    1  2  3  4  5\n1   R  T  X  F  S\n2   W  C  M  V  H\n3   Z  J  A  P  B\n4   L  Q  Y  G  K\n5   N  E  U  D  I\n\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 如果p是存在于Polybius方阵中的大写字母:\n            - 用字符在方阵中的行号和列号(都从1开始计数)替换该字符\n        - 特别地，字母O不存在于方阵中，用66替换\n    ", "replace": ["请根据加密算法对明文进行加密\n\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - Polybius方阵:\n    1  2  3  4  5\n1   R  T  X  F  S\n2   W  C  M  V  H\n3   Z  J  A  P  B\n4   L  Q  Y  G  K\n5   N  E  U  D  I\n\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 如果p是存在于Polybius方阵中的大写字母:\n            - 用字符在方阵中的行号和列号(都从1开始计数)替换该字符\n        - 特别地，字母O不存在于方阵中，用66替换\n    "], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - Polybius_square:\n```\n+----+----+----+----+----+\n|    | 1  | 2  | 3  | 4  | 5  |\n+----+----+----+----+----+\n| 1  | R  | T  | X  | F  | S  |\n| 2  | W  | C  | M  | V  | H  |\n| 3  | Z  | J  | A  | P  | B  |\n| 4  | L  | Q  | Y  | G  | K  |\n| 5  | N  | E  | U  | D  | I  |\n+----+----+----+----+----+\n```\n- Encryption Steps:\n    - For each given plaintext character p:\n        - If `p` is an uppercase letter and exists in the Polybius square:\n            - Replace `p` with the number of rows and columns (both counted from 1) in which the character appears.\n        - In particular, O, which does not exist in the Polybius square, is replaced by 66.\n\n "]}
{"kor_rule_num": "14", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 数字字符串，不含标点和空格\n- 准备:\n    - 3个网格(所有行列号从0开始计数):\n        - 网格1 (3x9):\n            Q W E R T Y U I O\n            P A S D F G H J K\n            L Z X C V B N M #\n        - 网格2 (9x3):\n            Q W E\n            R T Y\n            U I O\n            P A S\n            D F G\n            H J K\n            L Z X\n            C V B\n            N M #\n        - 网格3 (3x3):\n            1 2 3\n            4 5 6\n            7 8 9\n- 加密步骤:\n    - 移除所有空格和标点，将文本转换为大写字母\n    - 将明文切分为6个字符一组，如果最后一组不足6个字符，用#填充\n    - 将每组6个字符分成3个二元组\n    - 对每个二元组(L1, L2)执行以下操作:\n        - 确定L1在网格1中的行列号(l1_row, l1_col)\n        - 确定L2在网格2中的行列号(l2_row, l2_col)\n        - 在网格3中用l1_row和l2_col找到对应数字num3\n        - 输出三元组(l1_col, num3, l2_row)\n    - 将所有三元组连接成一个数字串作为加密信息\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 数字字符串，不含标点和空格\n- 输出:\n    - 明文: 大写字母字符串，不含标点和空格\n- 准备:\n    - 3个网格(与加密相同)\n- 解密步骤:\n    - 将密文分成三个数字一组\n    - 对每个三元组(x, y, z)执行以下操作:\n        - 在网格3中找到y的行号作为L1_row\n        - 在网格3中找到y的列号作为L2_col\n        - L1_col等于x，L2_row等于z\n        - 根据确定的(L1_row,L1_col)在网格1中找到对应字母p1\n        - 根据确定的(L2_row,L2_col)在网格2中找到对应字母p2\n        - p1p2为该三元组解密后的消息\n    - 将所有解密后的消息连接起来，移除末尾的#(这些字符是为使消息长度为6的倍数而添加的填充字符)，形成解密后的明文", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 数字字符串，不含标点和空格\n- 准备:\n    - 3个网格(所有行列号从0开始计数):\n        - 网格1 (3x9):\n            Q W E R T Y U I O\n            P A S D F G H J K\n            L Z X C V B N M #\n        - 网格2 (9x3):\n            Q W E\n            R T Y\n            U I O\n            P A S\n            D F G\n            H J K\n            L Z X\n            C V B\n            N M #\n        - 网格3 (3x3):\n            1 2 3\n            4 5 6\n            7 8 9\n- 加密步骤:\n    - 移除所有空格和标点，将文本转换为大写字母\n    - 将明文切分为6个字符一组，如果最后一组不足6个字符，用#填充\n    - 将每组6个字符分成3个二元组\n    - 对每个二元组(L1, L2)执行以下操作:\n        - 确定L1在网格1中的行列号(l1_row, l1_col)\n        - 确定L2在网格2中的行列号(l2_row, l2_col)\n        - 在网格3中用l1_row和l2_col找到对应数字num3\n        - 输出三元组(l1_col, num3, l2_row)\n    - 将所有三元组连接成一个数字串作为加密信息\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 数字字符串，不含标点和空格\n- 输出:\n    - 明文: 大写字母字符串，不含标点和空格\n- 准备:\n    - 3个网格(与加密相同)\n- 解密步骤:\n    - 将密文分成三个数字一组\n    - 对每个三元组(x, y, z)执行以下操作:\n        - 在网格3中找到y的行号作为L1_row\n        - 在网格3中找到y的列号作为L2_col\n        - L1_col等于x，L2_row等于z\n        - 根据确定的(L1_row,L1_col)在网格1中找到对应字母p1\n        - 根据确定的(L2_row,L2_col)在网格2中找到对应字母p2\n        - p1p2为该三元组解密后的消息\n    - 将所有解密后的消息连接起来，移除末尾的#(这些字符是为使消息长度为6的倍数而添加的填充字符)，形成解密后的明文"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: A numeric string without punctuation and spaces.\n- Preparation:\n    - 3 Girds(All row and column numbers are counted from 0.):\n        - Grid 1 (3x9):\n            \n            Q W E R T Y U I O\n            P A S D F G H J K\n            L Z X C V B N M #\n            \n        - Grid 2 (9x3):\n            \n            Q W E\n            R T Y\n            U I O\n            P A S\n            D F G\n            H J K\n            L Z X\n            C V B\n            N M #\n            \n        - Grid 3 (3x3):\n            \n            1 2 3\n            4 5 6\n            7 8 9\n            \n- Encryption Steps:\n    - Remove all spaces and punctuation from the plain text and convert them to capital letters.\n    - Cut the plaintext into groups of 6 characters, and if a group is less than 6 characters long, fill it with `#`.\n    - Split each group of 6 characters into 3 binary groups.\n    - For each binary group `(L1, L2)` do the following:\n        - Determine the row and column numbers  of `L1` in `grid1` as `(l1_row, l1_col)`.\n        - Determine the row and column numbers of `L2` in `grid2` as `(l2_row, l2_col)`.\n        - Find the corresponding number `num3` in `grid3` from `l1_row` and `l2_col`.\n        - Output the triple `(l1_col, num3, l2_row)` of the three numbers.\n            - For example, for the binary (T,H), the row and column numbers of T in `grid1` are (0,4), the row and column numbers of H in `grid2` are (5,0).\n            - Based on `l1_row` (0) and `l2_col`(0) , the corresponding number `num3` found in `grid3` is 1, and the final ternary is (4, 1, 5).\n    - After performing the previous step multiple times and converting all the binary groups to triples, read them in turn to form a string of numbers that can be used as encrypted information. For example (4, 1, 5), (2, 3, 3), (8, 1, 8), the final encrypted message is 415233818.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: A numeric string without punctuation and spaces.\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - 3 Girds (Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - Divide the ciphertext into triples of three numbers.\n    - For each ternary `(x, y, z)` do the following:\n        - Find the row number of y in Gird3 where the value of L1_row is equal to the row number;\n        - Find the column number of y in Gird3, with the value of L2_col equal to that column number;\n        - The value of L1_col is equal to x, the value of L2_row is equal to z.\n        - Find the corresponding letter p1 in Gird1 according to the determined (L1_row,L1_col).\n        - Based on the determined (L2_row,L2_col), find the corresponding letter p2 in Gird2.\n        - p1p2 is the decrypted message of the triad.\n        - For example, for the ternary (4,1,5), in Gird3, the row number corresponding to 1 is 0, so L1_row=0, in Gird3, the column number corresponding to 1 is 0, so L2_col=0. L1_col=4, L2_row=5. According to (0,4) in Gird1, we find the corresponding letter T, and according to (5,0) in Gird2, we decrypt all the ternaries to get the letter p2 p1p2 as the message after decrypting the ternary. We find the corresponding letter H in Gird2 according to (5,0), so the final decryption is TH.\n    - String all the decrypted messages together, remove the `#` at the end (these characters are padding characters added to make the message length a multiple of 6), to form the decrypted plaintext."]}
{"kor_rule_num": "15", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 5x5网格(所有行和列号从0开始计数):\n        - M Z S D P\n        K N F L Q\n        G A O X U\n        W R Y V C\n        B T E H I\n        - 位于所有行第一个字母的MKGWB是行首字母\n        - 位于所有列最后一个字母的PQUCL是列尾字母\n- 加密步骤:\n    - 移除明文中的空格、标点和字母J，并将所有字母转换为大写\n    - 对明文中的每个字母p:\n        - 在网格中找到字母p的位置，然后找到相应的行首和列尾字符\n        - 将行首和列尾字符连接成二元组作为该字母p的加密消息\n        - 例如，如果字母p是H，它在第4行，行首字符是B；它在第3列，列尾字符是H，所以加密消息是BH\n    \n    连接所有加密消息作为最终密文输出\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 明文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 5x5网格(与加密相同)\n- 解密步骤(与加密步骤完全相反):\n    - 每次从密文中取两个字母c1,c2\n        - 字母c1标识解密字母p在网格中的行位置，找到c1作为行首的行\n        - 字母c2标识解密字母p在网格中的列位置，找到c2在列底的列\n        - 在网格中找到这个行列位置的字母，即为c1,c2的解密消息p\n        - 例如，如果c1,c2=BH，B是行首的行是第4行，H是行底的行是第2列，(4,2)处的字母是H，所以BH解密为H\n    - 两个两个地解密密文中的字母，并将解密消息连接起来作为最终明文输出", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 密文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 5x5网格(所有行和列号从0开始计数):\n        - M Z S D P\n        K N F L Q\n        G A O X U\n        W R Y V C\n        B T E H I\n        - 位于所有行第一个字母的MKGWB是行首字母\n        - 位于所有列最后一个字母的PQUCL是列尾字母\n- 加密步骤:\n    - 移除明文中的空格、标点和字母J，并将所有字母转换为大写\n    - 对明文中的每个字母p:\n        - 在网格中找到字母p的位置，然后找到相应的行首和列尾字符\n        - 将行首和列尾字符连接成二元组作为该字母p的加密消息\n        - 例如，如果字母p是H，它在第4行，行首字符是B；它在第3列，列尾字符是H，所以加密消息是BH\n    \n    连接所有加密消息作为最终密文输出\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 不含标点和空格的大写字母字符串\n- 输出:\n    - 明文: 不含标点和空格的大写字母字符串\n- 准备:\n    - 5x5网格(与加密相同)\n- 解密步骤(与加密步骤完全相反):\n    - 每次从密文中取两个字母c1,c2\n        - 字母c1标识解密字母p在网格中的行位置，找到c1作为行首的行\n        - 字母c2标识解密字母p在网格中的列位置，找到c2在列底的列\n        - 在网格中找到这个行列位置的字母，即为c1,c2的解密消息p\n        - 例如，如果c1,c2=BH，B是行首的行是第4行，H是行底的行是第2列，(4,2)处的字母是H，所以BH解密为H\n    - 两个两个地解密密文中的字母，并将解密消息连接起来作为最终明文输出"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - 5x5 Gird(All row and column numbers are counted from 0.):\n        - M Z S D P\n        K N F L Q\n        G A O X U\n        W R Y V C\n        B T E H I\n        - Located at the first letter of all rows, MKGWB is the row header letter.\n        - Located at the last letter of all columns, BTEHI is the bottom column letter.\n- Encryption Steps:\n    - Remove spaces and punctuation and the letter J from plain text and convert all letters to uppercase.\n    - For each letter p in the plaintext.\n        - Find the position of the letter p in the grid, and then find the corresponding row header and column footer characters accordingly.\n        - Concatenate the row-header and column-bottom characters into a binary as the encrypted message for that letter p.\n        - For example, if the letter p is H, it is in the 4th row, and the row header character is B; it is in the 3rd column, and the column bottom character is H, so the encrypted message is BH.\n    \n    Concatenate all the encrypted messages for the final ciphertext output.\n    \n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Preparation:\n    - 5x5 Gird (Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - Take two letters c1,c2 at a time from the ciphertext.\n        - The letter c1 identifies the row position of the decrypted letter p in the grid, find the row where c1 is the row header.\n        - The letter c2 identifies the column position of the decrypted letter p in the grid, and finds the row with c2 at the bottom of the column.\n        - Find the letter at this row and column position in the grid, which is the c1,c2 decrypted message p.\n        - For example, if c1,c2=BH, B is the header of the row is the 4th row, H is the bottom of the row is the 2nd column, (4,2) at the letter H, so BH decrypted to H.\n    - Decrypt the letters in the ciphertext two by two, and output the connected decrypted message as the final plaintext."]}
{"kor_rule_num": "11", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n以下是经过整理后的文字：\n\n---\n\n### 5x5 网格布局\n\n共有四个5x5的字符网格，每个网格代表了不同的排列方式。\n\n1. **网格1 原始网格**\n\n这是最初的字符排列，按照特定顺序组织如下：\n\n```\nK L M N O\nP R S T U\nV W X Y Z\nA B C D E\nF G H I J\n```\n\n2. **网格2 ECHO 网格**\n\n该网格根据\"ECHO\"这个词进行了重新排列：\n\n```\nE C H O A\nB D F G I\nJ K L M N\nP R S T U\nV W X Y Z\n```\n\n3. **网格3 VORTEX 网格**\n\n此网格基于\"VORTEX\"一词进行了独特的字符重组：\n\n```\nV O R T E\nX A B C D\nF G H I J\nK L M N P\nS U W Y Z\n```\n\n4. **网格4 重复原始网格**\n\n最后一个网格与第一个原始网格完全相同，没有进行任何改变：\n\n```\nK L M N O\nP R S T U\nV W X Y Z\nA B C D E\nF G H I J\n```\n\n每个网格展示了不同主题词下字符的独特排列。\n- 加密步骤:\n    - 清理明文，移除空格和非字母字符，移除字母Q，转换为大写\n    - 如果明文长度为奇数，添加字母'X'使其成为偶数\n    - 将处理后的明文分成两个字母一组\n    - 对于每组两个字母p1,p2:\n        - 在网格1和网格4中找到第一个字母和第二个字母的位置\n        - 在网格2和网格3中找到这两个位置对应的字母，用这两个字母作为该组的加密结果\n    - 连接所有加密后的字母组形成最终密文\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 大写字母字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - 四个5x5网格(与加密相同)\n- 解密步骤(与加密步骤相反):\n    - 清理密文，移除空格和非字母字符，转换为大写\n    - 将处理后的密文分成两个字母一组\n    - 对于每组两个字母c1,c2:\n        - 在网格2和网格3中找到第一个字母和第二个字母的位置\n        - 在网格1和网格4中找到这两个位置对应的字母，用这两个字母作为该组的解密结果\n    - 连接所有解密后的字母组形成最终明文", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n以下是经过整理后的文字：\n\n---\n\n### 5x5 网格布局\n\n共有四个5x5的字符网格，每个网格代表了不同的排列方式。\n\n1. **网格1 原始网格**\n\n这是最初的字符排列，按照特定顺序组织如下：\n\n```\nK L M N O\nP R S T U\nV W X Y Z\nA B C D E\nF G H I J\n```\n\n2. **网格2 ECHO 网格**\n\n该网格根据\"ECHO\"这个词进行了重新排列：\n\n```\nE C H O A\nB D F G I\nJ K L M N\nP R S T U\nV W X Y Z\n```\n\n3. **网格3 VORTEX 网格**\n\n此网格基于\"VORTEX\"一词进行了独特的字符重组：\n\n```\nV O R T E\nX A B C D\nF G H I J\nK L M N P\nS U W Y Z\n```\n\n4. **网格4 重复原始网格**\n\n最后一个网格与第一个原始网格完全相同，没有进行任何改变：\n\n```\nK L M N O\nP R S T U\nV W X Y Z\nA B C D E\nF G H I J\n```\n\n每个网格展示了不同主题词下字符的独特排列。\n- 加密步骤:\n    - 清理明文，移除空格和非字母字符，移除字母Q，转换为大写\n    - 如果明文长度为奇数，添加字母'X'使其成为偶数\n    - 将处理后的明文分成两个字母一组\n    - 对于每组两个字母p1,p2:\n        - 在网格1和网格4中找到第一个字母和第二个字母的位置\n        - 在网格2和网格3中找到这两个位置对应的字母，用这两个字母作为该组的加密结果\n    - 连接所有加密后的字母组形成最终密文\n解密算法:\n解密规则:\n- 输入:\n    - 密文: 大写字母字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - 四个5x5网格(与加密相同)\n- 解密步骤(与加密步骤相反):\n    - 清理密文，移除空格和非字母字符，转换为大写\n    - 将处理后的密文分成两个字母一组\n    - 对于每组两个字母c1,c2:\n        - 在网格2和网格3中找到第一个字母和第二个字母的位置\n        - 在网格1和网格4中找到这两个位置对应的字母，用这两个字母作为该组的解密结果\n    - 连接所有解密后的字母组形成最终明文"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - Four 5x5 Girds\n        - Gird1\n            - K  L  M  N  O\n            P  R  S  T  U\n            V  W  X  Y  Z\n            A  B  C  D  E\n            F  G  H  I  J\n        - Gird2\n            - E  C  H  O  A\n            B  D  F  G  I\n            J  K  L  M  N\n            P  R  S  T  U\n            V  W  X  Y  Z\n        - Gird3\n            - V  O  R  T  E\n            X  A  B  C  D\n            F  G  H  I  J\n            K  L  M  N  P\n            S  U  W  Y  Z\n        - Gird4\n            - K  L  M  N  O\n            P  R  S  T  U\n            V  W  X  Y  Z\n            A  B  C  D  E\n            F  G  H  I  J\n- Encryption Steps:\n    - Cleans up plaintext, removing spaces and non-alphabetic characters, removing the letter Q, and converting all letters to uppercase.\n    - If the plaintext is of odd length, add a letter 'X' to make it of even length.\n    - Split the cleaned plaintext into two-letter groups.\n    - For each double-letter group p1,p2 of the plaintext:\n        - In Gird1 and Gird4, find the position of the first letter and the second letter.\n        - In Gird2 and Gird3, find the letters corresponding to these two positions, use these two letters as the result of encrypting the double letter combination.\n    - Concatenate all the encrypted double letter groups to form the final ciphertext.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: Uppercase letters string.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation:\n    - Four 5x5 Girds (Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - Cleans up ciphertext, removing spaces and non-alphabetic characters, and converting all letters to uppercase.\n    - Split the cleaned ciphertext into two-letter groups.\n    - For each double-letter group c1,c2 of the ciphertext:\n        - In Gird2 and Gird3, find the position of the first letter and the second letter.\n        - In Gird1 and Gird4, find the letters corresponding to these two positions, use these two letters as the result of decrypting the double letter combination.\n    - Concatenate all the decrypted double letter groups to form the final plaintext."]}
{"kor_rule_num": "12", "rule": "请根据加密算法对明文进行加密\n\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 字符串\n- 准备:\n    - 数字索引映射表\n        - '..' : 5\n        - '.-' : 4\n        - './' : 9\n        - '-.' : 8\n        - '--' : 6\n        - '-/' : 7\n        - '/.' : 3\n        - '/-' : 1\n        - '//' : 2\n    - 摩斯密码表\n        - A: '.-',     B: '-...',   C: '-.-.',   D: '-..',\n        - E: '.',      F: '..-.',   G: '--.',    H: '....',\n        - I: '..',     J: '.---',   K: '-.-',    L: '.-..',\n        - M: '--',     N: '-.',     O: '---',    P: '.--.',\n        - Q: '--.-',   R: '.-.',    S: '...',    T: '-',\n        - U: '..-',    V: '...-',   W: '.--',    X: '-..-',\n        - Y: '-.--',   Z: '--..'\n- 加密步骤:\n    - 根据摩斯密码表将明文中的每个字符转换为摩斯密码，用/分隔每个字符，例如AB对应'.-/-...'\n    - 将摩斯密码分成两个字符一组。如果摩斯密码长度为奇数，最后一个字符不进行映射，直接添加到密文末尾\n    - 根据数字索引映射表将每组字符转换为对应的数字字符串\n    - 加密后的消息用字符串表示\n", "replace": ["请根据加密算法对明文进行加密\n\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 字符串\n- 准备:\n    - 数字索引映射表\n        - '..' : 5\n        - '.-' : 4\n        - './' : 9\n        - '-.' : 8\n        - '--' : 6\n        - '-/' : 7\n        - '/.' : 3\n        - '/-' : 1\n        - '//' : 2\n    - 摩斯密码表\n        - A: '.-',     B: '-...',   C: '-.-.',   D: '-..',\n        - E: '.',      F: '..-.',   G: '--.',    H: '....',\n        - I: '..',     J: '.---',   K: '-.-',    L: '.-..',\n        - M: '--',     N: '-.',     O: '---',    P: '.--.',\n        - Q: '--.-',   R: '.-.',    S: '...',    T: '-',\n        - U: '..-',    V: '...-',   W: '.--',    X: '-..-',\n        - Y: '-.--',   Z: '--..'\n- 加密步骤:\n    - 根据摩斯密码表将明文中的每个字符转换为摩斯密码，用/分隔每个字符，例如AB对应'.-/-...'\n    - 将摩斯密码分成两个字符一组。如果摩斯密码长度为奇数，最后一个字符不进行映射，直接添加到密文末尾\n    - 根据数字索引映射表将每组字符转换为对应的数字字符串\n    - 加密后的消息用字符串表示\n"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: A string.\n- Preparation:\n    - Numerical-Index Mapping Table\n        - '..' : 5\n        - '.-' : 4\n        - './' : 9\n        - '-.' : 8\n        - '--' : 6\n        - '-/' : 7\n        - '/.' : 3\n        - '/-' : 1\n        - '//' : 2\n    - morse_code Table\n        - morse_code = {\n                'A': '.-',     'B': '-...',   'C': '-.-.',   'D': '-..',\n                'E': '.',      'F': '..-.',   'G': '--.',    'H': '....',\n                'I': '..',     'J': '.---',   'K': '-.-',    'L': '.-..',\n                'M': '--',     'N': '-.',     'O': '---',    'P': '.--.',\n                'Q': '--.-',   'R': '.-.',    'S': '...',    'T': '-',\n                'U': '..-',    'V': '...-',   'W': '.--',    'X': '-..-',\n                'Y': '-.--',   'Z': '--..',\n            }\n- Encryption Steps:\n    - Convert each character in the plaintext into Morse code according to the morse_code Table, with each character separated by a /, e.g., the Morse code corresponding to AB is '.-/-...'.\n    - Divide Morse code into two pairs of characters. If the length of the Morse code is odd, the last character, without the following mapping, is finally added to the end of the ciphertext.\n    - Each pair of characters is converted into a corresponding numeric string according to the numeric index mapping table.\n    - The encrypted message is represented by a string.\n\n "]}
{"kor_rule_num": "4", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - Polybius方阵:\n    1  2  3  4  5\n1   R  T  X  F  S\n2   W  C  M  V  H\n3   Z  J  A  P  B\n4   L  Q  Y  G  K\n5   N  E  U  D  I\n\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 如果p是存在于Polybius方阵中的大写字母:\n            - 用字符在方阵中的行号和列号(都从1开始计数)替换该字符\n        - 特别地，字母O不存在于方阵中，用66替换\n    \n解密算法:\n\n解密规则:\n- 输入:\n    - 密文: 字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - Polybius方阵(与加密相同)\n- 解密步骤(与加密步骤相反):\n    - 对于密文中的每对数字CrCc:\n        - 根据CrCc表示的行列号在Polybius方阵中找到对应字母\n        - 如果CrCc=66，替换为\"O\"\n    ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n加密规则:\n- 输入:\n    - 明文: 大写字母字符串，不含标点和空格\n- 输出:\n    - 密文: 大写字母字符串\n- 准备:\n    - Polybius方阵:\n    1  2  3  4  5\n1   R  T  X  F  S\n2   W  C  M  V  H\n3   Z  J  A  P  B\n4   L  Q  Y  G  K\n5   N  E  U  D  I\n\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 如果p是存在于Polybius方阵中的大写字母:\n            - 用字符在方阵中的行号和列号(都从1开始计数)替换该字符\n        - 特别地，字母O不存在于方阵中，用66替换\n    \n解密算法:\n\n解密规则:\n- 输入:\n    - 密文: 字符串\n- 输出:\n    - 明文: 大写字母字符串\n- 准备:\n    - Polybius方阵(与加密相同)\n- 解密步骤(与加密步骤相反):\n    - 对于密文中的每对数字CrCc:\n        - 根据CrCc表示的行列号在Polybius方阵中找到对应字母\n        - 如果CrCc=66，替换为\"O\"\n    "], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: Uppercase letters string.\n- Preparation:\n    - Polybius_square:\n```\n+----+----+----+----+----+\n|    | 1  | 2  | 3  | 4  | 5  |\n+----+----+----+----+----+\n| 1  | R  | T  | X  | F  | S  |\n| 2  | W  | C  | M  | V  | H  |\n| 3  | Z  | J  | A  | P  | B  |\n| 4  | L  | Q  | Y  | G  | K  |\n| 5  | N  | E  | U  | D  | I  |\n+----+----+----+----+----+\n```\n- Encryption Steps:\n    - For each given plaintext character p:\n        - If `p` is an uppercase letter and exists in the Polybius square:\n            - Replace `p` with the number of rows and columns (both counted from 1) in which the character appears.\n        - In particular, O, which does not exist in the Polybius square, is replaced by 66.\n\n **Decryption Rules:**\n\n- Input:\n    - Ciphertext: A string.\n- Output:\n    - Plaintext: Uppercase letters string.\n- Preparation: Polybius_square (Same as encryption)\n- Decryption Steps (exact opposite of encryption steps):\n    - For each of the two numbers CrCc in the given ciphertext.\n        - Based on the rows and columns denoted by CrCc, find the corresponding letters in the Polybius square grid.\n        - If CrCc=66, replace with \"O\"."]}
{"kor_rule_num": "3", "rule": "请根据加密算法对明文进行加密\n\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格。\n- 输出:\n    - 密文: 不含标点的字符串。\n- 准备:\n    - 多击编码表\n        | 字母 | 多击编码 |\n        | A | 2^1 |\n        | B | 2^2 |\n        | C | 2^3 |\n        | D | 3^1 |\n        | E | 3^2 |\n        | F | 3^3 |\n        | G | 4^1 |\n        | H | 4^2 |\n        | I | 4^3 |\n        | J | 5^1 |\n        | K | 5^2 |\n        | L | 5^3 |\n        | M | 6^1 |\n        | N | 6^2 |\n        | O | 6^3 |\n        | P | 7^1 |\n        | Q | 7^2 |\n        | R | 7^3 |\n        | S | 7^4 |\n        | T | 8^1 |\n        | U | 8^2 |\n        | V | 8^3 |\n        | W | 9^1 |\n        | X | 9^2 |\n        | Y | 9^3 |\n        | Z | 9^4 |\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 如果p是大写字母且存在于多击编码表中:\n            - 用多击编码表中对应的多击编码替换p。\n", "replace": ["请根据加密算法对明文进行加密\n\n加密规则:\n- 输入:\n    - 明文: 仅包含大写字母的字符串，不含标点和空格。\n- 输出:\n    - 密文: 不含标点的字符串。\n- 准备:\n    - 多击编码表\n        | 字母 | 多击编码 |\n        | A | 2^1 |\n        | B | 2^2 |\n        | C | 2^3 |\n        | D | 3^1 |\n        | E | 3^2 |\n        | F | 3^3 |\n        | G | 4^1 |\n        | H | 4^2 |\n        | I | 4^3 |\n        | J | 5^1 |\n        | K | 5^2 |\n        | L | 5^3 |\n        | M | 6^1 |\n        | N | 6^2 |\n        | O | 6^3 |\n        | P | 7^1 |\n        | Q | 7^2 |\n        | R | 7^3 |\n        | S | 7^4 |\n        | T | 8^1 |\n        | U | 8^2 |\n        | V | 8^3 |\n        | W | 9^1 |\n        | X | 9^2 |\n        | Y | 9^3 |\n        | Z | 9^4 |\n- 加密步骤:\n    - 对于每个明文字符p:\n        - 如果p是大写字母且存在于多击编码表中:\n            - 用多击编码表中对应的多击编码替换p。\n"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: Uppercase letters string without punctuation and spaces.\n- Output:\n    - Ciphertext: A string without punctuation.\n- Preparation:\n    - Multitap Code Table\n        | Letter | Multitap Code |\n        | --- | --- |\n        | A | 2^1 |\n        | B | 2^2 |\n        | C | 2^3 |\n        | D | 3^1 |\n        | E | 3^2 |\n        | F | 3^3 |\n        | G | 4^1 |\n        | H | 4^2 |\n        | I | 4^3 |\n        | J | 5^1 |\n        | K | 5^2 |\n        | L | 5^3 |\n        | M | 6^1 |\n        | N | 6^2 |\n        | O | 6^3 |\n        | P | 7^1 |\n        | Q | 7^2 |\n        | R | 7^3 |\n        | S | 7^4 |\n        | T | 8^1 |\n        | U | 8^2 |\n        | V | 8^3 |\n        | W | 9^1 |\n        | X | 9^2 |\n        | Y | 9^3 |\n        | Z | 9^4 |\n- Encryption Steps:\n    - For each given plaintext character p:\n        - If `p` is an uppercase letter and exists in the Multitap Code Table:\n            - Replace `p` with the corresponding Multitap Code from the Multitap Code Table.\n\n "]}
{"kor_rule_num": "22", "rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n    - 输入:\n        - 明文: 大写字母和空格组成的字符串\n    - 输出:\n        - 密文: 表示加密数据的十六进制字符串(其中A-E需要大写)\n    - 准备:\n        - 固定密钥\n            - KEY = b'1234567890ABCDEF'\n        - S盒\n            - S_BOX = {\n            0x00: 0x0F, 0x01: 0x0A, 0x02: 0x07, 0x03: 0x05,\n            0x04: 0x09, 0x05: 0x03, 0x06: 0x0D, 0x07: 0x00,\n            0x08: 0x0E, 0x09: 0x08, 0x0A: 0x04, 0x0B: 0x06,\n            0x0C: 0x01, 0x0D: 0x02, 0x0E: 0x0B, 0x0F: 0x0C\n            }\n    - 加密步骤:\n        1. 填充: 如果明文长度不是8字节的倍数，用\\x00(空字符)填充使其长度成为8字节的倍数\n        2. 分块: 将填充后的明文分成8字节的块\n        3. 块加密:\n            - 转换为字节: 使用ASCII编码将每个块转换为字节\n            - 与密钥XOR: 字节块与固定密钥进行XOR运算\n            - 替换: 使用S盒替换每个字节的高4位和低4位并拼接\n            - 置换: 通过将每个字节左移1位进行简单置换\n            - 与密钥XOR: 置换后的字节块再次与固定密钥进行XOR运算\n        4. 十六进制编码: 将加密后的字节块转换为十六进制字符串\n        5. 拼接: 将所有加密块的十六进制字符串拼接形成最终密文\n解密算法:\n解密规则:\n    - 输入:\n        - 密文: 表示加密数据的十六进制字符串(其中A-E需要大写)\n    - 输出:\n        - 明文: 大写字母和空格组成的字符串\n    - 准备:\n        - 固定密钥\n            - KEY = b'1234567890ABCDEF'\n        - 逆S盒\n            - INV_S_BOX = {\n            0x0F: 0x00, 0x0A: 0x01, 0x07: 0x02, 0x05: 0x03,\n            0x09: 0x04, 0x03: 0x05, 0x0D: 0x06, 0x00: 0x07,\n            0x0E: 0x08, 0x08: 0x09, 0x04: 0x0A, 0x06: 0x0B,\n            0x01: 0x0C, 0x02: 0x0D, 0x0B: 0x0E, 0x0C: 0x0F\n            }\n    - 解密步骤:\n        1. 分块: 将密文分成16字符(8字节)的块\n        2. 块解密:\n            - 转换为字节: 将每个块从十六进制字符串转换为字节\n            - 与密钥XOR: 字节块与固定密钥进行XOR运算\n            - 逆置换: 通过将每个字节右移1位进行逆置换\n            - 替换: 使用逆S盒替换块中字节的高4位和低4位并拼接\n            - 与密钥XOR: 字节块再次与固定密钥进行XOR运算\n        3. 转换为文本: 使用ASCII解码将解密后的字节块转换回文本\n        4. 移除填充: 从解密后的明文末尾移除填充字符(\\x00)\n        5. 拼接: 将所有解密块拼接形成最终明文", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则:\n    - 输入:\n        - 明文: 大写字母和空格组成的字符串\n    - 输出:\n        - 密文: 表示加密数据的十六进制字符串(其中A-E需要大写)\n    - 准备:\n        - 固定密钥\n            - KEY = b'1234567890ABCDEF'\n        - S盒\n            - S_BOX = {\n            0x00: 0x0F, 0x01: 0x0A, 0x02: 0x07, 0x03: 0x05,\n            0x04: 0x09, 0x05: 0x03, 0x06: 0x0D, 0x07: 0x00,\n            0x08: 0x0E, 0x09: 0x08, 0x0A: 0x04, 0x0B: 0x06,\n            0x0C: 0x01, 0x0D: 0x02, 0x0E: 0x0B, 0x0F: 0x0C\n            }\n    - 加密步骤:\n        1. 填充: 如果明文长度不是8字节的倍数，用\\x00(空字符)填充使其长度成为8字节的倍数\n        2. 分块: 将填充后的明文分成8字节的块\n        3. 块加密:\n            - 转换为字节: 使用ASCII编码将每个块转换为字节\n            - 与密钥XOR: 字节块与固定密钥进行XOR运算\n            - 替换: 使用S盒替换每个字节的高4位和低4位并拼接\n            - 置换: 通过将每个字节左移1位进行简单置换\n            - 与密钥XOR: 置换后的字节块再次与固定密钥进行XOR运算\n        4. 十六进制编码: 将加密后的字节块转换为十六进制字符串\n        5. 拼接: 将所有加密块的十六进制字符串拼接形成最终密文\n解密算法:\n解密规则:\n    - 输入:\n        - 密文: 表示加密数据的十六进制字符串(其中A-E需要大写)\n    - 输出:\n        - 明文: 大写字母和空格组成的字符串\n    - 准备:\n        - 固定密钥\n            - KEY = b'1234567890ABCDEF'\n        - 逆S盒\n            - INV_S_BOX = {\n            0x0F: 0x00, 0x0A: 0x01, 0x07: 0x02, 0x05: 0x03,\n            0x09: 0x04, 0x03: 0x05, 0x0D: 0x06, 0x00: 0x07,\n            0x0E: 0x08, 0x08: 0x09, 0x04: 0x0A, 0x06: 0x0B,\n            0x01: 0x0C, 0x02: 0x0D, 0x0B: 0x0E, 0x0C: 0x0F\n            }\n    - 解密步骤:\n        1. 分块: 将密文分成16字符(8字节)的块\n        2. 块解密:\n            - 转换为字节: 将每个块从十六进制字符串转换为字节\n            - 与密钥XOR: 字节块与固定密钥进行XOR运算\n            - 逆置换: 通过将每个字节右移1位进行逆置换\n            - 替换: 使用逆S盒替换块中字节的高4位和低4位并拼接\n            - 与密钥XOR: 字节块再次与固定密钥进行XOR运算\n        3. 转换为文本: 使用ASCII解码将解密后的字节块转换回文本\n        4. 移除填充: 从解密后的明文末尾移除填充字符(\\x00)\n        5. 拼接: 将所有解密块拼接形成最终明文"], "replace_en": ["**Encryption Rules:**\n\n- Input:\n    - Plaintext: A string of uppercase letters and spaces.\n- Output:\n    - Ciphertext: A hexadecimal string representing the encrypted data (where A-E needs to be capitalised).\n- Preparation:\n    - Fixed key\n        - KEY = b'1234567890ABCDEF'\n    - S_BOX\n        - S_BOX = {\n        0x00: 0x0F, 0x01: 0x0A, 0x02: 0x07, 0x03: 0x05,\n        0x04: 0x09, 0x05: 0x03, 0x06: 0x0D, 0x07: 0x00,\n        0x08: 0x0E, 0x09: 0x08, 0x0A: 0x04, 0x0B: 0x06,\n        0x0C: 0x01, 0x0D: 0x02, 0x0E: 0x0B, 0x0F: 0x0C\n        }\n- Encryption Steps:\n    1. Padding: If the plaintext is not a multiple of 8 bytes, pad it with \\x00 (null character) to make its length a multiple of 8 bytes.\n    2. Block Splitting: Divide the padded plaintext into 8-byte blocks.\n    3. Block Encryption:\n        - Convert Block to Bytes: Convert each block to bytes using ASCII encoding.\n        - XOR with Key: Apply XOR between the byte block and the fixed key.\n        - Substitute:  Use the S_BOX Replacement Box to replace the high 4 bits and low 4 bits in each byte before stitching them together.\n        - Permute: Perform a simple permutation by rotating each byte left by 1 bit.\n        - XOR with Key: Apply XOR between the permuted byte block and the fixed key again.\n    4. Hexadecimal Encoding: Convert the encrypted byte blocks to a hexadecimal string.\n    5. Concatenate: Concatenate all the hexadecimal strings of the encrypted blocks to form the final ciphertext.\n\n**Decryption Rules:**\n\n- Input:\n    - Ciphertext: A hexadecimal string representing the encrypted data (where A-E needs to be capitalised).\n- Output:\n    - Plaintext: A string of uppercase letters and spaces.\n- Preparation:\n    - Fixed key\n        - KEY = b'1234567890ABCDEF'\n    - INV_S_BOX\n        - INV_S_BOX = {\n        0x0F: 0x00, 0x0A: 0x01, 0x07: 0x02, 0x05: 0x03,\n        0x09: 0x04, 0x03: 0x05, 0x0D: 0x06, 0x00: 0x07,\n        0x0E: 0x08, 0x08: 0x09, 0x04: 0x0A, 0x06: 0x0B,\n        0x01: 0x0C, 0x02: 0x0D, 0x0B: 0x0E, 0x0C: 0x0F\n        }\n- Decryption Steps:\n    1. Block Splitting: Divide the ciphertext into 16-character (8-byte) blocks (each block is 8 bytes long).\n    2. Block Decryption:\n        - Convert Hex to Bytes: Convert each block from hexadecimal string to bytes.\n        - XOR with Key: Apply XOR between the byte block and the fixed key.\n        - Inverse Permute: Perform an inverse permutation by rotating each byte right by 1 bit.\n        - Substitute: Use INV_S_BOX to replace the high four and low four bits in a block of bytes and splice them together.\n        - XOR with Key: Apply XOR between the byte block and the fixed key again.\n    3. Convert Bytes to Text: Convert the decrypted byte blocks back to text using ASCII decoding.\n    4. Remove Padding: Remove any padding characters (\\x00) from the end of the decrypted plaintext.\n    5. Concatenate: Concatenate all the decrypted blocks to form the final plaintext."]}
{"rule": "请根据加密算法对明文进行加密\n元素周期表加密是将明文字母映射到元素周期表中相应元素的原子序号的方法。每个字母可以对应多个元素，加密者需要选择一个规则来决定映射到哪个元素。空格可以不映射或用一个特定的数字表示，如\"0\"。加密后的密文是这些原子序号的序列。\n\n具体步骤如下：\n1. 选择字母序列：决定用于加密的字母序列，例如谜题中的文字。\n2. 映射到元素序号：将字母映射到对应的元素序号。若有多个元素的首字母相同，则随机选择一个元素进行映射。\n3. 生成密文：将映射后的数字串联起来得到密文。", "replace": ["请根据加密算法对明文进行加密\n元素周期表加密是将明文字母映射到元素周期表中相应元素的原子序号的方法。每个字母可以对应多个元素，加密者需要选择一个规则来决定映射到哪个元素。空格可以不映射或用一个特定的数字表示，如\"0\"。加密后的密文是这些原子序号的序列。\n\n具体步骤如下：\n1. 选择字母序列：决定用于加密的字母序列，例如谜题中的文字。\n2. 映射到元素序号：将字母映射到对应的元素序号。若有多个元素的首字母相同，则随机选择一个元素进行映射。\n3. 生成密文：将映射后的数字串联起来得到密文。"], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm. The periodic table encryption method maps plaintext letters to the atomic numbers of corresponding elements in the periodic table. Each letter can correspond to multiple elements, and the encryptor needs to choose a rule to determine which element to map to. Spaces can either not be mapped or represented by a specific number, such as \"0\". The encrypted ciphertext is a sequence of these atomic numbers.\n\nThe specific steps are as follows:\n1. Select the letter sequence: Decide on the letter sequence to be used for encryption, such as the text in the puzzle.\n2. Map to element numbers: Map the letters to the corresponding element numbers. If multiple elements have the same initial letter, randomly select an element for mapping.\n3. Generate ciphertext: Concatenate the mapped numbers to get the ciphertext."]}
{"rule": "请根据加密算法对明文进行加密\n\n    1. 过滤掉所有非字母数字字符。\n    2. 初始化一个包含 num_rails 个空字符串的列表，用于存储每一行的字符。\n    3. 遍历过滤后的明文中的每个字符，根据当前行数和方向将其添加到相应的行。\n    4. 当到达第一行或最后一行时，改变方向。\n    5. 按行读取所有字符，形成最终的密文。\n    ", "replace": ["请根据加密算法对明文进行加密\n\n    1. 过滤掉所有非字母数字字符。\n    2. 初始化一个包含 num_rails 个空字符串的列表，用于存储每一行的字符。\n    3. 遍历过滤后的明文中的每个字符，根据当前行数和方向将其添加到相应的行。\n    4. 当到达第一行或最后一行时，改变方向。\n    5. 按行读取所有字符，形成最终的密文。\n    "], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm.\n\n    1. Filter out all non-alphanumeric characters.\n    2. Initialize a list containing num_rails empty strings, which will be used to store the characters of each row.\n    3. Traverse each character in the filtered plaintext, and add it to the corresponding row based on the current row number and direction.\n    4. Change direction when reaching the first or last row.\n    5. Read all characters by row to form the final ciphertext."]}
{"rule": "请根据加密算法对明文进行加密\n\n### Autokey Cipher 加密方法概述\n\nAutokey Cipher是一种流密码技术，它使用一个初始密钥和明文本身的一部分来生成一个动态的、较长的密钥用于加密。这种方法可以提高安全性，因为每次加密使用的密钥都不同。\n\n### 加密过程简化解释\n\n1. **去除空格**：首先从明文中移除所有的空格，确保明文是连续的字母序列。\n\n2. **构造实际密钥**：开始时有一个初始密钥（可以是任意长度），然后将明文直接附加到这个初始密钥之后，创建一个与明文等长的“实际密钥”。这意味着，如果初始密钥较短，明文将被用作密钥的扩展部分。\n\n3. **字符映射**：在Autokey Cipher中，通常会使用一个简单的映射，即a=0, b=1, ..., z=25，用来将字母转换为数字，方便计算。\n\n4. **生成密文**：对于明文中的每个字母，根据其位置找到对应的“实际密钥”中的字母。然后，将这两个字母所代表的数字相加（如果结果大于等于26，则减去26以保持在字母表范围内）。最后，将得到的数值再转换回字母，这就是该位置上对应的密文字符。\n\n5. **拼接密文**：重复上述过程直到处理完所有明文字母，并将所有获得的密文字符连接起来形成最终的密文。\n", "replace": ["请根据加密算法对明文进行加密\n\n### Autokey Cipher 加密方法概述\n\nAutokey Cipher是一种流密码技术，它使用一个初始密钥和明文本身的一部分来生成一个动态的、较长的密钥用于加密。这种方法可以提高安全性，因为每次加密使用的密钥都不同。\n\n### 加密过程简化解释\n\n1. **去除空格**：首先从明文中移除所有的空格，确保明文是连续的字母序列。\n\n2. **构造实际密钥**：开始时有一个初始密钥（可以是任意长度），然后将明文直接附加到这个初始密钥之后，创建一个与明文等长的“实际密钥”。这意味着，如果初始密钥较短，明文将被用作密钥的扩展部分。\n\n3. **字符映射**：在Autokey Cipher中，通常会使用一个简单的映射，即a=0, b=1, ..., z=25，用来将字母转换为数字，方便计算。\n\n4. **生成密文**：对于明文中的每个字母，根据其位置找到对应的“实际密钥”中的字母。然后，将这两个字母所代表的数字相加（如果结果大于等于26，则减去26以保持在字母表范围内）。最后，将得到的数值再转换回字母，这就是该位置上对应的密文字符。\n\n5. **拼接密文**：重复上述过程直到处理完所有明文字母，并将所有获得的密文字符连接起来形成最终的密文。\n"], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm.\n\n### Overview of Autokey Cipher Encryption Method\n\nAutokey Cipher is a stream cipher technique that uses an initial key and a portion of the plaintext itself to generate a dynamic, longer key for encryption. This method can enhance security as the key used for encryption varies each time.\n\n### Simplified Explanation of the Encryption Process\n\n1. **Remove Spaces**: Firstly, remove all spaces from the plaintext to ensure that the plaintext is a continuous sequence of letters.\n\n2. **Construct Actual Key**: Initially, there is an initial key (which can be of any length), and then the plaintext is directly appended to this initial key, creating an \"actual key\" that is as long as the plaintext. This means that if the initial key is short, the plaintext will be used as the extension part of the key.\n\n3. **Character Mapping**: In Autokey Cipher, a simple mapping is usually used, i.e., a=0, b=1, ..., z=25, to convert letters into numbers for easy calculation.\n\n4. **Generate Ciphertext**: For each letter in the plaintext, find the corresponding letter in the \"actual key\" according to its position. Then, add the numbers represented by these two letters (if the result is greater than or equal to 26, subtract 26 to stay within the range of the alphabet). Finally, convert the obtained value back into a letter, which is the corresponding ciphertext character at that position.\n\n5. **Concatenate Ciphertext**: Repeat the above process until all plaintext letters are processed, and connect all the obtained ciphertext characters to form the final ciphertext."]}
{"rule": "请根据加密算法对明文进行加密\n\n    Beaufort Cipher是一种基于替换的加密算法，其加密过程依赖于一个字母表表格。字母表表格是一个26行26列的矩阵，每一行是从字母表的一个字母开始循环偏移排列的结果。\n\n    表格的结构如下：\n    Row 1: abcdefghijklmnopqrstuvwxyz\n    Row 2: bcdefghijklmnopqrstuvwxyza\n    Row 3: cdefghijklmnopqrstuvwxyzab\n    ...\n    Row 26: zabcdefghijklmnopqrstuvwxy\n\n    加密步骤如下：\n    1. 选择密钥（Key）：确定一个密钥，用于指导加密过程，每个字母将依次与明文字符匹配。\n    2. 表格查找：\n       - 找到明文字母在字母表中的位置（行索引）。\n       - 在该行中查找密钥字母的列索引。\n       - 在第一行中定位列索引对应的字母，将其作为密文字母。\n    3. 按照上述规则逐字处理明文，最终生成完整的密文。\n\n    注意：如果明文中包含非字母字符，它们将直接原样添加到密文中。\n    ", "replace": ["请根据加密算法对明文进行加密\n\n    Beaufort Cipher是一种基于替换的加密算法，其加密过程依赖于一个字母表表格。字母表表格是一个26行26列的矩阵，每一行是从字母表的一个字母开始循环偏移排列的结果。\n\n    表格的结构如下：\n    Row 1: abcdefghijklmnopqrstuvwxyz\n    Row 2: bcdefghijklmnopqrstuvwxyza\n    Row 3: cdefghijklmnopqrstuvwxyzab\n    ...\n    Row 26: zabcdefghijklmnopqrstuvwxy\n\n    加密步骤如下：\n    1. 选择密钥（Key）：确定一个密钥，用于指导加密过程，每个字母将依次与明文字符匹配。\n    2. 表格查找：\n       - 找到明文字母在字母表中的位置（行索引）。\n       - 在该行中查找密钥字母的列索引。\n       - 在第一行中定位列索引对应的字母，将其作为密文字母。\n    3. 按照上述规则逐字处理明文，最终生成完整的密文。\n\n    注意：如果明文中包含非字母字符，它们将直接原样添加到密文中。\n    "], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm.\n\nThe Beaufort Cipher is an encryption algorithm based on substitution, and its encryption process relies on a letter table. The letter table is a 26x26 matrix, each row of which is the result of cyclically offsetting from a letter in the alphabet.\n\nThe structure of the table is as follows:\nRow 1: abcdefghijklmnopqrstuvwxyz\nRow 2: bcdefghijklmnopqrstuvwxyza\nRow 3: cdefghijklmnopqrstuvwxyzab\n...\nRow 26: zabcdefghijklmnopqrstuvwxy\n\nThe encryption steps are as follows:\n1. Choose a key: Determine a key to guide the encryption process, each letter will be matched with the plaintext character in turn.\n2. Table lookup:\n   - Find the position of the plaintext letter in the alphabet (row index).\n   - Find the column index of the key letter in that row.\n   - Locate the letter corresponding to the column index in the first row and use it as the ciphertext letter.\n3. Process the plaintext letter by letter according to the above rules to finally generate the complete ciphertext.\n\nNote: If the plaintext contains non-alphabet characters, they will be directly added to the ciphertext as they are."]}
{"rule": "请根据加密算法对明文进行加密\n\n    加密规则\n    1. **字符替换**：根据给定的字母对映射规则，对原始文本中的字母进行替换。例如，将字母'V'替换为'I'，'I'替换为'V'，等等。注意：字母的大小写会进行相互替换，其他字符（如空格、标点符号）保持不变。\n    - 字母对映射表\n    {\n    'V': 'I', 'I': 'V', 'J': 'W', 'W': 'J', 'E': 'R', 'R': 'E',\n    'U': 'H', 'H': 'U', 'B': 'O', 'O': 'B', 'L': 'Y', 'Y': 'L',\n    'Q': 'D', 'D': 'Q', 'A': 'N', 'N': 'A', 'G': 'T', 'T': 'G',\n    'F': 'S', 'S': 'F', 'X': 'K', 'K': 'X', 'Z': 'M', 'M': 'Z',\n    'P': 'C', 'C': 'P',\n    'v': 'i', 'i': 'v', 'j': 'w', 'w': 'j', 'e': 'r', 'r': 'e',\n    'u': 'h', 'h': 'u', 'b': 'o', 'o': 'b', 'l': 'y', 'y': 'l',\n    'q': 'd', 'd': 'q', 'a': 'n', 'n': 'a', 'g': 't', 't': 'g',\n    'f': 's', 's': 'f', 'x': 'k', 'k': 'x', 'z': 'm', 'm': 'z',\n    'p': 'c', 'c': 'p'\n}\n    2. **16进制ASCII编码**：将替换后的文本转换为16进制表示的ASCII码，每个字符的ASCII码用16进制表示。例如，字母'H'的ASCII码是72，转换为16进制后为'48'。\n    3. **输出加密结果**：最后，返回加密后的消息，以16进制格式输出。\n    ", "replace": ["请根据加密算法对明文进行加密\n\n    加密规则\n    1. **字符替换**：根据给定的字母对映射规则，对原始文本中的字母进行替换。例如，将字母'V'替换为'I'，'I'替换为'V'，等等。注意：字母的大小写会进行相互替换，其他字符（如空格、标点符号）保持不变。\n    - 字母对映射表\n    {\n    'V': 'I', 'I': 'V', 'J': 'W', 'W': 'J', 'E': 'R', 'R': 'E',\n    'U': 'H', 'H': 'U', 'B': 'O', 'O': 'B', 'L': 'Y', 'Y': 'L',\n    'Q': 'D', 'D': 'Q', 'A': 'N', 'N': 'A', 'G': 'T', 'T': 'G',\n    'F': 'S', 'S': 'F', 'X': 'K', 'K': 'X', 'Z': 'M', 'M': 'Z',\n    'P': 'C', 'C': 'P',\n    'v': 'i', 'i': 'v', 'j': 'w', 'w': 'j', 'e': 'r', 'r': 'e',\n    'u': 'h', 'h': 'u', 'b': 'o', 'o': 'b', 'l': 'y', 'y': 'l',\n    'q': 'd', 'd': 'q', 'a': 'n', 'n': 'a', 'g': 't', 't': 'g',\n    'f': 's', 's': 'f', 'x': 'k', 'k': 'x', 'z': 'm', 'm': 'z',\n    'p': 'c', 'c': 'p'\n}\n    2. **16进制ASCII编码**：将替换后的文本转换为16进制表示的ASCII码，每个字符的ASCII码用16进制表示。例如，字母'H'的ASCII码是72，转换为16进制后为'48'。\n    3. **输出加密结果**：最后，返回加密后的消息，以16进制格式输出。\n    "], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm.\n\n    Encryption Rules\n    1. **Character Replacement**: Replace the letters in the original text according to the given letter pair mapping rules. For example, replace the letter 'V' with 'I', 'I' with 'V', and so on. Note: The case of the letters will be swapped, while other characters (such as spaces, punctuation marks) remain unchanged.\n    - Letter Pair Mapping Table\n    {\n    'V': 'I', 'I': 'V', 'J': 'W', 'W': 'J', 'E': 'R', 'R': 'E',\n    'U': 'H', 'H': 'U', 'B': 'O', 'O': 'B', 'L': 'Y', 'Y': 'L',\n    'Q': 'D', 'D': 'Q', 'A': 'N', 'N': 'A', 'G': 'T', 'T': 'G',\n    'F': 'S', 'S': 'F', 'X': 'K', 'K': 'X', 'Z': 'M', 'M': 'Z',\n    'P': 'C', 'C': 'P',\n    'v': 'i', 'i': 'v', 'j': 'w', 'w': 'j', 'e': 'r', 'r': 'e',\n    'u': 'h', 'h': 'u', 'b': 'o', 'o': 'b', 'l': 'y', 'y': 'l',\n    'q': 'd', 'd': 'q', 'a': 'n', 'n': 'a', 'g': 't', 't': 'g',\n    'f': 's', 's': 'f', 'x': 'k', 'k': 'x', 'z': 'm', 'm': 'z',\n    'p': 'c', 'c': 'p'\n}\n    2. **Hexadecimal ASCII Encoding**: Convert the replaced text into ASCII codes represented in hexadecimal. Each character's ASCII code is represented in hexadecimal. For example, the ASCII code for the letter 'H' is 72, which is '48' in hexadecimal.\n    3. **Output the Encrypted Result**: Finally, return the encrypted message in hexadecimal format."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    Beaufort Cipher是一种基于替换的加密算法，其加密过程依赖于一个字母表表格。字母表表格是一个26行26列的矩阵，每一行是从字母表的一个字母开始循环偏移排列的结果。\n\n    表格的结构如下：\n    Row 1: abcdefghijklmnopqrstuvwxyz\n    Row 2: bcdefghijklmnopqrstuvwxyza\n    Row 3: cdefghijklmnopqrstuvwxyzab\n    ...\n    Row 26: zabcdefghijklmnopqrstuvwxy\n\n    加密步骤如下：\n    1. 选择密钥（Key）：确定一个密钥，用于指导加密过程，每个字母将依次与明文字符匹配。\n    2. 表格查找：\n       - 找到明文字母在字母表中的位置（行索引）。\n       - 在该行中查找密钥字母的列索引。\n       - 在第一行中定位列索引对应的字母，将其作为密文字母。\n    3. 按照上述规则逐字处理明文，最终生成完整的密文。\n\n    注意：如果明文中包含非字母字符，它们将直接原样添加到密文中。\n    \n解密算法:\n\n    Beaufort Cipher的解密过程与加密过程类似，但方向相反。\n    解密过程中需要使用同样的字母表表格，其结构与加密相同：\n\n    表格的结构如下：\n    Row 1: abcdefghijklmnopqrstuvwxyz\n    Row 2: bcdefghijklmnopqrstuvwxyza\n    Row 3: cdefghijklmnopqrstuvwxyzab\n    ...\n    Row 26: zabcdefghijklmnopqrstuvwxy\n\n    解密步骤如下：\n    1. 在第一行中找到密文字母的位置（列索引）。\n    2. 在该列中查找密钥字母的位置（行索引）。\n    3. 使用行索引在第一列中定位对应的明文字母。\n    4. 按照上述规则逐字处理密文，最终还原完整的明文。\n\n    注意：如果密文中包含非字母字符，它们将直接原样添加到明文中。\n    ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    Beaufort Cipher是一种基于替换的加密算法，其加密过程依赖于一个字母表表格。字母表表格是一个26行26列的矩阵，每一行是从字母表的一个字母开始循环偏移排列的结果。\n\n    表格的结构如下：\n    Row 1: abcdefghijklmnopqrstuvwxyz\n    Row 2: bcdefghijklmnopqrstuvwxyza\n    Row 3: cdefghijklmnopqrstuvwxyzab\n    ...\n    Row 26: zabcdefghijklmnopqrstuvwxy\n\n    加密步骤如下：\n    1. 选择密钥（Key）：确定一个密钥，用于指导加密过程，每个字母将依次与明文字符匹配。\n    2. 表格查找：\n       - 找到明文字母在字母表中的位置（行索引）。\n       - 在该行中查找密钥字母的列索引。\n       - 在第一行中定位列索引对应的字母，将其作为密文字母。\n    3. 按照上述规则逐字处理明文，最终生成完整的密文。\n\n    注意：如果明文中包含非字母字符，它们将直接原样添加到密文中。\n    \n解密算法:\n\n    Beaufort Cipher的解密过程与加密过程类似，但方向相反。\n    解密过程中需要使用同样的字母表表格，其结构与加密相同：\n\n    表格的结构如下：\n    Row 1: abcdefghijklmnopqrstuvwxyz\n    Row 2: bcdefghijklmnopqrstuvwxyza\n    Row 3: cdefghijklmnopqrstuvwxyzab\n    ...\n    Row 26: zabcdefghijklmnopqrstuvwxy\n\n    解密步骤如下：\n    1. 在第一行中找到密文字母的位置（列索引）。\n    2. 在该列中查找密钥字母的位置（行索引）。\n    3. 使用行索引在第一列中定位对应的明文字母。\n    4. 按照上述规则逐字处理密文，最终还原完整的明文。\n\n    注意：如果密文中包含非字母字符，它们将直接原样添加到明文中。\n    "], "replace_en": ["Please decrypt the password according to the encryption and decryption algorithms.\n\nEncryption Algorithm:\n\n    The Beaufort Cipher is a substitution-based encryption algorithm, and its encryption process relies on an alphabetic table. The alphabetic table is a 26x26 matrix, each row of which is the result of cyclically offsetting from a letter in the alphabet.\n\n    The structure of the table is as follows:\n    Row 1: abcdefghijklmnopqrstuvwxyz\n    Row 2: bcdefghijklmnopqrstuvwxyza\n    Row 3: cdefghijklmnopqrstuvwxyzab\n    ...\n    Row 26: zabcdefghijklmnopqrstuvwxy\n\n    The encryption steps are as follows:\n    1. Choose a key: Determine a key to guide the encryption process, each letter will match the plaintext character in turn.\n    2. Table lookup:\n       - Find the position of the plaintext letter in the alphabet (row index).\n       - Find the column index of the key letter in that row.\n       - Locate the letter corresponding to the column index in the first row and use it as the ciphertext letter.\n    3. Process the plaintext letter by letter according to the above rules to generate the complete ciphertext.\n\n    Note: If the plaintext contains non-alphabetic characters, they will be directly added to the ciphertext as they are.\n\nDecryption Algorithm:\n\n    The decryption process of the Beaufort Cipher is similar to the encryption process, but in the opposite direction. The same alphabetic table is used in the decryption process, and its structure is the same as that of encryption:\n\n    The structure of the table is as follows:\n    Row 1: abcdefghijklmnopqrstuvwxyz\n    Row 2: bcdefghijklmnopqrstuvwxyza\n    Row 3: cdefghijklmnopqrstuvwxyzab\n    ...\n    Row 26: zabcdefghijklmnopqrstuvwxy\n\n    The decryption steps are as follows:\n    1. Find the position of the ciphertext letter in the first row (column index).\n    2. Find the position of the key letter in that column (row index).\n    3. Use the row index to locate the corresponding plaintext letter in the first column.\n    4. Process the ciphertext letter by letter according to the above rules to restore the complete plaintext.\n\n    Note: If the ciphertext contains non-alphabetic characters, they will be directly added to the plaintext as they are."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    编码规则基于 Beale Ciphers，具体步骤如下：\n    1. 将码书按空格和标点符号分词，生成一个不含标点符号的单词列表。\n    2. 为每个单词分配从1开始的唯一索引。\n    3. 对于明文中的每个字符，找到其在码书中首次匹配的单词（首字母与字符相同）。\n    4. 记录该单词的索引，依次生成编码数字串。\n    \n解密算法:\n\n    解码规则基于 Beale Ciphers，具体步骤如下：\n    1. 根据编码数字串，找到码书中对应索引的单词。\n    2. 提取这些单词的首字母，按顺序组合形成明文。\n    ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    编码规则基于 Beale Ciphers，具体步骤如下：\n    1. 将码书按空格和标点符号分词，生成一个不含标点符号的单词列表。\n    2. 为每个单词分配从1开始的唯一索引。\n    3. 对于明文中的每个字符，找到其在码书中首次匹配的单词（首字母与字符相同）。\n    4. 记录该单词的索引，依次生成编码数字串。\n    \n解密算法:\n\n    解码规则基于 Beale Ciphers，具体步骤如下：\n    1. 根据编码数字串，找到码书中对应索引的单词。\n    2. 提取这些单词的首字母，按顺序组合形成明文。\n    "], "replace_en": ["Please decrypt the password according to the encryption and decryption algorithms.\n\nEncryption Algorithm:\n\n    The coding rules are based on Beale Ciphers, with the specific steps as follows:\n    1. Divide the codebook into words by spaces and punctuation marks, generating a word list without punctuation marks.\n    2. Assign a unique index starting from 1 for each word.\n    3. For each character in the plaintext, find the word that first matches it in the codebook (the first letter of the word is the same as the character).\n    4. Record the index of this word and generate a coded number string in sequence.\n\nDecryption Algorithm:\n\n    The decoding rules are based on Beale Ciphers, with the specific steps as follows:\n    1. According to the coded number string, find the word with the corresponding index in the codebook.\n    2. Extract the first letters of these words and combine them in order to form the plaintext."]}
{"rule": "请根据加密算法对明文进行加密\n\n    棋盘密码（Polybius Square Cipher）是一种将字母编码成符号对的方法。它使用一个5行5列的网格，网格中包含26个英文字母，其中I和J在同一个格中。相应字母用数对表示。在古代，这种棋盘密码被广泛使用。Polybius校验表如下：\n\n    1 2 3 4 5\n    1 A B C D E\n    2 F G H I/J K\n    3 L M N O P\n    4 Q R S T U\n    5 V W X Y Z\n\n    棋盘密码的加密过程非常简单，对于一个需要解码的英文字符串，首先将每个字母转换成大写，然后按照校验表中的元素对应：A对应11，B对应12...Z对应55（I和J都对应24），就可以将英文字符串加密成一个长度为2倍、由数字组成的密文。\n    ", "replace": ["请根据加密算法对明文进行加密\n\n    棋盘密码（Polybius Square Cipher）是一种将字母编码成符号对的方法。它使用一个5行5列的网格，网格中包含26个英文字母，其中I和J在同一个格中。相应字母用数对表示。在古代，这种棋盘密码被广泛使用。Polybius校验表如下：\n\n    1 2 3 4 5\n    1 A B C D E\n    2 F G H I/J K\n    3 L M N O P\n    4 Q R S T U\n    5 V W X Y Z\n\n    棋盘密码的加密过程非常简单，对于一个需要解码的英文字符串，首先将每个字母转换成大写，然后按照校验表中的元素对应：A对应11，B对应12...Z对应55（I和J都对应24），就可以将英文字符串加密成一个长度为2倍、由数字组成的密文。\n    "], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm.\n\nThe Polybius Square Cipher is a method of encoding letters into pairs of symbols. It uses a 5x5 grid that contains 26 English letters, with I and J in the same cell. The corresponding letters are represented by pairs of numbers. In ancient times, this type of cipher was widely used. The Polybius check table is as follows:\n\n1 2 3 4 5\n1 A B C D E\n2 F G H I/J K\n3 L M N O P\n4 Q R S T U\n5 V W X Y Z\n\nThe encryption process of the Polybius Square Cipher is very simple. For an English string that needs to be decoded, first convert each letter to uppercase, then correspond to the elements in the check table: A corresponds to 11, B corresponds to 12...Z corresponds to 55 (I and J both correspond to 24), and you can encrypt the English string into a ciphertext composed of numbers twice the length."]}
{"rule": "请根据加密算法对明文进行加密\n\n    编码规则基于 Beale Ciphers，具体步骤如下：\n    1. 将码书按空格和标点符号分词，生成一个不含标点符号的单词列表。\n    2. 为每个单词分配从1开始的唯一索引。\n    3. 对于明文中的每个字符，找到其在码书中首次匹配的单词（首字母与字符相同）。\n    4. 记录该单词的索引，依次生成编码数字串。\n    ", "replace": ["请根据加密算法对明文进行加密\n\n    编码规则基于 Beale Ciphers，具体步骤如下：\n    1. 将码书按空格和标点符号分词，生成一个不含标点符号的单词列表。\n    2. 为每个单词分配从1开始的唯一索引。\n    3. 对于明文中的每个字符，找到其在码书中首次匹配的单词（首字母与字符相同）。\n    4. 记录该单词的索引，依次生成编码数字串。\n    "], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm.\n\nThe encoding rules are based on Beale Ciphers, and the specific steps are as follows:\n1. Divide the codebook into words by spaces and punctuation marks to generate a word list without punctuation marks.\n2. Assign a unique index starting from 1 for each word.\n3. For each character in the plaintext, find the word that first matches it in the codebook (the first letter of the word is the same as the character).\n4. Record the index of this word and generate the encoded number string in order."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n元素周期表加密是将明文字母映射到元素周期表中相应元素的原子序号的方法。每个字母可以对应多个元素，加密者需要选择一个规则来决定映射到哪个元素。空格可以不映射或用一个特定的数字表示，如\"0\"。加密后的密文是这些原子序号的序列。\n\n具体步骤如下：\n1. 选择字母序列：决定用于加密的字母序列，例如谜题中的文字。\n2. 映射到元素序号：将字母映射到对应的元素序号。若有多个元素的首字母相同，则随机选择一个元素进行映射。\n3. 生成密文：将映射后的数字串联起来得到密文。\n解密算法:\n解密元素周期表加密时需要元素周期表首字母序列。然后根据数字重新映射到对应的字母，再按数字的原始顺序还原出明文。具体步骤如下：\n1. 确定字母序列：获取用于加密和解密的字母序列。\n2. 序号映射到字母：将数字映射回对应的元素首字母。\n3. 生成明文：将映射后的字母按原始顺序串联起来得到明文。", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n元素周期表加密是将明文字母映射到元素周期表中相应元素的原子序号的方法。每个字母可以对应多个元素，加密者需要选择一个规则来决定映射到哪个元素。空格可以不映射或用一个特定的数字表示，如\"0\"。加密后的密文是这些原子序号的序列。\n\n具体步骤如下：\n1. 选择字母序列：决定用于加密的字母序列，例如谜题中的文字。\n2. 映射到元素序号：将字母映射到对应的元素序号。若有多个元素的首字母相同，则随机选择一个元素进行映射。\n3. 生成密文：将映射后的数字串联起来得到密文。\n解密算法:\n解密元素周期表加密时需要元素周期表首字母序列。然后根据数字重新映射到对应的字母，再按数字的原始顺序还原出明文。具体步骤如下：\n1. 确定字母序列：获取用于加密和解密的字母序列。\n2. 序号映射到字母：将数字映射回对应的元素首字母。\n3. 生成明文：将映射后的字母按原始顺序串联起来得到明文。"], "replace_en": ["Please decrypt the password according to the encryption and decryption algorithms.\n\nEncryption Algorithm:\nThe periodic table encryption method maps plain text letters to the atomic numbers of corresponding elements in the periodic table. Each letter can correspond to multiple elements, and the encryptor needs to choose a rule to determine which element to map to. Spaces can either not be mapped or represented by a specific number, such as \"0\". The encrypted ciphertext is a sequence of these atomic numbers.\n\nThe specific steps are as follows:\n1. Select the letter sequence: Decide on the letter sequence to be used for encryption, such as the text in the puzzle.\n2. Map to element numbers: Map the letters to the corresponding element numbers. If multiple elements have the same initial letter, randomly select an element for mapping.\n3. Generate ciphertext: Concatenate the mapped numbers to get the ciphertext.\n\nDecryption Algorithm:\nWhen decrypting periodic table encryption, you need the initial letter sequence of the periodic table. Then, according to the numbers, remap to the corresponding letters, and restore the plaintext in the original order of the numbers. The specific steps are as follows:\n1. Determine the letter sequence: Obtain the letter sequence used for encryption and decryption.\n2. Map numbers to letters: Map the numbers back to the corresponding element's initial letter.\n3. Generate plaintext: Concatenate the mapped letters in the original order to get the plaintext."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n### Autokey Cipher 加密方法概述\n\nAutokey Cipher是一种流密码技术，它使用一个初始密钥和明文本身的一部分来生成一个动态的、较长的密钥用于加密。这种方法可以提高安全性，因为每次加密使用的密钥都不同。\n\n### 加密过程简化解释\n\n1. **去除空格**：首先从明文中移除所有的空格，确保明文是连续的字母序列。\n\n2. **构造实际密钥**：开始时有一个初始密钥（可以是任意长度），然后将明文直接附加到这个初始密钥之后，创建一个与明文等长的“实际密钥”。这意味着，如果初始密钥较短，明文将被用作密钥的扩展部分。\n\n3. **字符映射**：在Autokey Cipher中，通常会使用一个简单的映射，即a=0, b=1, ..., z=25，用来将字母转换为数字，方便计算。\n\n4. **生成密文**：对于明文中的每个字母，根据其位置找到对应的“实际密钥”中的字母。然后，将这两个字母所代表的数字相加（如果结果大于等于26，则减去26以保持在字母表范围内）。最后，将得到的数值再转换回字母，这就是该位置上对应的密文字符。\n\n5. **拼接密文**：重复上述过程直到处理完所有明文字母，并将所有获得的密文字符连接起来形成最终的密文。\n\n解密算法:\n\nAutokey Cipher的解密过程是加密过程的逆操作。由于在加密过程中，明文的一部分被用来扩展了密钥，因此在解密时我们也需要逐步重建这个动态密钥。以下是根据您提供的文本简化和澄清后的解密步骤：\n\n### Autokey Cipher 解密过程\n\n1. **准备**：首先准备好密文（即加密后的文本）和初始密钥。确保你知道密文字母的数量。\n\n2. **初始化密钥**：使用与加密相同的初始密钥开始解密过程。初始密钥长度通常比最终用于加密的密钥短，因为它会被明文扩展。\n\n3. **解密并扩展密钥**：\n   - 对于密文中的每个字母 Ci 和当前使用的密钥字母 Ki，应用解密公式来计算原始明文字母 Pi。\n   - 解密公式为：`Pi = (Ci - Ki + 26) % 26`，这里 `%` 表示取模运算，保证结果落在0到25之间。\n   - 将得到的明文字母 Pi 转换回字母，并将其添加到解密出的明文中。\n   - 同时，将刚刚解密出来的明文字母 Pi 追加到密钥后面，以扩展密钥。\n\n4. **重复解密**：继续对密文的下一个字母进行解密，并按照上述步骤更新密钥，直到所有密文都被解密。\n\n5. **拼接明文**：当所有密文字符都已经被解密后，将所有解密出的明文字母按顺序拼接起来形成完整的原始明文。\n    ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n### Autokey Cipher 加密方法概述\n\nAutokey Cipher是一种流密码技术，它使用一个初始密钥和明文本身的一部分来生成一个动态的、较长的密钥用于加密。这种方法可以提高安全性，因为每次加密使用的密钥都不同。\n\n### 加密过程简化解释\n\n1. **去除空格**：首先从明文中移除所有的空格，确保明文是连续的字母序列。\n\n2. **构造实际密钥**：开始时有一个初始密钥（可以是任意长度），然后将明文直接附加到这个初始密钥之后，创建一个与明文等长的“实际密钥”。这意味着，如果初始密钥较短，明文将被用作密钥的扩展部分。\n\n3. **字符映射**：在Autokey Cipher中，通常会使用一个简单的映射，即a=0, b=1, ..., z=25，用来将字母转换为数字，方便计算。\n\n4. **生成密文**：对于明文中的每个字母，根据其位置找到对应的“实际密钥”中的字母。然后，将这两个字母所代表的数字相加（如果结果大于等于26，则减去26以保持在字母表范围内）。最后，将得到的数值再转换回字母，这就是该位置上对应的密文字符。\n\n5. **拼接密文**：重复上述过程直到处理完所有明文字母，并将所有获得的密文字符连接起来形成最终的密文。\n\n解密算法:\n\nAutokey Cipher的解密过程是加密过程的逆操作。由于在加密过程中，明文的一部分被用来扩展了密钥，因此在解密时我们也需要逐步重建这个动态密钥。以下是根据您提供的文本简化和澄清后的解密步骤：\n\n### Autokey Cipher 解密过程\n\n1. **准备**：首先准备好密文（即加密后的文本）和初始密钥。确保你知道密文字母的数量。\n\n2. **初始化密钥**：使用与加密相同的初始密钥开始解密过程。初始密钥长度通常比最终用于加密的密钥短，因为它会被明文扩展。\n\n3. **解密并扩展密钥**：\n   - 对于密文中的每个字母 Ci 和当前使用的密钥字母 Ki，应用解密公式来计算原始明文字母 Pi。\n   - 解密公式为：`Pi = (Ci - Ki + 26) % 26`，这里 `%` 表示取模运算，保证结果落在0到25之间。\n   - 将得到的明文字母 Pi 转换回字母，并将其添加到解密出的明文中。\n   - 同时，将刚刚解密出来的明文字母 Pi 追加到密钥后面，以扩展密钥。\n\n4. **重复解密**：继续对密文的下一个字母进行解密，并按照上述步骤更新密钥，直到所有密文都被解密。\n\n5. **拼接明文**：当所有密文字符都已经被解密后，将所有解密出的明文字母按顺序拼接起来形成完整的原始明文。\n    "], "replace_en": ["Please decrypt the password according to the encryption and decryption algorithms.\n\nEncryption Algorithm:\n\n### Overview of Autokey Cipher Encryption Method\n\nAutokey Cipher is a stream cipher technique that uses an initial key and a portion of the plaintext itself to generate a dynamic, longer key for encryption. This method can enhance security as the key used for encryption varies each time.\n\n### Simplified Explanation of the Encryption Process\n\n1. **Remove Spaces**: First, remove all spaces from the plaintext to ensure a continuous sequence of letters.\n\n2. **Construct Actual Key**: Start with an initial key (of any length), then append the plaintext directly to this initial key, creating an \"actual key\" of the same length as the plaintext. This means that if the initial key is short, the plaintext will be used as an extension of the key.\n\n3. **Character Mapping**: In Autokey Cipher, a simple mapping is usually used, i.e., a=0, b=1, ..., z=25, to convert letters into numbers for easy calculation.\n\n4. **Generate Ciphertext**: For each letter in the plaintext, find the corresponding letter in the \"actual key\" based on its position. Then, add the numbers represented by these two letters (if the result is greater than or equal to 26, subtract 26 to stay within the alphabet range). Finally, convert the resulting number back into a letter, which is the corresponding ciphertext character at that position.\n\n5. **Concatenate Ciphertext**: Repeat the above process until all plaintext letters are processed, and connect all the obtained ciphertext characters to form the final ciphertext.\n\nDecryption Algorithm:\n\nThe decryption process of Autokey Cipher is the reverse operation of the encryption process. Since a part of the plaintext is used to extend the key during encryption, we also need to gradually rebuild this dynamic key during decryption. Here are the simplified and clarified decryption steps based on the text you provided:\n\n### Autokey Cipher Decryption Process\n\n1. **Preparation**: First, prepare the ciphertext (i.e., the encrypted text) and the initial key. Make sure you know the number of ciphertext letters.\n\n2. **Initialize Key**: Start the decryption process with the same initial key used for encryption. The initial key length is usually shorter than the final key used for encryption because it will be extended by the plaintext.\n\n3. **Decrypt and Extend Key**:\n   - For each letter Ci in the ciphertext and the currently used key letter Ki, apply the decryption formula to calculate the original plaintext letter Pi.\n   - The decryption formula is: `Pi = (Ci - Ki + 26) % 26`, where `%` represents the modulus operation, ensuring the result falls between 0 and 25.\n   - Convert the obtained plaintext letter Pi back into a letter and add it to the decrypted plaintext.\n   - At the same time, append the just decrypted plaintext letter Pi to the key to extend the key.\n\n4. **Repeat Decryption**: Continue to decrypt the next letter in the ciphertext and update the key according to the above steps until all ciphertexts are decrypted.\n\n5. **Concatenate Plaintext**: When all ciphertext characters have been decrypted, concatenate all decrypted plaintext letters in order to form the complete original plaintext."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    1. 过滤掉所有非字母数字字符。\n    2. 初始化一个包含 num_rails 个空字符串的列表，用于存储每一行的字符。\n    3. 遍历过滤后的明文中的每个字符，根据当前行数和方向将其添加到相应的行。\n    4. 当到达第一行或最后一行时，改变方向。\n    5. 按行读取所有字符，形成最终的密文。\n    \n解密算法:\n\n    1. 计算周期，即 (num_rails - 1) * 2。\n    2. 计算密文长度。\n    3. 计算每行的字符数量。\n    4. 初始化解密后的字符数组。\n    5. 逐行填充字符，根据Rail Fence Cipher的模式重新排列字符。\n    6. 输出解密后的明文。\n    ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    1. 过滤掉所有非字母数字字符。\n    2. 初始化一个包含 num_rails 个空字符串的列表，用于存储每一行的字符。\n    3. 遍历过滤后的明文中的每个字符，根据当前行数和方向将其添加到相应的行。\n    4. 当到达第一行或最后一行时，改变方向。\n    5. 按行读取所有字符，形成最终的密文。\n    \n解密算法:\n\n    1. 计算周期，即 (num_rails - 1) * 2。\n    2. 计算密文长度。\n    3. 计算每行的字符数量。\n    4. 初始化解密后的字符数组。\n    5. 逐行填充字符，根据Rail Fence Cipher的模式重新排列字符。\n    6. 输出解密后的明文。\n    "], "replace_en": ["Please decrypt the password according to the encryption and decryption algorithms.\n\nEncryption Algorithm:\n\n    1. Filter out all non-alphanumeric characters.\n    2. Initialize a list containing num_rails empty strings to store the characters of each row.\n    3. Traverse each character in the filtered plaintext, and add it to the corresponding row based on the current row number and direction.\n    4. Change direction when reaching the first or last row.\n    5. Read all characters by row to form the final ciphertext.\n\nDecryption Algorithm:\n\n    1. Calculate the period, which is (num_rails - 1) * 2.\n    2. Calculate the length of the ciphertext.\n    3. Calculate the number of characters in each row.\n    4. Initialize the character array after decryption.\n    5. Fill in the characters row by row, and rearrange the characters according to the Rail Fence Cipher pattern.\n    6. Output the plaintext after decryption."]}
{"rule": "请根据加密算法对明文进行加密\n\n    1. 去除输入句子的前导和尾随空格。\n    2. 将每个字母或数字映射为其对应的摩尔斯电码，并在每个摩尔斯电码后添加一个斜杠 `/`。将每个既不是字母也不是数字的字符映射为斜杠 `/`，得到初始字符串。\n    3. 将初始字符串中的每个点 `.` 替换为字母 `B`，将每个划线 `-` 替换为字母 `W`。\n    4. 检查字符串长度是否能被 8 整除。如果不能，用斜杠 `/` 填充字符串，使其长度能被 8 整除。\n    5. 在字符串的每 8 个字符之间插入换行符 `\n`，确保没有尾随的换行符。这将是最终的加密字符串。\n    ", "replace": ["请根据加密算法对明文进行加密\n\n    1. 去除输入句子的前导和尾随空格。\n    2. 将每个字母或数字映射为其对应的摩尔斯电码，并在每个摩尔斯电码后添加一个斜杠 `/`。将每个既不是字母也不是数字的字符映射为斜杠 `/`，得到初始字符串。\n    3. 将初始字符串中的每个点 `.` 替换为字母 `B`，将每个划线 `-` 替换为字母 `W`。\n    4. 检查字符串长度是否能被 8 整除。如果不能，用斜杠 `/` 填充字符串，使其长度能被 8 整除。\n    5. 在字符串的每 8 个字符之间插入换行符 `\n`，确保没有尾随的换行符。这将是最终的加密字符串。\n    "], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm:\n\n    1. Remove the leading and trailing spaces from the input sentence.\n    2. Map each letter or number to its corresponding Morse code, and add a slash `/` after each Morse code. Map each character that is neither a letter nor a number to a slash `/` to get the initial string.\n    3. Replace each dot `.` in the initial string with the letter `B`, and replace each dash `-` with the letter `W`.\n    4. Check if the length of the string can be divided by 8. If not, fill the string with slashes `/` to make its length divisible by 8.\n    5. Insert a newline character `\n` between every 8 characters in the string, ensuring there is no trailing newline. This will be the final encrypted string."]}
{"rule": "请根据加密算法对明文进行加密\n\n    1. **去重关键词生成加密字母表**: 根据关键词生成一个新的字母表，去除重复字母并补全未使用的字母。\n    2. **逐个字母替换**: 遍历明文字符，将标准字母表中的字母替换为加密字母表中的对应字母。\n    3. **保持非字母字符不变**: 对空格、标点符号等非字母字符直接保留。\n    4. **输出最终结果**: 将所有加密后的字符组合成密文。\n    ", "replace": ["请根据加密算法对明文进行加密\n\n    1. **去重关键词生成加密字母表**: 根据关键词生成一个新的字母表，去除重复字母并补全未使用的字母。\n    2. **逐个字母替换**: 遍历明文字符，将标准字母表中的字母替换为加密字母表中的对应字母。\n    3. **保持非字母字符不变**: 对空格、标点符号等非字母字符直接保留。\n    4. **输出最终结果**: 将所有加密后的字符组合成密文。\n    "], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm.\n\n    1. **Generate an encryption alphabet by removing duplicate keywords**: Create a new alphabet based on the keyword, remove duplicate letters and complete unused letters.\n    2. **Replace each letter individually**: Traverse the plaintext characters, replacing the letters in the standard alphabet with the corresponding letters in the encryption alphabet.\n    3. **Keep non-letter characters unchanged**: Directly retain spaces, punctuation marks, and other non-letter characters.\n    4. **Output the final result**: Combine all encrypted characters into ciphertext."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    棋盘密码（Polybius Square Cipher）是一种将字母编码成符号对的方法。它使用一个5行5列的网格，网格中包含26个英文字母，其中I和J在同一个格中。相应字母用数对表示。在古代，这种棋盘密码被广泛使用。Polybius校验表如下：\n\n    1 2 3 4 5\n    1 A B C D E\n    2 F G H I/J K\n    3 L M N O P\n    4 Q R S T U\n    5 V W X Y Z\n\n    棋盘密码的加密过程非常简单，对于一个需要解码的英文字符串，首先将每个字母转换成大写，然后按照校验表中的元素对应：A对应11，B对应12...Z对应55（I和J都对应24），就可以将英文字符串加密成一个长度为2倍、由数字组成的密文。\n    \n解密算法:\n\n    解密过程可以看成是加密过程的逆过程，由加密过程可知，密文应该是由偶数位的数字组成（如不然，舍去最后一位数字）。解密过程首先应从左到右每位数字分成一个组，再对每个组按照校验表得到2位数字对应的英文字母，再将英文字母从左往右排列即可得到明文。\n\n    需要注意的是，与加密过程的唯一性不同，由于24这个数字既可以解密成I，又可以解密成J，加密过程可以出现不同的结果。如果把加密的映射规则看成一个函数，这个加密函数不存在逆函数。根据任务网址可以试验发现：对于PROJECT进行一次加密，再将密文进行解密，得到的结果是PROIECT。通常来说，如何确定24解密成I还是J要根据上下文确定，这需要人的工作。对于算法实现棋盘密码的加密解密过程，由在网址的实验可知：24固定解密成I。\n    ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    棋盘密码（Polybius Square Cipher）是一种将字母编码成符号对的方法。它使用一个5行5列的网格，网格中包含26个英文字母，其中I和J在同一个格中。相应字母用数对表示。在古代，这种棋盘密码被广泛使用。Polybius校验表如下：\n\n    1 2 3 4 5\n    1 A B C D E\n    2 F G H I/J K\n    3 L M N O P\n    4 Q R S T U\n    5 V W X Y Z\n\n    棋盘密码的加密过程非常简单，对于一个需要解码的英文字符串，首先将每个字母转换成大写，然后按照校验表中的元素对应：A对应11，B对应12...Z对应55（I和J都对应24），就可以将英文字符串加密成一个长度为2倍、由数字组成的密文。\n    \n解密算法:\n\n    解密过程可以看成是加密过程的逆过程，由加密过程可知，密文应该是由偶数位的数字组成（如不然，舍去最后一位数字）。解密过程首先应从左到右每位数字分成一个组，再对每个组按照校验表得到2位数字对应的英文字母，再将英文字母从左往右排列即可得到明文。\n\n    需要注意的是，与加密过程的唯一性不同，由于24这个数字既可以解密成I，又可以解密成J，加密过程可以出现不同的结果。如果把加密的映射规则看成一个函数，这个加密函数不存在逆函数。根据任务网址可以试验发现：对于PROJECT进行一次加密，再将密文进行解密，得到的结果是PROIECT。通常来说，如何确定24解密成I还是J要根据上下文确定，这需要人的工作。对于算法实现棋盘密码的加密解密过程，由在网址的实验可知：24固定解密成I。\n    "], "replace_en": ["Please decrypt the password according to the encryption and decryption algorithms.\n\nEncryption Algorithm:\n\nThe Polybius Square Cipher is a method of encoding letters into pairs of symbols. It uses a 5x5 grid that contains 26 English letters, with I and J in the same cell. The corresponding letters are represented by pairs of numbers. This type of cipher was widely used in ancient times. The Polybius check table is as follows:\n\n1 2 3 4 5\n1 A B C D E\n2 F G H I/J K\n3 L M N O P\n4 Q R S T U\n5 V W X Y Z\n\nThe encryption process of the Polybius Square Cipher is very simple. For an English string that needs to be decoded, first convert each letter to uppercase, then correspond to the elements in the check table: A corresponds to 11, B corresponds to 12...Z corresponds to 55 (I and J both correspond to 24). This way, the English string can be encrypted into a ciphertext composed of numbers, twice the length of the original string.\n\nDecryption Algorithm:\n\nThe decryption process can be seen as the reverse process of the encryption process. As known from the encryption process, the ciphertext should be composed of an even number of digits (if not, discard the last digit). The decryption process should first divide each digit from left to right into a group, then get the English letter corresponding to the two-digit number according to the check table, and then arrange the English letters from left to right to get the plaintext.\n\nIt should be noted that unlike the uniqueness of the encryption process, since the number 24 can be decrypted into either I or J, the encryption process can produce different results. If the encryption mapping rule is regarded as a function, this encryption function does not have an inverse function. According to the task URL, it can be found by experiment: encrypt PROJECT once, and then decrypt the ciphertext, the result is PROIECT. Generally speaking, whether 24 is decrypted into I or J needs to be determined based on the context, which requires human work. For the algorithm to implement the encryption and decryption process of the Polybius Square Cipher, it is known from the experiment on the URL: 24 is always decrypted into I."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    1. **去重关键词生成加密字母表**: 根据关键词生成一个新的字母表，去除重复字母并补全未使用的字母。\n    2. **逐个字母替换**: 遍历明文字符，将标准字母表中的字母替换为加密字母表中的对应字母。\n    3. **保持非字母字符不变**: 对空格、标点符号等非字母字符直接保留。\n    4. **输出最终结果**: 将所有加密后的字符组合成密文。\n    \n解密算法:\n\n    1. **生成加密字母表**: 根据关键词生成新的加密字母表，确保字母之间的映射规则一致。\n    2. **逐个字符替换**: 遍历密文字符，将加密字母表中的字母替换为标准字母表中的对应字母。\n    3. **保持非字母字符不变**: 对空格、标点符号等非字母字符直接保留。\n    4. **输出最终结果**: 将所有解密后的字符组合成明文。\n    ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    1. **去重关键词生成加密字母表**: 根据关键词生成一个新的字母表，去除重复字母并补全未使用的字母。\n    2. **逐个字母替换**: 遍历明文字符，将标准字母表中的字母替换为加密字母表中的对应字母。\n    3. **保持非字母字符不变**: 对空格、标点符号等非字母字符直接保留。\n    4. **输出最终结果**: 将所有加密后的字符组合成密文。\n    \n解密算法:\n\n    1. **生成加密字母表**: 根据关键词生成新的加密字母表，确保字母之间的映射规则一致。\n    2. **逐个字符替换**: 遍历密文字符，将加密字母表中的字母替换为标准字母表中的对应字母。\n    3. **保持非字母字符不变**: 对空格、标点符号等非字母字符直接保留。\n    4. **输出最终结果**: 将所有解密后的字符组合成明文。\n    "], "replace_en": ["Please decrypt the password according to the encryption and decryption algorithms.\n\nEncryption Algorithm:\n\n    1. **Generate Encrypted Alphabet by Removing Duplicate Keywords**: Create a new alphabet based on the keyword, remove duplicate letters and complete unused letters.\n    2. **Replace Letters Individually**: Traverse the plaintext characters, replace the letters in the standard alphabet with the corresponding letters in the encrypted alphabet.\n    3. **Keep Non-letter Characters Unchanged**: Directly retain non-letter characters such as spaces and punctuation marks.\n    4. **Output the Final Result**: Combine all encrypted characters into ciphertext.\n\nDecryption Algorithm:\n\n    1. **Generate Encrypted Alphabet**: Create a new encrypted alphabet based on the keyword, ensuring the mapping rules between letters are consistent.\n    2. **Replace Characters Individually**: Traverse the ciphertext characters, replace the letters in the encrypted alphabet with the corresponding letters in the standard alphabet.\n    3. **Keep Non-letter Characters Unchanged**: Directly retain non-letter characters such as spaces and punctuation marks.\n    4. **Output the Final Result**: Combine all decrypted characters into plaintext."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    加密规则\n    1. **字符替换**：根据给定的字母对映射规则，对原始文本中的字母进行替换。例如，将字母'V'替换为'I'，'I'替换为'V'，等等。注意：字母的大小写会进行相互替换，其他字符（如空格、标点符号）保持不变。\n    - 字母对映射表\n    {\n    'V': 'I', 'I': 'V', 'J': 'W', 'W': 'J', 'E': 'R', 'R': 'E',\n    'U': 'H', 'H': 'U', 'B': 'O', 'O': 'B', 'L': 'Y', 'Y': 'L',\n    'Q': 'D', 'D': 'Q', 'A': 'N', 'N': 'A', 'G': 'T', 'T': 'G',\n    'F': 'S', 'S': 'F', 'X': 'K', 'K': 'X', 'Z': 'M', 'M': 'Z',\n    'P': 'C', 'C': 'P',\n    'v': 'i', 'i': 'v', 'j': 'w', 'w': 'j', 'e': 'r', 'r': 'e',\n    'u': 'h', 'h': 'u', 'b': 'o', 'o': 'b', 'l': 'y', 'y': 'l',\n    'q': 'd', 'd': 'q', 'a': 'n', 'n': 'a', 'g': 't', 't': 'g',\n    'f': 's', 's': 'f', 'x': 'k', 'k': 'x', 'z': 'm', 'm': 'z',\n    'p': 'c', 'c': 'p'\n}\n    2. **16进制ASCII编码**：将替换后的文本转换为16进制表示的ASCII码，每个字符的ASCII码用16进制表示。例如，字母'H'的ASCII码是72，转换为16进制后为'48'。\n    3. **输出加密结果**：最后，返回加密后的消息，以16进制格式输出。\n    \n解密算法:\n\n    解密规则\n    1. **接收加密的密文（16进制格式）**：接收加密的密文，并将其转换为ASCII字符。\n    2. **16进制到ASCII转换**：将16进制密文转化为对应的字符。\n    3. **字符替换**：使用16进制到ASCII转换后的字符作为基础，按预定义的字母对规则进行替换。字母对规则中包含大小写字母的互换，每对字母之间进行反向替换。保持空格、标点符号等字符不变。\n    4. **组合成解密后的英文句子**：最终将替换后的字符组合成可读的英文句子。\n    ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    加密规则\n    1. **字符替换**：根据给定的字母对映射规则，对原始文本中的字母进行替换。例如，将字母'V'替换为'I'，'I'替换为'V'，等等。注意：字母的大小写会进行相互替换，其他字符（如空格、标点符号）保持不变。\n    - 字母对映射表\n    {\n    'V': 'I', 'I': 'V', 'J': 'W', 'W': 'J', 'E': 'R', 'R': 'E',\n    'U': 'H', 'H': 'U', 'B': 'O', 'O': 'B', 'L': 'Y', 'Y': 'L',\n    'Q': 'D', 'D': 'Q', 'A': 'N', 'N': 'A', 'G': 'T', 'T': 'G',\n    'F': 'S', 'S': 'F', 'X': 'K', 'K': 'X', 'Z': 'M', 'M': 'Z',\n    'P': 'C', 'C': 'P',\n    'v': 'i', 'i': 'v', 'j': 'w', 'w': 'j', 'e': 'r', 'r': 'e',\n    'u': 'h', 'h': 'u', 'b': 'o', 'o': 'b', 'l': 'y', 'y': 'l',\n    'q': 'd', 'd': 'q', 'a': 'n', 'n': 'a', 'g': 't', 't': 'g',\n    'f': 's', 's': 'f', 'x': 'k', 'k': 'x', 'z': 'm', 'm': 'z',\n    'p': 'c', 'c': 'p'\n}\n    2. **16进制ASCII编码**：将替换后的文本转换为16进制表示的ASCII码，每个字符的ASCII码用16进制表示。例如，字母'H'的ASCII码是72，转换为16进制后为'48'。\n    3. **输出加密结果**：最后，返回加密后的消息，以16进制格式输出。\n    \n解密算法:\n\n    解密规则\n    1. **接收加密的密文（16进制格式）**：接收加密的密文，并将其转换为ASCII字符。\n    2. **16进制到ASCII转换**：将16进制密文转化为对应的字符。\n    3. **字符替换**：使用16进制到ASCII转换后的字符作为基础，按预定义的字母对规则进行替换。字母对规则中包含大小写字母的互换，每对字母之间进行反向替换。保持空格、标点符号等字符不变。\n    4. **组合成解密后的英文句子**：最终将替换后的字符组合成可读的英文句子。\n    "], "replace_en": ["Please decrypt the password according to the encryption and decryption algorithms.\n\nEncryption Algorithm:\n\n    Encryption Rules\n    1. **Character Replacement**: Replace the letters in the original text according to the given letter pair mapping rules. For example, replace the letter 'V' with 'I', 'I' with 'V', and so on. Note: The case of the letters will be swapped, while other characters (such as spaces, punctuation marks) remain unchanged.\n    - Letter Pair Mapping Table\n    {\n    'V': 'I', 'I': 'V', 'J': 'W', 'W': 'J', 'E': 'R', 'R': 'E',\n    'U': 'H', 'H': 'U', 'B': 'O', 'O': 'B', 'L': 'Y', 'Y': 'L',\n    'Q': 'D', 'D': 'Q', 'A': 'N', 'N': 'A', 'G': 'T', 'T': 'G',\n    'F': 'S', 'S': 'F', 'X': 'K', 'K': 'X', 'Z': 'M', 'M': 'Z',\n    'P': 'C', 'C': 'P',\n    'v': 'i', 'i': 'v', 'j': 'w', 'w': 'j', 'e': 'r', 'r': 'e',\n    'u': 'h', 'h': 'u', 'b': 'o', 'o': 'b', 'l': 'y', 'y': 'l',\n    'q': 'd', 'd': 'q', 'a': 'n', 'n': 'a', 'g': 't', 't': 'g',\n    'f': 's', 's': 'f', 'x': 'k', 'k': 'x', 'z': 'm', 'm': 'z',\n    'p': 'c', 'c': 'p'\n}\n    2. **Hexadecimal ASCII Encoding**: Convert the replaced text into hexadecimal ASCII codes, with each character's ASCII code represented in hexadecimal. For example, the ASCII code for the letter 'H' is 72, which is '48' in hexadecimal.\n    3. **Output Encrypted Result**: Finally, return the encrypted message in hexadecimal format.\n\nDecryption Algorithm:\n\n    Decryption Rules\n    1. **Receive Encrypted Cipher Text (in Hexadecimal Format)**: Receive the encrypted cipher text and convert it into ASCII characters.\n    2. **Hexadecimal to ASCII Conversion**: Convert the hexadecimal cipher text into corresponding characters.\n    3. **Character Replacement**: Based on the characters obtained from the hexadecimal to ASCII conversion, replace them according to the predefined letter pair rules. The letter pair rules include swapping of uppercase and lowercase letters, with each pair of letters being replaced in reverse. Keep spaces, punctuation marks, and other characters unchanged.\n    4. **Combine into Decrypted English Sentence**: Finally, combine the replaced characters into a readable English sentence."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    1. 去除输入句子的前导和尾随空格。\n    2. 将每个字母或数字映射为其对应的摩尔斯电码，并在每个摩尔斯电码后添加一个斜杠 `/`。将每个既不是字母也不是数字的字符映射为斜杠 `/`，得到初始字符串。\n    3. 将初始字符串中的每个点 `.` 替换为字母 `B`，将每个划线 `-` 替换为字母 `W`。\n    4. 检查字符串长度是否能被 8 整除。如果不能，用斜杠 `/` 填充字符串，使其长度能被 8 整除。\n    5. 在字符串的每 8 个字符之间插入换行符 `\n`，确保没有尾随的换行符。这将是最终的加密字符串。\n    \n解密算法:\n\n    1. 去除字符串中的所有换行符 `\n`。\n    2. 去除字符串的前导和尾随斜杠 `/`。\n    3. 使用斜杠 `/` 作为分隔符，将字符串拆分为子字符串列表。\n    4. 对每个子字符串，将 `B` 替换为点 `.`，将 `W` 替换为划线 `-`，将其他字符替换为空格 ` `。\n    5. 现在，每个子字符串要么是摩尔斯电码，要么是空格。如果子字符串是摩尔斯电码，将其映射为对应的字母或数字。否则，保留为空格。\n    6. 最后，将所有字母、数字和空格连接在一起，得到明文。\n    ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n\n    1. 去除输入句子的前导和尾随空格。\n    2. 将每个字母或数字映射为其对应的摩尔斯电码，并在每个摩尔斯电码后添加一个斜杠 `/`。将每个既不是字母也不是数字的字符映射为斜杠 `/`，得到初始字符串。\n    3. 将初始字符串中的每个点 `.` 替换为字母 `B`，将每个划线 `-` 替换为字母 `W`。\n    4. 检查字符串长度是否能被 8 整除。如果不能，用斜杠 `/` 填充字符串，使其长度能被 8 整除。\n    5. 在字符串的每 8 个字符之间插入换行符 `\n`，确保没有尾随的换行符。这将是最终的加密字符串。\n    \n解密算法:\n\n    1. 去除字符串中的所有换行符 `\n`。\n    2. 去除字符串的前导和尾随斜杠 `/`。\n    3. 使用斜杠 `/` 作为分隔符，将字符串拆分为子字符串列表。\n    4. 对每个子字符串，将 `B` 替换为点 `.`，将 `W` 替换为划线 `-`，将其他字符替换为空格 ` `。\n    5. 现在，每个子字符串要么是摩尔斯电码，要么是空格。如果子字符串是摩尔斯电码，将其映射为对应的字母或数字。否则，保留为空格。\n    6. 最后，将所有字母、数字和空格连接在一起，得到明文。\n    "], "replace_en": ["Please decrypt the password according to the encryption and decryption algorithms.\n\nEncryption Algorithm:\n\n    1. Remove the leading and trailing spaces of the input sentence.\n    2. Map each letter or number to its corresponding Morse code, and add a slash `/` after each Morse code. Map each character that is neither a letter nor a number to a slash `/`, to get the initial string.\n    3. Replace each dot `.` in the initial string with the letter `B`, and replace each dash `-` with the letter `W`.\n    4. Check if the length of the string can be divided by 8. If not, fill the string with slashes `/` to make its length divisible by 8.\n    5. Insert a newline character `\n` every 8 characters in the string, ensuring there is no trailing newline. This will be the final encrypted string.\n    \nDecryption Algorithm:\n\n    1. Remove all newline characters `\n` in the string.\n    2. Remove the leading and trailing slashes `/` of the string.\n    3. Use the slash `/` as a delimiter to split the string into a list of substrings.\n    4. For each substring, replace `B` with dot `.`, replace `W` with dash `-`, and replace other characters with space ` `.\n    5. Now, each substring is either Morse code or a space. If the substring is Morse code, map it to the corresponding letter or number. Otherwise, keep it as a space.\n    6. Finally, connect all letters, numbers, and spaces to get the plaintext."]}
{"rule": "请根据加密算法对明文进行加密\nAtbash 密码的编码规则是将每个字母替换为其在字母表中的反向对应字母。例如，'A' 变成 'Z'，'B' 变成 'Y'，依此类推。非字母字符保持不变。", "replace": ["请根据加密算法对明文进行加密\nAtbash 密码的编码规则是将每个字母替换为其在字母表中的反向对应字母。例如，'A' 变成 'Z'，'B' 变成 'Y'，依此类推。非字母字符保持不变。", "使用Atbash加密方法对原始文本进行编码。该加密方式是将每个英文字母转换为字母表中相对位置的字母，即A对应Z，B对应Y，以此类推。加密时，所有非字母的字符维持原样不变。", "按照以下规则将原始文本进行编码转换:使用Atbash加密方式,该方式要求把每个英文字母替换成字母表中相对应的反向字母,比如把'A'换成'Z','B'换成'Y'等。对于文本中的非字母内容,则保留原样不做改变。", "按照 Atbash 加密方式对原始文本进行转换。这种加密方法是将每个英文字母替换为字母表中相对位置相反的字母，比如用'Z'代替'A'，用'Y'代替'B'等。其他不是字母的符号则维持原样不变。", "按照以下方式对原文进行编码:使用Atbash加密方法,该方法将每个英文字母替换为字母表中相对位置相反的字母。具体来说,A对应Z,B对应Y,C对应X等。注意,对于非字母的字符(如数字、标点符号等),应保持原样不变。", "使用加密规则将原始文本转换为密文。加密方式采用Atbash算法,该算法的原理是:把每个英文字母替换为字母表中相对位置相反的字母,比如字母表首位的'A'对应末位的'Z',第二位的'B'对应倒数第二位的'Y'等。对于文本中的非字母内容(如数字、标点符号等),保持原样不做改变。"], "replace_en": ["Encrypt the plaintext using the following cipher:\nThe Atbash cipher works by substituting each letter with its opposite counterpart from the alphabet. For instance, 'A' is replaced with 'Z', 'B' becomes 'Y', and so on in this pattern. Any character that isn't a letter remains unchanged in the output.", "Encrypt the plaintext using the Atbash cipher method. In this encryption scheme, each letter is replaced with its corresponding letter from the opposite end of the alphabet. For instance, 'A' is encoded as 'Z', 'B' becomes 'Y', and so forth. Any characters that are not letters remain unchanged in the output.", "Encrypt the plaintext using the following encryption method:\nThe Atbash cipher works by substituting each letter with its opposite counterpart from the alphabet. For instance, if you see 'A', write 'Z'; if you see 'B', write 'Y'; and so forth. Any characters that aren't letters should remain unchanged.", "To encode a message, apply the Atbash cipher encryption method. This encryption technique works by substituting each alphabetic character with its opposite letter from the alphabet - meaning you replace 'A' with 'Z', 'B' with 'Y', and so forth through the alphabet. Any characters that aren't letters should remain unchanged in the encrypted message.", "Write an encrypted version of the plaintext using the Atbash cipher method. In this encryption system, each letter is replaced with its opposite counterpart from the alphabet - for instance, 'A' is encoded as 'Z', 'B' becomes 'Y', and so forth. Any characters that aren't letters should remain unchanged in the output."]}
{"rule": "请根据加密算法对明文进行加密\n加密规则：\n    1. 将输入文本中的每个字母向后移动指定的位数（shift）。\n    2. 输出加密后的文本。", "replace": ["请根据加密算法对明文进行加密\n加密规则：\n    1. 将输入文本中的每个字母向后移动指定的位数（shift）。\n    2. 输出加密后的文本。", "按照加密规则对输入的文本内容进行编码转换。具体要求如下:\n1. 对原始文本中的每个字母字符进行位移变换,位移量为指定的数值(shift)\n2. 将转换后的结果作为密文输出", "按照指定的加密方法处理原始文本，具体步骤是：\n1. 对输入的文字内容中的每个字母字符，按照预设的偏移量进行位移变换\n2. 显示经过加密转换后的结果文本", "按照指定的加密方案，把原始文字内容进行编码转换。具体步骤是:\n1. 对输入的原文中每个字母字符，按照设定的偏移量进行位移变换\n2. 输出经过加密处理后的密文结果", "按照加密方案对原始文本进行编码\n具体加密步骤:\n    1. 对输入的原文中每个字母字符进行位移变换,移动指定数量的位置\n    2. 返回经过加密处理后的密文结果", "依照加密方案对原始文字进行编码处理\n具体加密步骤:\n    1. 对输入的原文中的每个字母字符,按指定的偏移量(shift)进行位移变换\n    2. 输出经过加密转换后的密文内容"], "replace_en": ["Write a program to encrypt a plaintext message using the following encryption rules:\n- Each letter in the input text should be shifted forward in the alphabet by a specified number of positions\n- The program should output the encrypted message after applying the shift cipher", "Here's how to encrypt your message:\nFollow these encryption steps:\n    1. Take each letter in your input text and shift it forward in the alphabet by the specified number of positions.\n    2. The resulting text will be your encrypted message.", "Please encrypt the input text using the following encryption method:\n- Each letter in the input text should be shifted forward by a specified number of positions\n- The encrypted result will be displayed as output\n\nNote: This is a letter substitution cipher where characters are displaced based on the given shift value.", "To encrypt your message, please follow these steps:\n1. Each letter in your original text will be shifted forward in the alphabet by a specified number of positions\n2. The result will be your encrypted message\n\nNote: This encryption method converts plaintext into ciphertext by applying the designated shift value to each alphabetical character.", "To encrypt the plaintext, follow these steps:\n- Take each letter in your input message\n- Apply the specified shift value to move each character forward in the alphabet\n- Generate the encrypted output using the shifted characters"]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n对于每一个编码前的字母，计算其在字母表中的位置，然后找到两个可能的原始字母位置，这些位置的平均值等于编码后的字母位置。选择一个合理的字母对作为编码结果。\n解密算法:\n对于每一对字母，计算它们在字母表中的位置，然后取这两个位置的平均值，再转换成对应的字母。", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n对于每一个编码前的字母，计算其在字母表中的位置，然后找到两个可能的原始字母位置，这些位置的平均值等于编码后的字母位置。选择一个合理的字母对作为编码结果。\n解密算法:\n对于每一对字母，计算它们在字母表中的位置，然后取这两个位置的平均值，再转换成对应的字母。"], "replace_en": ["Please decrypt the password based on the encryption and decryption algorithms.\n\nEncryption Algorithm:\nFor each letter before encoding, calculate its position in the alphabet, then find two possible original letter positions whose average equals the position of the encoded letter. Choose a reasonable letter pair as the encoding result.\n\nDecryption Algorithm:\nFor each pair of letters, calculate their positions in the alphabet, then take the average of these two positions, and convert it back to the corresponding letter."]}
{"rule": "请根据加密算法对明文进行加密\n加密方案概述：将字符串转换为ASCII编码。", "replace": ["请根据加密算法对明文进行加密\n加密方案概述：将字符串转换为ASCII编码。"], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm.\nOverview of the encryption scheme: Convert the string to ASCII encoding."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则：\n1. 将输入文本中的每个字母向后移动指定的位数（shift）。\n2. 输出加密后的文本。\n解密算法:\n解码规则：\n1. 将输入文本中的每个字母向前移动指定的位数（shift）。\n2. 输出解密后的文本。", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密规则：\n1. 将输入文本中的每个字母向后移动指定的位数（shift）。\n2. 输出加密后的文本。\n解密算法:\n解码规则：\n1. 将输入文本中的每个字母向前移动指定的位数（shift）。\n2. 输出解密后的文本。"], "replace_en": ["Please decrypt the password according to the encryption algorithm and decryption algorithm.\nEncryption Algorithm:\nEncryption Rules:\n1. Shift each letter in the input text forward by a specified number of positions (shift).\n2. Output the encrypted text.\nDecryption Algorithm:\nDecryption Rules:\n1. Shift each letter in the input text backward by a specified number of positions (shift).\n2. Output the decrypted text."]}
{"rule": "请根据加密算法对明文进行加密\n解题方案：\n1. 构建3个矩阵：默认字母表矩阵M_T，加密矩阵M1和M2（由str1和str2生成）。\n2. 将明文文本转换为大写字母，仅保留字母字符并分成两个字母一组。\n3. 对每对字母进行加密：\n   - 查找每个字母在默认矩阵中的位置，交换其y坐标，\n   - 根据新坐标从M1和M2矩阵中取出加密后的字母对。\n4. 输出加密后的文本。", "replace": ["请根据加密算法对明文进行加密\n解题方案：\n1. 构建3个矩阵：默认字母表矩阵M_T，加密矩阵M1和M2（由str1和str2生成）。\n2. 将明文文本转换为大写字母，仅保留字母字符并分成两个字母一组。\n3. 对每对字母进行加密：\n   - 查找每个字母在默认矩阵中的位置，交换其y坐标，\n   - 根据新坐标从M1和M2矩阵中取出加密后的字母对。\n4. 输出加密后的文本。"], "replace_en": ["Please encrypt the plaintext using the encryption algorithm.\n\nSolution:\n1. Construct three matrices: the default alphabet matrix M_T, and the encryption matrices M1 and M2 (generated from str1 and str2).\n2. Convert the plaintext to uppercase, retain only the letter characters, and split them into pairs of two letters.\n3. Encrypt each pair of letters:\n   - Find the position of each letter in the default matrix, swap their y-coordinates,\n   - Retrieve the encrypted letter pair from the M1 and M2 matrices based on the new coordinates.\n4. Output the encrypted text."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n解题方案：\n1. 构建3个矩阵：默认字母表矩阵M_T，加密矩阵M1和M2（由str1和str2生成）。\n2. 将明文文本转换为大写字母，仅保留字母字符并分成两个字母一组。\n3. 对每对字母进行加密：\n   - 查找每个字母在默认矩阵中的位置，交换其y坐标，\n   - 根据新坐标从M1和M2矩阵中取出加密后的字母对。\n4. 输出加密后的文本。\n解密算法:\n解题方案：\n1. 构建3个矩阵：默认字母表矩阵M_T，加密矩阵M1和M2（由str1和str2生成）。\n2. 将密文按两个字母一组分组。\n3. 对每对加密字母进行解密：\n   - 在M1和M2中找到加密字母的位置，交换列坐标\n   - 从默认矩阵中获取对应的明文字母。\n4. 输出解密后的文本。", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n解题方案：\n1. 构建3个矩阵：默认字母表矩阵M_T，加密矩阵M1和M2（由str1和str2生成）。\n2. 将明文文本转换为大写字母，仅保留字母字符并分成两个字母一组。\n3. 对每对字母进行加密：\n   - 查找每个字母在默认矩阵中的位置，交换其y坐标，\n   - 根据新坐标从M1和M2矩阵中取出加密后的字母对。\n4. 输出加密后的文本。\n解密算法:\n解题方案：\n1. 构建3个矩阵：默认字母表矩阵M_T，加密矩阵M1和M2（由str1和str2生成）。\n2. 将密文按两个字母一组分组。\n3. 对每对加密字母进行解密：\n   - 在M1和M2中找到加密字母的位置，交换列坐标\n   - 从默认矩阵中获取对应的明文字母。\n4. 输出解密后的文本。"], "replace_en": ["Please decrypt the password based on the encryption and decryption algorithms.\n\nEncryption Algorithm:\nSolution:\n1. Construct three matrices: the default alphabet matrix M_T, and the encryption matrices M1 and M2 (generated from str1 and str2).\n2. Convert the plaintext to uppercase, retain only the letter characters, and split them into pairs of two letters.\n3. Encrypt each pair of letters:\n   - Find the position of each letter in the default matrix, swap their y-coordinates,\n   - Retrieve the encrypted letter pair from the M1 and M2 matrices based on the new coordinates.\n4. Output the encrypted text.\n\nDecryption Algorithm:\nSolution:\n1. Construct three matrices: the default alphabet matrix M_T, and the encryption matrices M1 and M2 (generated from str1 and str2).\n2. Group the ciphertext into pairs of two letters.\n3. Decrypt each pair of encrypted letters:\n   - Find the positions of the encrypted letters in M1 and M2, swap their column coordinates,\n   - Retrieve the corresponding plaintext letters from the default matrix.\n4. Output the decrypted text."]}
{"rule": "请根据加密算法对明文进行加密\n加密规则：\n1. 将输入文本中的每个字母向后移动指定的位数（shift）。\n2. 输出加密后的文本。", "replace": ["请根据加密算法对明文进行加密\n加密规则：\n1. 将输入文本中的每个字母向后移动指定的位数（shift）。\n2. 输出加密后的文本。"], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm.\nEncryption rules:\n1. Shift each letter in the input text forward by a specified number of positions (shift).\n2. Output the encrypted text."]}
{"rule": "请根据加密算法对明文进行加密\n对于每一个编码前的字母，计算其在字母表中的位置，然后找到两个可能的原始字母位置，这些位置的平均值等于编码后的字母位置。选择一个合理的字母对作为编码结果。", "replace": ["请根据加密算法对明文进行加密\n对于每一个编码前的字母，计算其在字母表中的位置，然后找到两个可能的原始字母位置，这些位置的平均值等于编码后的字母位置。选择一个合理的字母对作为编码结果。"], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm. For each letter before encoding, calculate its position in the alphabet, then find two possible original letter positions whose average equals the position of the encoded letter. Choose a reasonable letter pair as the encoding result."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密方案概述：将字符串转换为ASCII编码。\n解密算法:\n解密方案概述：遍历ASCII编码字符串,返回转换后的字符串", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密方案概述：将字符串转换为ASCII编码。\n解密算法:\n解密方案概述：遍历ASCII编码字符串,返回转换后的字符串"], "replace_en": ["Please decrypt the password based on the encryption and decryption algorithms.\nEncryption Algorithm:\nOverview of the encryption scheme: Convert the string to ASCII encoding.\nDecryption Algorithm:\nOverview of the decryption scheme: Traverse the ASCII encoded string and return the converted string."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密方案概述：\n        1. 过滤掉非字母字符并转换为大写。\n        2. 将每个字母转换为对应的3D坐标。\n        3. 将3D坐标重新组合，每三个字符一组。\n        4. 根据新的坐标组在3D立方体中找到对应的字母，生成密文。\n        5. 按照加密逻辑，将密文输出。\n        \n解密算法:\n解密方案概述：\n        1. 将密文转换为大写字母。\n        2. 将密文转换为对应的3D坐标。\n        3. 将3D坐标重新组合，每三个字符一组。\n        4. 根据新的坐标组在3D立方体中找到对应的字母，生成明文。\n        5. 按照解密逻辑，将明文输出。\n        ", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\n加密方案概述：\n        1. 过滤掉非字母字符并转换为大写。\n        2. 将每个字母转换为对应的3D坐标。\n        3. 将3D坐标重新组合，每三个字符一组。\n        4. 根据新的坐标组在3D立方体中找到对应的字母，生成密文。\n        5. 按照加密逻辑，将密文输出。\n        \n解密算法:\n解密方案概述：\n        1. 将密文转换为大写字母。\n        2. 将密文转换为对应的3D坐标。\n        3. 将3D坐标重新组合，每三个字符一组。\n        4. 根据新的坐标组在3D立方体中找到对应的字母，生成明文。\n        5. 按照解密逻辑，将明文输出。\n        "], "replace_en": ["Please decrypt the password based on the encryption and decryption algorithms.\n\nEncryption Algorithm:\nOverview of the encryption scheme:\n1. Filter out non-alphabetic characters and convert to uppercase.\n2. Convert each letter to its corresponding 3D coordinates.\n3. Reorganize the 3D coordinates, grouping every three characters together.\n4. Find the corresponding letters in the 3D cube based on the new coordinate groups to generate the ciphertext.\n5. Output the ciphertext according to the encryption logic.\n\nDecryption Algorithm:\nOverview of the decryption scheme:\n1. Convert the ciphertext to uppercase letters.\n2. Convert the ciphertext to its corresponding 3D coordinates.\n3. Reorganize the 3D coordinates, grouping every three characters together.\n4. Find the corresponding letters in the 3D cube based on the new coordinate groups to generate the plaintext.\n5. Output the plaintext according to the decryption logic."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\nTap Code 是一种简单的密码技术，每个字母由一个点模式表示。模式通过计算行和列中的点数来编码。例如，字母 'A' 由第一行和第一列的一个点表示。\n解密算法:\n要解码 Tap Code，需要计算每一行和每一列中的点数。通过查找表格中的位置，可以确定对应的字母。", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\nTap Code 是一种简单的密码技术，每个字母由一个点模式表示。模式通过计算行和列中的点数来编码。例如，字母 'A' 由第一行和第一列的一个点表示。\n解密算法:\n要解码 Tap Code，需要计算每一行和每一列中的点数。通过查找表格中的位置，可以确定对应的字母。"], "replace_en": ["Please decrypt the password based on the encryption and decryption algorithms.\nEncryption Algorithm:\nTap Code is a simple cryptographic technique where each letter is represented by a dot pattern. The pattern is encoded by counting the number of dots in the rows and columns. For example, the letter 'A' is represented by a single dot in the first row and the first column.\nDecryption Algorithm:\nTo decode Tap Code, you need to count the number of dots in each row and column. By finding the position in the table, you can determine the corresponding letter."]}
{"rule": "请根据加密算法对明文进行加密\nTap Code 是一种简单的密码技术，每个字母由一个点模式表示。模式通过计算行和列中的点数来编码。例如，字母 'A' 由第一行和第一列的一个点表示。", "replace": ["请根据加密算法对明文进行加密\nTap Code 是一种简单的密码技术，每个字母由一个点模式表示。模式通过计算行和列中的点数来编码。例如，字母 'A' 由第一行和第一列的一个点表示。"], "replace_en": ["Please encrypt the plaintext using the encryption algorithm.\nTap Code is a simple cipher technique where each letter is represented by a dot pattern. The pattern is encoded by counting the dots in the rows and columns. For example, the letter 'A' is represented by a single dot in the first row and first column."]}
{"rule": "请根据加密算法对明文进行加密\n加密方案概述：\n        1. 过滤掉非字母字符并转换为大写。\n        2. 将每个字母转换为对应的3D坐标。\n        3. 将3D坐标重新组合，每三个字符一组。\n        4. 根据新的坐标组在3D立方体中找到对应的字母，生成密文。\n        5. 按照加密逻辑，将密文输出。\n        ", "replace": ["请根据加密算法对明文进行加密\n加密方案概述：\n        1. 过滤掉非字母字符并转换为大写。\n        2. 将每个字母转换为对应的3D坐标。\n        3. 将3D坐标重新组合，每三个字符一组。\n        4. 根据新的坐标组在3D立方体中找到对应的字母，生成密文。\n        5. 按照加密逻辑，将密文输出。\n        "], "replace_en": ["Please encrypt the plaintext according to the encryption algorithm.\n\nOverview of the encryption scheme:\n1. Filter out non-alphabetic characters and convert the remaining characters to uppercase.\n2. Convert each letter to its corresponding 3D coordinates.\n3. Reorganize the 3D coordinates, grouping every three characters together.\n4. Find the corresponding letters in the 3D cube based on the new coordinate groups to generate the ciphertext.\n5. Output the ciphertext according to the encryption logic."]}
{"rule": "请根据加密算法和解密算法对密码进行解密\n加密算法:\nAtbash 密码的编码规则是将每个字母替换为其在字母表中的反向对应字母。例如，'A' 变成 'Z'，'B' 变成 'Y'，依此类推。非字母字符保持不变。\n解密算法:\nAtbash 密码的解码规则是将每个字母替换为其在字母表中的反向对应字母。由于 Atbash 密码是对称的，解码过程与编码过程相同。例如，'Z' 变成 'A'，'Y' 变成 'B'，依此类推。非字母字符保持不变。", "replace": ["请根据加密算法和解密算法对密码进行解密\n加密算法:\nAtbash 密码的编码规则是将每个字母替换为其在字母表中的反向对应字母。例如，'A' 变成 'Z'，'B' 变成 'Y'，依此类推。非字母字符保持不变。\n解密算法:\nAtbash 密码的解码规则是将每个字母替换为其在字母表中的反向对应字母。由于 Atbash 密码是对称的，解码过程与编码过程相同。例如，'Z' 变成 'A'，'Y' 变成 'B'，依此类推。非字母字符保持不变。"], "replace_en": ["Please decrypt the password according to the encryption and decryption algorithms.\n\nEncryption Algorithm:\nThe Atbash cipher encoding rule is to replace each letter with its reverse corresponding letter in the alphabet. For example, 'A' becomes 'Z', 'B' becomes 'Y', and so on. Non-letter characters remain unchanged.\n\nDecryption Algorithm:\nThe Atbash cipher decoding rule is to replace each letter with its reverse corresponding letter in the alphabet. Since the Atbash cipher is symmetric, the decoding process is the same as the encoding process. For example, 'Z' becomes 'A', 'Y' becomes 'B', and so on. Non-letter characters remain unchanged."]}
